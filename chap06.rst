.. -*- coding: utf-8 -*-

.. highlight:: fortran
  :linenothreshold: 1

====================================
書式指定・ファイル入出力・文字列処理
====================================

.. highlight:: fortran
  :linenothreshold: 1

ここではこれまではオマジナイとして使ってきた ``write(*,*)`` や ``read(*,*)`` の意味を理解し，ファイル入出力や，出力時の書式指定の仕方，さらには文字列処理の方法について学ぼう．

    サンプルプログラム

    - `sample1.f90 <sample/chap06/sample1.f90>`_ : 書式指定
    - `sample2.f90 <sample/chap06/sample2.f90>`_ : ファイル入出力(アスキー形式)
    - `sample3.f90 <sample/chap06/sample3.f90>`_ : ファイル入出力(バイナリ形式)
    - `sample4.f90 <sample/chap06/sample4.f90>`_ : 文字列処理
    - `sample5.f90 <sample/chap06/sample5.f90>`_ : ファイル各行の逐次処理

.. contents:: この章の内容
    :depth: 2

書式指定
--------

実は ``write(*,*)`` の2つめの引数は出力される値の書式を表す **編集記述子** を指定するためのもので，"``*`` "はデフォルトの書式を意味している(従って一般にコンパイラによって出力の書式は異なる)．ここに決められた形式で書式を指定することで桁を揃えたりして，綺麗な出力を得ることが出来る．例えば

::

      character(len=128) :: fmt
      integer :: year = 2014

      write(*, '(i6)') year

      fmt = '(i6)'
      write(*, fmt) year

のように ``*`` の代わりの編集記述子(ここでは ``'(i6)'`` や ``fmt``)を指定することになる．4行目のように直接指定しても良いし，7行目のように文字型の変数を用いてもどちらでも構わない．

さて，問題は書式の指定の仕方(上の例では ``i6``)についてである．書式指定の詳細については適宜他の文献 [#]_ を参照してもらうとして，ここでは以下の表に挙げる典型的な例を理解しておけば良い．

.. tabularcolumns:: |p{0.1 \textwidth}|p{0.1 \textwidth}|p{0.1 \textwidth}|p{0.6 \textwidth}|
.. list-table:: 編集記述子の使い方の例
    :widths: 10, 10, 10, 60
    :header-rows: 1

    * - データ型
      - 記述子
      - 例
      - 例の説明

    * - 整数型
      - ``I``
      - ``i6``
      - 6桁で出力する．

    * -
      -
      - ``i8.6``
      - 8桁で出力する．
        ただし6桁に満たない部分は0で埋められる．

    * - 実数
      - ``F``
      - ``f12.5``
      - 12桁で出力，うち5桁が小数点以下．

    * -
      - ``E``
      - ``e20.7``
      - 科学的表記 [#]_ の20桁で出力，うち7桁が小数点以下．

    * - 文字型
      - ``A``
      - ``a``
      - 与えられた文字型の字数に対応する桁数を確保して出力．

    * -
      -
      - ``a30``
      - 30桁で右寄せの出力．


    * - 空白
      - ``X``
      - ``5X``
      - 指定された数だけ空白を出力．この場合は5桁．

    * - 改行
      - ``/``
      - ``/``
      - 改行される．

上の表は編集記述子の使い方の典型的な例を示している．基本的には **編集記述子** と **表示桁数** の組み合わせの形で表すことになっている．以下にいくつか注意点を挙げておこう:

-  数値データは指定された書式で出力が出来ない場合の出力は **全て ``*`` が出力されてしまう** ので気をつけよう．実数データの出力では符号，小数点，指数部の桁数を考慮しなくてはならないので，``E`` 型記述子では 全桁数 :math:`\geq` 小数部の桁数 + 6 となっている必要がある．``F`` 型編集記述子の場合はデータ(整数部の桁数)に依存するが少なくとも 全桁数 :math:`\geq` 小数部の桁数 + 2 が必要である．これは以下のような例によって確認することが出来る．

::

      write(*,'(f5.3)') 3.1415      ! これはOK
      write(*,'(f5.3)') 3.1415 * 10 ! これはダメ
      write(*,'(e9.3)') 3.1415      ! これはOK
      write(*,'(e5.3)') 3.1415      ! これはダメ

-  文字型データでは，桁数が渡された文字数よりも少ない場合は文字型の先頭から桁数分だけが出力される．

-  複数の編集記述子をカンマ" ``,`` "で区切って並べることが出来る．この際に，編集記述子ではない通常の文字列も同様にカンマで区切って並べることが出来る．ただし指定子の文字列が" ``'`` "(シングルクオート)で区切られている場合には，その中の文字列は" ``"`` "(ダブルクオート)で囲まなければならない．使い方は以下の通りである．

::

      ! 複数の記述子を並べる
      write(*,'(e10.3, e10.3, e10.3)') x, y, z

      ! 文字列および改行を使う
      write(*,'("x = ", e10.3, /, "y = ", e10.3, /, "z = ", e10.3)') x, y, z

-  同じ書式指定子を複数回繰り返す場合には書式指定子の前に繰り返す回数を指定する省略記法が使える．例えば ``'(a10, 3i5)'`` は ``'(a10, i5, i5, i5)'`` と等しい．

なお ``read(*,*)`` についても同様の指定が可能であるが，それほど必要な場面はないかもしれない．一つ考えられるのはスペースを含んだ文字列(例えばファイルの1行分)を一つの文字型変数に読み込みたいときであろう．このときには

::

     character(128) :: text

     read(*, '(a)') text

のように ``'(a)'`` を指定しないとスペースまでの文字列が ``text`` に取り込まれてしまう．これはFortranがデフォルトでスペースや改行などを変数の区切りとして読み込んでしまうからである．

また書式指定は ``write(*, fmt='(a)')`` のように行うこともできる [#]_．他には改行を抑制するために ``advance='no'`` のような指定も使うことがしばしばあるので覚えておいて損はない．Fortranでは通常 ``write`` 文によって最後に自動的に改行が挿入されてしまうが,

::

      write(*, fmt='(a)', advance='no') 'Input some text : '

のようにすれば ``'Input some text : '`` が表示された後に改行されない．

.. _c6_file_io:

ファイル入出力
--------------

``open`` と ``close``
~~~~~~~~~~~~~~~~~~~~~~~

これまではファイルから何らかのデータを読み込んだり，ファイルに出力する時にはシェルのリダイレクト機能を用いてきた．しかし，これだと例えば複数のファイルから別々に違うデータを読み込んだり，複数ファイルへの出力などの柔軟は処理はできない．このような場合にはソースコードの中で明示的に入出力に用いるファイルを指定し，そのファイルに対する入出力処理を行うように指定しなければならない．Fortranプログラムからファイルを開くには ``open`` 文を用いることになる．例えば以下の例は予め存在しないファイル ``filename.dat`` を新規作成して開く．(この例では，ファイルが既に存在している時にはエラーとなる．)

::

      open(unit=10, iostat=ios, file='filename.dat', action='write', &
           & form='formatted', status='new')

``open`` には多くの引数を指定することになる．(あまりに多いので通常は :ref:`c7_optional_keyword` で必要なものだけ渡す．) それぞれの意味は以下の様なものである．

unit
    装置番号を指定する．装置番号とはファイルを特徴付ける一意な整数である．なお標準入力は5，標準出力は6，標準エラー出力は0，と予め決められているのでこれら以外の値を指定すること．1つのプログラム中で同時に複数のファイルを開く際には違う値を指定しなければならない．自分でプログラムを書く際には10以上の重複しない整数にしておくのが無難である．

iostat
    ここに指定した変数に ``open`` 文の終了ステータスが格納される．ファイルが正常に開けた場合には ``0``，そうでない場合には ``0`` 以外の値が返される．この変数をチェックすることでエラーチェックをするのが定石である．

file
    ファイル名を指定する．

action
    ファイルに対する操作を指定する．読み取り専用なら ``read``，書き込み専用なら ``write``，読み書きどちらもしたい場合には ``readwrite`` を指定する．デフォルトでは(可能ならば) ``readwrite`` となる．

form
    アスキー形式(書式付き)なら ``formatted``，バイナリ形式(書式なし)なら ``unformatted`` を指定する．デフォルトでは ``formatted`` となる．

status
    ファイルの状態を指定する．``new`` はファイルの新規作成を意味し，そのファイルが既に存在する時にはエラーが発生する．``replace`` も新規作成であるが，そのファイルが既に存在する場合は中身を破棄して空のファイルとして開く．``old`` は既に存在するファイルを開く．このときそのファイルが存在していない場合はエラーが発生する．他にも処理系依存の ``unknown`` があり，これがデフォルトである．

ファイルが正常に開けたかどうかは以下のようにチェックすることが出来る．

::

      if (ios /= 0) then
         write(*,*) 'Failed to open'
         stop
      end if

いちいちチェックするのは面倒なようだが，プログラミングにおいてこのようなエラーチェックは非常に大切なのでいつもチェックする癖をつけよう．プログラム作成の際にその半分がエラーチェックになるというのもよくある話である [#]_．

以下にいくつかよく使う例を挙げておこう．(念の為に言っておくと ``open`` に渡す引数の詳細を覚えておく必要は無い．大まかな使い方さえ知っておけば，後はgoogleで検索する方が早い．)

-  ファイルを新規作成する．ただしファイルが既に存在する場合にはその中身を破棄する(上書き)．

::

      open(unit=10, iostat=ios, file='ascii.dat', action='write', &
           & form='formatted', status='replace')

-  既に存在するファイルを開き，位置をファイル終端に指定する( ``position='append'`` )．既存のファイルの終端にデータを追加する場合に用いる．

::

      open(unit=10, iostat=ios, file='ascii.dat', action='write', &
           & form='formatted', status='old', position='append')

-  既に存在するファイルを読み込み専用で開き，位置をファイル先頭に指定する( ``position='rewind'``)．既存のファイルの先頭からデータを読み込む場合に用いる．ただし ``position=rewind`` は必ずしも指定しなくても良い．

::

      open(unit=10, iostat=ios, file='ascii.dat', action='read', &
           & form='formatted', status='old', position='rewind')

なお，``open`` で開いたファイルは ``close`` で閉じるのが作法である．ファイルを閉じないままプログラムが異常終了してしまうと，せっかくの結果が正しく出力されないこともあり得るので注意して欲しい．``close`` には ``open`` で開いた時に用いた装置番号を指定する．例えば装置番号が10であれば

::

      close(10)

とすれば良い．

アスキー(書式付き)入出力
~~~~~~~~~~~~~~~~~~~~~~~~

アスキー形式とかテキスト形式と呼ばれるファイルはテキストエディタや ``cat`` などのコマンドで人間が理解できる形で表示できるファイルである．アスキー形式でファイルを開くには ``open`` で ``form='formatted'`` と指定するのは既に説明した通りである．

開いたファイルへの入出力をするには，``write`` や ``read`` に装置番号を指定しなければならない．実はこれまで使ってきた ``write(*,*)`` や ``read(*,*)`` の1番目の引数は装置番号を意味するものである．ここでも"``*`` "はデフォルトの装置番号を意味し，通常は ``write`` であれば標準出力の6，``read`` であれば標準入力の5を指定したことと同じ意味となる．ここに ``open`` 文で指定した装置番号を代わりに指定することで，``write`` の出力先，``read`` の入力先ファイルが指定出来る．

なお装置番号が何であっても2番目の引数には同じように編集記述子を指定すれば良い．従って例えば

::

      integer :: i, j

      write(10, *)      i   ! デフォルトの書式
      write(10, '(i6)') j   ! 6桁で出力

などのように出力が出来る．

バイナリ(書式なし)入出力
~~~~~~~~~~~~~~~~~~~~~~~~

バイナリ形式とは一般にテキスト形式以外の人間がそのままでは解釈できない形式のファイルの総称である．アスキー形式での入出力では計算機の内部表現(メモリ上のビット列)を人間に解釈できる形式に逐一変換して入出力を行っている．Fortranでは ``open`` で ``form='unformatted'`` を指定して開いたファイルに対してはこのような変換が行われず，メモリ上のビット列が(ほぼ)そのまま出力されることになる．アスキー形式への変換が行われないため，編集記述子は指定することは出来ず，``write(10)``，``read(20)`` のような形で装置番号のみを指定して入出力を行う．

バイナリ入出力を行うメリットとして，まず高速であることが挙げられる．これはテキスト形式への変換を行わないことに加えて，テキスト形式での入出力に比べてデータ量を少なく抑えることが出来るためである．また内部的に2進数で表されている実数は10進数では正確に表現出来ないことから，実数型のデータはアスキー形式への変換に伴い情報が失われてしまうが，バイナリ形式での入出力ではこの問題がない．

デメリットは人間の目ではデータの中身が判別出来ないことである．従って，バイナリで出力されたデータを読み込むにはどのような形式で出力されたのかを予め正確に知っていなければならない．例えば,

::

      write(10) x
      write(10) y

と出力されたデータを読み込むには

::

      read(10) x
      read(10) y

としなければならないし，出力が

::

      write(10) x, y

であれば入力は

::

      read(10) x, y

とする必要がある．すなわち ``write`` で指定した変数並びと全く同じ変数並びで ``read`` しなければ正しく読み込みが出来ない．(大変困ったものであるが，:ref:`c6_stream_io` を用いれば少なくともこの問題は生じない ．) なお当然であるが，``x`` や ``y`` は :ref:`c5_array_io` の時と同様に配列でも良い．

また一般には異なる環境で作成したバイナリファイルには互換性が無い.ただし，この問題については多くの場合に対応が可能である(次節参照)．

バイトオーダー :sup:`†`
~~~~~~~~~~~~~~~~~~~~~~~~

マルチバイトのデータを計算機のメモリ上に配置する方法のことをバイトオーダーとかエンディアンなどと呼ぶ．分かりやすい(？)例としてIPアドレスを考えよう．IPアドレスは(IPv4では)4バイトで表され，192.168.1.0のように1バイトごとに"."で区切って記述するのが一般的である．これをメモリに格納する際に192，168，1，0の順に格納する方法をビッグエンディアン，逆に0，1，168，192の順に格納する方法をリトルエンディアンと呼んでいる．このバイトオーダーはCPU依存である．Intel系のCPUの場合はリトルエンディアンが採用されているので，普通のPCを扱っている限りはバイトオーダーを気にする必要は無い．一方でスーパーコンピューターなどではビッグエンディアンが採用されているCPUも比較的多く，そのような計算機で出力したデータを手元のPCで読み込む際にはバイトオーダーの変換が必要になってくる．

この変換は手動で行うことも出来るが，コンパイラのオプションで自動的に変換を行うように指定することも可能である．例えばgfortranの場合はコンパイルオプションに ``-fconvert=big-endian`` を用いると，入出力がビッグエンディアンのバイトオーダーで行われる．他にも環境変数 ``F_UFMTENDIAN`` を指定することでもバイトオーダーを指定することが出来るようである．

.. _c6_stream_io:

ストリーム入出力 :sup:`†`
~~~~~~~~~~~~~~~~~~~~~~~~~~

Fortranの ``unformatted`` のバイナリデータは一般にはC言語の ``fread``，``fwrite`` による入出力と互換性が無い．これはFortranは各 ``write`` 文で出力されるデータの前後に余計なデータ(ヘッダーおよびフッター)を付加するためである [#]_．新しいFortran 2003規格ではストリーム入出力というC言語の ``fread``，``fwrite`` と同じ(余計なデータを付加しない)読み書きが出来るようになっている．これには以下のように ``access='stream'`` を指定してファイルを開く．

::

      open(unit=10, file='binary.dat', access='stream', form='unformatted')

このように開かれたファイルに対しては

::

      write(10) x, y, z

と

::

      write(10) x
      write(10) y
      write(10) z

では全く同じデータが出力される．このように生成されたデータファイルはC言語の ``fread`` を用いて正常に読み込みが出来るし，また ``fwrite`` で出力したデータもFortranの ``read`` 文で読み込むことが可能である．

文字列処理
----------

文字型変数の宣言
~~~~~~~~~~~~~~~~

文字型変数の宣言は

::

      character(len=長さ) :: 変数名 = 初期化文字列

のように行えば良いことは既に学んだ．ここで指定した文字数に足りない部分はスペースで埋められる．従って，例えば長さ10の文字型変数に ``'ABCDE'`` を代入すると，その後ろに空白文字が5文字代入される．定数の場合は文字型の初期化時には長さを陽に指定しなくても

::

      character(len=*), parameter :: text = 'initialization by this string'

のように ``len=*`` を指定して初期化すると，自動的に初期化文字列の長さを持った文字型変数となる [#]_．

結合と代入
~~~~~~~~~~

文字型変数は ``//`` 演算子を用いて結合することや，結合した文字列を他の文字型変数に代入することが出来る．ただしこの際には空白の存在に注意しなければならない．例えば

::

      character(len=16) :: a, b, c, d

      a = 'This'
      b = 'is'
      c = 'a'
      d = 'pen'

      write(*,*) a // b // c // d

とした場合には，``a``，``b``，``c``，``d`` のどれも16文字の文字列であるので，16文字に満たない部分は全て空白で埋められている．従って ``//`` で結合しても空白は取り除かれずに残ることになり，実行結果の出力は以下のようになるだろう．

.. code-block:: bash

     This            is              a               pen

文字列の前後の空白文字を除去するには ``trim`` という組み込み関数を用いれば良い．空白を除去して各文字列間に1文字分ずつ空白を入れて出力するには

::

      write(*, '(a,x,a,x,a,x,a)') trim(a), trim(b), trim(c), trim(d)

などとすれば良い．これによって以下の様な出力が得られる．

.. code-block:: bash

    This is a pen

部分文字列
~~~~~~~~~~

配列の場合には ``a(1:10)`` のように部分配列を用いることが出来た．これと同じことが文字型変数に対しても出来る．例えば

::

      character(len=64) :: str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

      write(*,*) str(1:1)  ! 'A'
      write(*,*) str(6:10) ! 'FGHIJ'

などのような形である．例えば，以下のように特定の文字列の検索を行い，該当部分だけを取り出すような処理に用いることが出来る．

::

      integer :: i1, i2
      character(len=64) :: str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

      ! XYZと一致する部分文字列を検索し, 開始位置のインデックスを返す
      i1 = index(str, 'XYZ')
      i2 = i1 + len('XYZ')
      write(*,*) str(i1:i2)  ! XYZを出力

ここで組込み関数 ``index(s1, s2)`` は文字列 ``s1`` の中から ``s2`` に一致する部分文字列を検索し，開始位置のインデックスを返す関数である．文字列操作に関するその他の組み込み関数については富田・齋藤(2011，7章)などを参照のこと．

内部ファイル
~~~~~~~~~~~~

プログラム中で必要な文字列のフォーマットを揃えるのには **内部ファイル** と呼ばれる機能を知っていると何かと便利である．これまでに ``write`` の一番目の引数には装置番号を指定することを学んだが，以下の例では装置番号の代わりに文字型変数 ``str`` が指定されている．

::

      character(len=64) :: str
      integer :: n

      do n = 1, 8
         write(str, '("data",i3.3,".dat")') n
         write(*, '(a)') str
      end do

これによりフォーマットされた文字列が ``str`` に代入される．この例では ``data001.dat``, ``data002.dat``, ... のように連番のファイル名を作成して出力する．

ファイル終端までの逐次処理
--------------------------

文字列処理ではファイルの中身を一行ずつ読み込んで何らかの処理を行うことが多い．以下のサンプルコードは標準入力から1行ずつ順に読み込み処理をする例である．(従ってリダイレクトによってファイルを与えれば良い)．ファイルが終端に達したかどうかを調べるには ``read`` の終了ステータス ``iostat`` を取得すれば良い．正常に読み込みが実行された時には ``iostat`` が0となり，これが負の場合にはファイルの終端，正の場合には何らかのエラーが発生したことを意味する．なお，実際にはこのような処理はシェルスクリプトやPerl，Python，Rubyなどを使って実装する方が圧倒的に簡単である．(何でもかんでもFortranでやろうとするのは無駄が多い．)

::

      integer :: ios
      character(len=128) :: line

      read(*, fmt='(a)', iostat=ios) line

      do while(ios == 0)

        ! lineに何らかの処理をする

        ! 次の行を読み込む
        read(*, fmt='(a)', iostat=ios) line
      end do

----

.. [#]

   高木(2009，8章)が詳しい．

.. [#]

   科学的表記とは :math:`3 \times 10^{10}` のような表記法のことである．Fortranの出力では ``0.3e+11`` のような形になる．

.. [#]

   このような引数の渡し方はこの後の ``open`` 文などでも出てくる．これは :ref:`c7_optional_keyword` と呼ばれ，これによって関数やサブルーチンに順番を気にすること無く引数を渡すことが出来る．

.. [#]

   書き殴りでその後2度と使わないようなコードの場合はそれほど気にする必要はないかもしれないが．

.. [#]

   ただしこれは慣習的にそうなっているだけで，標準化されているわけではなく，完全に処理系依存である．ヘッダーやフッターは4バイトのこともあるし8バイトのこともある．同じコンパイラであってもオプションで変更することも出来る．ここで扱うストリーム入出力であればバイトオーダーさえ把握していればヘッダーやフッターのことを気にする必要が無い．

.. [#]

   後述の関数やサブルーチンの仮引数でもこの形式が使える．
