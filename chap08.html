

<!doctype html>

<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>8. 数値解析の基礎 &#8212; Fortran演習(地球惑星物理学演習)</title>
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="9. モジュールと構造型" href="chap09.html" />
    <link rel="prev" title="7. 関数とサブルーチン" href="chap07.html" />
<link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-99010794-2', 'auto');
  ga('send', 'pageview');

</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="chap09.html" title="9. モジュールと構造型"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="chap07.html" title="7. 関数とサブルーチン"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Fortran演習</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">8. 数値解析の基礎</a><ul>
<li><a class="reference internal" href="#c8-float-precision">8.1. 実数の精度と誤差</a><ul>
<li><a class="reference internal" href="#id5">8.1.1. 浮動小数点数の表現</a></li>
<li><a class="reference internal" href="#id6">8.1.2. 丸め誤差</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id7">8.2. 求根法</a><ul>
<li><a class="reference internal" href="#id9">8.2.1. 二分法</a></li>
<li><a class="reference internal" href="#newton">8.2.2. Newton法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#c8-numerical-integration">8.3. 数値積分</a></li>
<li><a class="reference internal" href="#id11">8.4. 乱数</a></li>
<li><a class="reference internal" href="#id13">8.5. 第8章 演習課題</a><ul>
<li><a class="reference internal" href="#id14">8.5.1. 課題1</a></li>
<li><a class="reference internal" href="#id15">8.5.2. 課題2</a></li>
<li><a class="reference internal" href="#id16">8.5.3. 課題3</a></li>
<li><a class="reference internal" href="#id17">8.5.4. 課題4</a></li>
<li><a class="reference internal" href="#id18">8.5.5. 課題5</a></li>
<li><a class="reference internal" href="#id19">8.5.6. 課題6 <sup>†</sup></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="chap07.html"
                        title="前の章へ"><span class="section-number">7. </span>関数とサブルーチン</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="chap09.html"
                        title="次の章へ"><span class="section-number">9. </span>モジュールと構造型</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="検索" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id27"><span class="section-number">8. </span>数値解析の基礎</a><a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>これまでは主にプログラミングの作法を学んできた．基本的には現在までの知識を組み合わせれば原理的にはどんな問題にも対応できるようになっている <a class="footnote-reference brackets" href="#id20" id="id2">1</a>．そこで，これまでに学んだ知識を用いてもう少し実践的な内容に取り組もう．具体的には非線形方程式の求根法や，関数の数値積分，また乱数の使い方などを扱う．</p>
<blockquote>
<div><p>サンプルプログラム</p>
<ul class="simple">
<li><p><a class="reference internal" href="chap08_sample1_f90.html"><span class="doc">sample1.f90</span></a> : 桁落ちと情報落ち</p></li>
<li><p><a class="reference internal" href="chap08_sample2_f90.html"><span class="doc">sample2.f90</span></a> : 二分法</p></li>
<li><p><a class="reference internal" href="chap08_sample3_f90.html"><span class="doc">sample3.f90</span></a> : Newton法</p></li>
<li><p><a class="reference internal" href="chap08_sample4_f90.html"><span class="doc">sample4.f90</span></a> : 数値積分</p></li>
<li><p><a class="reference internal" href="chap08_sample5_f90.html"><span class="doc">sample5.f90</span></a> : 乱数</p></li>
</ul>
</div></blockquote>
<div class="contents topic" id="id3">
<p class="topic-title">この章の内容</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id27">数値解析の基礎</a></p>
<ul>
<li><p><a class="reference internal" href="#c8-float-precision" id="id28">実数の精度と誤差</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id29">求根法</a></p></li>
<li><p><a class="reference internal" href="#c8-numerical-integration" id="id30">数値積分</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id31">乱数</a></p></li>
<li><p><a class="reference internal" href="#id13" id="id32">第8章 演習課題</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="c8-float-precision">
<span id="id4"></span><h2><a class="toc-backref" href="#id28"><span class="section-number">8.1. </span>実数の精度と誤差</a><a class="headerlink" href="#c8-float-precision" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><p><a class="reference internal" href="chap08_sample1_f90.html"><span class="doc">サンプルコード参照</span></a></p>
</div></blockquote>
<p>これまで何気なく用いてきた実数型だが，数値解析を始める前に計算機における実数の取り扱いやその誤差について理解しておこう．</p>
<div class="section" id="id5">
<h3><span class="section-number">8.1.1. </span>浮動小数点数の表現<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>実数は計算機の内部では浮動小数点数と呼ばれる形式になっており，</p>
<div class="math notranslate nohighlight">
\[x = \underbrace{(-1)^{s}}_{\mbox{符号}} \times
    \underbrace{(1.f)}_{\mbox{仮数部(2進表現)}} \times
    \underbrace{(2^{e-127})}_{\mbox{指数部}}\]</div>
<p>のような表現で表される．仮数部は有効桁を決める部分であり，指数部は絶対値を調整するためのものである． 仮数部が <span class="math notranslate nohighlight">\(1.f\)</span> となっているのは(最上位ビットは常に1なので)実質1ビット分だけ精度を稼ぐためである(これをケチ表現と呼ぶ)． 例えば標準的な規格(IEEE754規格)では単精度の場合，符号部に1ビット，仮数部に23ビット，指数部に8ビットが割り当てられている． 指数部が8ビットであることから，<span class="math notranslate nohighlight">\(e=0, 1, \ldots, 255\)</span> であり，即ち絶対値の範囲としては <span class="math notranslate nohighlight">\(2^{-127} \sim 10^{-38} \lesssim x \lesssim 2^{127} \sim 10^{+38}\)</span> 程度以内の数値しか表現できない． また <span class="math notranslate nohighlight">\(\log_{10} (2^{23 + 1}) \sim 7.2\)</span> なので10進での有効桁数は7桁程度である． 同様に倍精度では符号部に1ビット，仮数部に52ビット，指数部に11ビットが割り当てられていることから絶対値の範囲は <span class="math notranslate nohighlight">\(2^{-1024} \sim 10^{-308} \lesssim x \lesssim 2^{+1024} \sim 10^{+308}\)</span>，有効桁数は <span class="math notranslate nohighlight">\(\log_{10} (2^{52+1}) \sim 15.9\)</span> となり10進での有効桁数は16桁程度である．</p>
</div>
<div class="section" id="id6">
<h3><span class="section-number">8.1.2. </span>丸め誤差<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>実数を有効桁で「丸め」て表現することから生じる誤差を丸め誤差と呼ぶ．これは場合によっては求めたい計算結果の精度に悪影響を及ぼすこともあるため，注意が必要である．</p>
<ul>
<li><p>桁落ち</p>
<p>絶対値の非常に近い2つの数の差を計算すると絶対値が非常に小さくなり，その分だけ相対誤差が大きくなってしまう．これを桁落ちと呼ぶ．</p>
<p>例えば <span class="math notranslate nohighlight">\(\sqrt{1 + x} - 1\)</span> のような演算は <span class="math notranslate nohighlight">\(x\)</span> が非常に小さい場合にはその誤差が無視できない．簡単のため10進数で有効桁数が5桁の場合を考えよう． <span class="math notranslate nohighlight">\(x=0.001\)</span> とすると， この精度の範囲では <span class="math notranslate nohighlight">\(\sqrt{1 + x} \approx 1.0005\)</span> なので， <span class="math notranslate nohighlight">\(\sqrt{1 + x} - 1 \approx 0.0005\)</span> となり有効桁数が1桁に低下してしまう．これは例えば以下のような式変形によって減算を無くすことで回避が可能である．</p>
<div class="math notranslate nohighlight">
\[\sqrt{1 + x} - 1 = \frac{x}{\sqrt{1 + x} + 1}\]</div>
</li>
<li><p>情報落ち</p>
<p>絶対値の大きい数に小さい数を加えてもほとんど変化が無い．これを情報落ちと呼ぶ．</p>
<p>同様に有効桁数が5桁の場合を考えよう．<span class="math notranslate nohighlight">\(a = 1.0000\)</span>， <span class="math notranslate nohighlight">\(b = 1.0000 \times 10^{-5}\)</span> はどちらとも5桁の有効桁数を持つが， <span class="math notranslate nohighlight">\(a + b = 1.00001\)</span> の小数点第5位は精度は有効桁数の範囲外となるため，情報が失われてしまう．例えば，総和計算の際に非常に大きな数と小さな数を多数加える場合にはこれが問題となることがある．このときには小さい方から順に和を計算することで回避できる．</p>
</li>
</ul>
<p>丸め誤差の影響を調べるのに一番安直だが確実な方法は単精度から倍精度，倍精度から4倍精度に精度を上げてみて結果が変わらないことを確認することである．</p>
</div>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id29"><span class="section-number">8.2. </span>求根法</a><a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>解析的には解けない方程式(非線形方程式)の解を求める方法を考えよう．通常は右辺と左辺の両方に式があるわけだが，移項してしまって</p>
<div class="math notranslate nohighlight">
\[f(x) = 0\]</div>
<p>という一般的な形にして解くことにしよう．実はこの問題は意外と難しい問題であり，どんな問題にも使うことのできる汎用的で，かつ高速に解を求められるような手法は存在しない．と言うのはどんな手法であっても基本的には初期値として近似解のあたりを付けて，少しずつ真の解に近づけていく反復法だからである．初期値の選び方によっては正しい解に収束しない場合や，欲しい解(例えば物理的な解)に収束しないもあり得る <a class="footnote-reference brackets" href="#id21" id="id8">2</a>．計算機は初期値までは面倒を見てくれないので，人間が適切な初期値を与えてあげなければならない．とりあえず初期値は与えられたとして，そこから近似解を反復によって求めるアルゴリズムを見ていこう．</p>
<div class="section" id="id9">
<h3><span class="section-number">8.2.1. </span>二分法<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h3>
<blockquote>
<div><p><a class="reference internal" href="chap08_sample2_f90.html"><span class="doc">サンプルコード参照</span></a></p>
</div></blockquote>
<p>もしある区間に解が1つあると分かっているならば，反復によって近似解が必ず真の解に収束する，二分法(bisection method)と呼ばれるアルゴリズムが知られいる．まず <span class="math notranslate nohighlight">\([x_1, x_2] \ (x_1 &lt; x_2)\)</span> に対して <span class="math notranslate nohighlight">\(f(x_1) &lt; 0, f(x_2) &gt; 0\)</span> ならばこのの区間に解があることが分かる．このとき，二分法によって近似解を求める手順は以下のようなものとなる．</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(x = (x_1 + x_2)/2\)</span> を近似解とする．</p></li>
<li><p><span class="math notranslate nohighlight">\(f(x) &lt; 0\)</span> なら <span class="math notranslate nohighlight">\(x_1 = x\)</span>，
<span class="math notranslate nohighlight">\(f(x) &gt; 0\)</span> なら <span class="math notranslate nohighlight">\(x_2 = x\)</span> とし，(1)に戻る．</p></li>
</ol>
</div></blockquote>
<p>この手順を解が収束するまで繰り返せばよい．収束判定は例えば許容誤差を <span class="math notranslate nohighlight">\(\epsilon\)</span> として <span class="math notranslate nohighlight">\(|x_2 - x_1| &lt; \epsilon\)</span> (区間の幅が許容誤差よりも小さい)などとすればよい．</p>
<p>実際には <span class="math notranslate nohighlight">\(f(x_1) &gt; 0, f(x_2) &lt; 0\)</span> の場合も考慮しなければならないが，組み込み関数 <code class="docutils literal notranslate"><span class="pre">sign</span></code> を用いてこれは簡単に実現出来る．以下のコードには二分法の実装例を示している．ただし <code class="docutils literal notranslate"><span class="pre">f</span></code> は関数として定義されているものとする．</p>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">sig</span> <span class="o">=</span> <span class="nb">sign</span><span class="p">(</span><span class="mf">1.0_8</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="o">-</span><span class="n">f</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
<span class="k">do </span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nmax</span>
   <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5_8</span>
   <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

   <span class="c">! 収束判定</span>
   <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      exit</span>
<span class="k">   end if</span>

   <span class="c">! 次の値を推定</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">sig</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      </span><span class="n">x1</span> <span class="o">=</span> <span class="n">x</span>
   <span class="k">else</span>
<span class="k">      </span><span class="n">x2</span> <span class="o">=</span> <span class="n">x</span>
   <span class="k">end if</span>
<span class="k">end do</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="newton">
<h3><span class="section-number">8.2.2. </span>Newton法<a class="headerlink" href="#newton" title="このヘッドラインへのパーマリンク">¶</a></h3>
<blockquote>
<div><p><a class="reference internal" href="chap08_sample3_f90.html"><span class="doc">サンプルコード参照</span></a></p>
</div></blockquote>
<p>二分法は解の含まれる範囲を正しく指定すれば必ず収束するという利点はあるものの，あまり収束の速いアルゴリズムではなかった．一方で，初期値によっては収束しないかもしれないが，収束するならばその収束自体は速いというアルゴリズムも考えられる．それがここで紹介するNewton法と呼ばれるものである．これは <span class="math notranslate nohighlight">\(f(x)\)</span> に加えてその微分 <span class="math notranslate nohighlight">\(f'(x)\)</span> も用いるのが特徴である．すなわち，近似解 <span class="math notranslate nohighlight">\(x\)</span> が与えられたときに <span class="math notranslate nohighlight">\(x\)</span> の周りでのテイラー展開した</p>
<div class="math notranslate nohighlight">
\[f(x + \delta) \simeq f(x) + \delta f'(x) + O(\delta^2)\]</div>
<p>を用いて， <span class="math notranslate nohighlight">\(f(x + \delta) = 0\)</span> とすると</p>
<div class="math notranslate nohighlight">
\[\delta = - \frac{f(x)}{f'(x)}\]</div>
<p>を得る．即ち <span class="math notranslate nohighlight">\(x - f(x)/f'(x)\)</span> を新しい近似解として採用すればよい．大きな特徴は関数の値だけではなく，その微分値(接線)も用いて収束を加速している点である．しかし，当然ながら初期値によっては収束しないことも十分に考えられる(どういった場合であろうか？)．以下のコードはNewton法のアルゴリズムを実装したものである．プログラムの構造は二分法の場合とほぼ同様であるが，微分値を返す関数 <code class="docutils literal notranslate"><span class="pre">df</span></code> も用いている．</p>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">do </span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nmax</span>
   <span class="c">! 次の値の推定</span>
   <span class="n">y</span>  <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
   <span class="n">dy</span> <span class="o">=</span> <span class="n">df</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
   <span class="n">dx</span> <span class="o">=-</span><span class="n">y</span> <span class="o">/</span> <span class="n">dy</span>
   <span class="n">x</span>  <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span>

   <span class="c">! 収束判定</span>
   <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      exit</span>
<span class="k">   end if</span>
<span class="k">end do</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="c8-numerical-integration">
<span id="id10"></span><h2><a class="toc-backref" href="#id30"><span class="section-number">8.3. </span>数値積分</a><a class="headerlink" href="#c8-numerical-integration" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><p><a class="reference internal" href="chap08_sample4_f90.html"><span class="doc">サンプルコード参照</span></a></p>
</div></blockquote>
<p>次に関数の積分</p>
<div class="math notranslate nohighlight">
\[S = \int_{a}^{b} f(x) d x\]</div>
<p>の数値的な評価を考えよう．区分求積法の原理を思い出せば，積分領域 <span class="math notranslate nohighlight">\([a, b]\)</span> を小さな領域 <span class="math notranslate nohighlight">\(h = (b-a)/N\)</span> に分割し，積分を微小区間の積分の総和で近似すればよいことが分かるだろう．ここで分割数 <span class="math notranslate nohighlight">\(N\)</span> を十分大きくとることができれば，近似式の誤差は十分小さく抑えることができる．<span class="math notranslate nohighlight">\(x_j = a + j h\)</span> とし，微小区間の端点 <span class="math notranslate nohighlight">\([x_{i}, x_{i+1}]\)</span> で与えられた関数値 <span class="math notranslate nohighlight">\(f_{i}, f_{i+1}\)</span> から，関数系を</p>
<div class="math notranslate nohighlight">
\[f(x) = \frac{f_{i+1} - f_{i}}{h} (x - x_{i}) + f_{i}\]</div>
<p>のように線形近似することで，以下の <strong>台形公式</strong> が得られる．</p>
<div class="math notranslate nohighlight">
\[S = \frac{h}{2} \left[ f(x_0) +
                      2 \sum_{j=1}^{N-1} f (x_{j}) + f(x_N) \right]
+ O(h^2).\]</div>
<p>ここで <span class="math notranslate nohighlight">\(O(h^2)\)</span> は誤差が刻み幅 <span class="math notranslate nohighlight">\(h\)</span> の2乗で小さくなることを意味する．ただし例外として，元の関数系が線形であれば，当然この評価は厳密な積分値を与える．</p>
<p>この考え方をさらに発展させ， <span class="math notranslate nohighlight">\(x_{i-1}, x_{i}, x_{i+1}\)</span> の3点の関数値 <span class="math notranslate nohighlight">\(f_{i-1}, f_{i}, f_{i+1}\)</span> から関数系を2次関数で近似すれば，以下の <em>Simpsonの公式</em> が得られる．</p>
<div class="math notranslate nohighlight">
\[S = \frac{h}{3}
 \left[ f(x_0) + 4 \sum_{j=1}^{N/2} f(x_{2j-1}) +
  2 \sum_{j=1}^{N/2-1} f(x_{2j}) + f(x_N)
 \right]
+ O(h^4).\]</div>
<p>ここでSimpsonの公式の誤差は <span class="math notranslate nohighlight">\(h\)</span> の4乗に比例する．当然ながら同じ精度を実現するために必要な計算量はSimpsonの公式の方が台形公式よりも小さくて済む．</p>
<p>Fortranプログラム中では <span class="math notranslate nohighlight">\(f(x)\)</span> を関数として定義し，分割数 <span class="math notranslate nohighlight">\(N\)</span> を適当に定めれば <code class="docutils literal notranslate"><span class="pre">do</span></code> ループによって総和計算をすることで積分値は簡単に求まる．例えば台形公式は以下のように実装することが出来る．</p>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">integral</span> <span class="o">=</span> <span class="mf">0.5_8</span> <span class="o">*</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>
<span class="k">do </span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nmax</span><span class="o">-</span><span class="mi">1</span>
   <span class="n">integral</span> <span class="o">=</span> <span class="n">integral</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">dx</span><span class="o">*</span><span class="kt">real</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="k">end do</span>
<span class="n">integral</span> <span class="o">=</span> <span class="n">integral</span> <span class="o">*</span> <span class="n">dx</span>
</pre></div>
</td></tr></table></div>
<p>ただし，ここで <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> は被積分関数である．</p>
</div>
<div class="section" id="id11">
<h2><a class="toc-backref" href="#id31"><span class="section-number">8.4. </span>乱数</a><a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><p><a class="reference internal" href="chap08_sample5_f90.html"><span class="doc">サンプルコード参照</span></a></p>
</div></blockquote>
<p>確率的な現象を計算機を用いて模擬する際には乱数を用いることになる．ただし計算機で用いることのできる乱数は擬似乱数と呼ばれ，乱数のように見えるが実際には決定論的な手法に基づき生成される数列である．従って質の良い(周期の長い)乱数を用いなければ，用途によっては乱数とみなすことのできない場合もあるため注意が必要である．</p>
<p>Fortranには乱数を発生させる組込みのサブルーチン <code class="docutils literal notranslate"><span class="pre">random_number</span></code> が存在する．</p>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">call </span><span class="nb">random_number</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>とすれば <code class="docutils literal notranslate"><span class="pre">x</span></code> に区間 <span class="math notranslate nohighlight">\([0,1)\)</span> の一様乱数が代入される．<code class="docutils literal notranslate"><span class="pre">x</span></code> は実数型(単精度もしくは倍精度)であれば配列でも良い．配列の場合は全ての要素に一様乱数が代入される．</p>
<p>擬似乱数は決定論的な数列であることは既に述べた通りであるが，その初期値を指定することも出来る．これは乱数のシード(seed)と呼ばれ，組込みのサブルーチン <code class="docutils literal notranslate"><span class="pre">random_seed</span></code> を用いて行うことが出来る．使い方は</p>
<ol class="arabic simple">
<li><p>シードを格納領域のサイズを取得(サイズはコンパイラ依存)</p></li>
<li><p>必要な領域を確保( <code class="docutils literal notranslate"><span class="pre">allocate</span></code> を用いる)</p></li>
<li><p>シードを指定</p></li>
</ol>
<p>といった流れとなる．以下のサブルーチン <code class="docutils literal notranslate"><span class="pre">random_seed_clock</span></code> は計算機の時刻 <a class="footnote-reference brackets" href="#id22" id="id12">3</a> に応じてシードを指定するものであり，これを用いれば実行する度に(時刻が異なるので)得られる乱数値が異なることが保証される．逆に固定のシードを用いるようにしておくと毎回同じ結果が得られるため，乱数を用いるプログラムをデバッグする際には都合が良い．</p>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">random_seed_clock</span><span class="p">()</span>
  <span class="k">implicit none</span>
<span class="k">  </span><span class="kt">integer</span> <span class="kd">::</span> <span class="n">nseed</span><span class="p">,</span> <span class="n">clock</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">allocatable</span> <span class="kd">::</span> <span class="n">seed</span><span class="p">(:)</span>

  <span class="c">! システムクロックを取得</span>
  <span class="k">call </span><span class="nb">system_clock</span><span class="p">(</span><span class="n">clock</span><span class="p">)</span>

  <span class="k">call </span><span class="nb">random_seed</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">nseed</span><span class="p">)</span>
  <span class="k">allocate</span><span class="p">(</span><span class="n">seed</span><span class="p">(</span><span class="n">nseed</span><span class="p">))</span>

  <span class="n">seed</span> <span class="o">=</span> <span class="n">clock</span>
  <span class="k">call </span><span class="nb">random_seed</span><span class="p">(</span><span class="n">put</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

  <span class="k">deallocate</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
<span class="k">end subroutine </span><span class="n">random_seed_clock</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="id13">
<h2><a class="toc-backref" href="#id32"><span class="section-number">8.5. </span>第8章 演習課題</a><a class="headerlink" href="#id13" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><p><a class="reference external" href="chap08_kadai.pdf">課題PDFダウンロード</a></p>
</div></blockquote>
<div class="section" id="id14">
<h3><span class="section-number">8.5.1. </span>課題1<a class="headerlink" href="#id14" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>サンプルプログラムをコンパイル・実行して動作を確認せよ．さらに，適宜修正してその実行結果を確認せよ．</p>
</div>
<div class="section" id="id15">
<h3><span class="section-number">8.5.2. </span>課題2<a class="headerlink" href="#id15" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>2次方程式 <span class="math notranslate nohighlight">\(a x^2 + b x + c = 0\)</span>
の解は以下の解の公式を用いて求めることが出来る．</p>
<div class="math notranslate nohighlight">
\[x = \frac{-b \pm \sqrt{b^2 - 4 a c}}{2 a}\]</div>
<p>しかしこの公式を単純に用いた場合には <span class="math notranslate nohighlight">\(b^2 \gg 4 a c\)</span> の時には，桁落ちによってどちらか一方の解の精度が悪くなってしまう．このことを実際に確認し，式変形によってその精度を改善せよ．</p>
<p>例えば <span class="math notranslate nohighlight">\(a = 1, b = -10^{9}, c = 1\)</span> とした時の解は</p>
<div class="math notranslate nohighlight">
\[x \simeq 1.\underbrace{000000000000000}_{0が15個} \times 10^{9}, \quad
1.\underbrace{000000000000000}_{0が15個} \times 10^{-9}\]</div>
<p>であるが，解の公式を用いた場合と式変形によって桁落ち対策をした場合で数値解を比較せよ．(桁落ち対策が必要なのはどちらか一方の解のみである．)</p>
</div>
<div class="section" id="id16">
<h3><span class="section-number">8.5.3. </span>課題3<a class="headerlink" href="#id16" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Newton法では関数の微分値を解析的に与えて用いるが，割線法(Secant method)と呼ばれる手法では連続した2つの近似解を用いて，微分を差分で近似する．即ち <span class="math notranslate nohighlight">\(n\)</span> 番目の近似解を <span class="math notranslate nohighlight">\(x_n\)</span> と書いたときに，Newton法の公式</p>
<div class="math notranslate nohighlight">
\[x_{n+1} = x_{n} - \frac{f(x_{n})}{f'(x_{n})}\]</div>
<p>において，微分値を以下のように近似する．</p>
<div class="math notranslate nohighlight">
\[f'(x_n) \simeq \frac{f(x_{n}) - f(x_{n-1})}{x_{n} - x_{n-1}}\]</div>
<p>(この手法では微分値の計算をする必要がないため，反復1回あたりの計算量が少なくなる可能性があるが，収束はNewton法よりも少し遅くなる．)</p>
<p>この割線法を実装し，以下の方程式</p>
<div class="math notranslate nohighlight">
\[f(x) = \frac{1-x}{\sqrt{M}} - \exp(x)\]</div>
<p>を数値的に解くことで，その収束の速さを二分法およびNewton法と比較せよ．ただし <span class="math notranslate nohighlight">\(M= 1836\)</span> とする．なお解は <span class="math notranslate nohighlight">\(x \simeq -2.5\)</span> なので二分法ではこの前後に2つの初期値を指定すればよい．割線法も2つ初期値が必要になるが，(この関数に関しては)初期値には敏感ではないので，例えば0と1を初期値として用いればよい．ここでは収束の速さを比較すればよいので，各反復ごとの収束判定はせずに20回程度の反復を行い誤差の減少の様子をgnuplotを用いて図示せよ．ただし連続する2つの近似解の差を誤差と定義する．</p>
<p>結果は以下の例ようになるであろう．</p>
<div class="figure align-center" id="id23">
<a class="reference internal image-reference" href="_images/rootfind.png"><img alt="_images/rootfind.png" src="_images/rootfind.png" style="width: 75%;" /></a>
<p class="caption"><span class="caption-text">求根法の収束比較</span><a class="headerlink" href="#id23" title="この画像へのパーマリンク">¶</a></p>
</div>
</div>
<div class="section" id="id17">
<h3><span class="section-number">8.5.4. </span>課題4<a class="headerlink" href="#id17" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><span class="math notranslate nohighlight">\(f(x) = \dfrac{4}{\pi} \dfrac{1}{1 + x^2}\)</span> および <span class="math notranslate nohighlight">\(f(x) = (n+1) \ x^{n} \ (n = 0, \ldots, 5)\)</span> のそれぞれについて</p>
<div class="math notranslate nohighlight">
\[\int_{0}^{1} f(x) dx\]</div>
<p>の積分を台形公式およびSimpsonの公式で数値的に行い，誤差の分割数に対する依存性をgnuplotを用いて図示せよ．例えば分割数を <span class="math notranslate nohighlight">\(2^{n} (n=1, 2, \ldots, 16)\)</span> の範囲で変えて依存性を調べれば良い．</p>
<p>結果は以下の例ようになるであろう．</p>
<div class="figure align-center" id="id24">
<a class="reference internal image-reference" href="_images/integration.png"><img alt="_images/integration.png" src="_images/integration.png" style="width: 75%;" /></a>
<p class="caption"><span class="caption-text">数値積分誤差の分割数依存性</span><a class="headerlink" href="#id24" title="この画像へのパーマリンク">¶</a></p>
</div>
<p>このような依存性となるのはなぜか?</p>
</div>
<div class="section" id="id18">
<h3><span class="section-number">8.5.5. </span>課題5<a class="headerlink" href="#id18" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>一様乱数を用いてある確率分布に従う乱数を発生させるために逆関数を用いる方法(変換法や逆関数法などと呼ばれる)を考える．区間 <span class="math notranslate nohighlight">\([0, 1)\)</span> での一様乱数 <span class="math notranslate nohighlight">\(x\)</span> およびその確率分布 <span class="math notranslate nohighlight">\(f(x)\)</span> ，また必要な乱数 <span class="math notranslate nohighlight">\(y\)</span> とその確率分布 <span class="math notranslate nohighlight">\(g(y)\)</span> とする．ただし乱数の値域は <span class="math notranslate nohighlight">\(a \leq y &lt; b\)</span> とする． <span class="math notranslate nohighlight">\(y\)</span> を <span class="math notranslate nohighlight">\(x\)</span> から何らかの変換で <span class="math notranslate nohighlight">\(y = P(x)\)</span> のように表すとき，確率密度の保存から</p>
<div class="math notranslate nohighlight">
\[g(y) d y = f(x) dx = d x\]</div>
<p>が成り立つ．(最後の等式は一様乱数であることから自明である．)
この両辺を積分して</p>
<div class="math notranslate nohighlight">
\[x = \frac
{ \int^{y}_{a} g(y') d y' }
{ \int^{b}_{a} g(y') d y' }
\equiv G(y)\]</div>
<p>によって関数 <span class="math notranslate nohighlight">\(G(y)\)</span> を定義する．ただし <span class="math notranslate nohighlight">\(G(a) = 0\)</span> ， <span class="math notranslate nohighlight">\(G(b) = 1\)</span> となるように規格化した．これより</p>
<div class="math notranslate nohighlight">
\[y = G^{-1} (x)\]</div>
<p>を得る．即ち， <span class="math notranslate nohighlight">\(G^{-1} (x)\)</span> を解析的に求めることができれば，一様乱数 <span class="math notranslate nohighlight">\(x\)</span> を用いて必要な確率分布 <span class="math notranslate nohighlight">\(g(y)\)</span> に従う乱数を作ることができる．（以下の図を参照）</p>
<div class="figure align-center" id="id25">
<a class="reference internal image-reference" href="_images/inversefunc.png"><img alt="_images/inversefunc.png" src="_images/inversefunc.png" style="width: 480px;" /></a>
<p class="caption"><span class="caption-text">逆関数法の概念図</span><a class="headerlink" href="#id25" title="この画像へのパーマリンク">¶</a></p>
</div>
<p>このことを用いて指数分布</p>
<div class="math notranslate nohighlight">
\[g(y; \lambda) = \lambda \exp(-\lambda y)\]</div>
<p>に従う乱数分布を発生させるプログラムを作成せよ．また分布のヒストグラムを作成し，gnuplotを用いてヒストグラムを解析的な分布と共に図示し，乱数の発生数を増やした時に乱数分布が真の分布に近づくことを確かめよ．</p>
<p>以下は60000個の乱数を発生させた場合のヒストグラムの例である．</p>
<div class="figure align-center" id="id26">
<a class="reference internal image-reference" href="_images/expdist.png"><img alt="_images/expdist.png" src="_images/expdist.png" style="width: 480px;" /></a>
<p class="caption"><span class="caption-text">指数分布のヒストグラム</span><a class="headerlink" href="#id26" title="この画像へのパーマリンク">¶</a></p>
</div>
</div>
<div class="section" id="id19">
<h3><span class="section-number">8.5.6. </span>課題6 <sup>†</sup><a class="headerlink" href="#id19" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>乱数を利用した数値積分法としてモンテカルロ法が知られている．これを用いて <span class="math notranslate nohighlight">\(n\)</span> 次元ユークリッド空間における単位超球の体積 <span class="math notranslate nohighlight">\(V_n\)</span> を求めるプログラムを作成せよ．</p>
<p>ただし <span class="math notranslate nohighlight">\(n\)</span> 次元超球の体積は <span class="math notranslate nohighlight">\(n\)</span> 次元空間の座標を <span class="math notranslate nohighlight">\(x_i \, (i=1, \ldots, n)\)</span> とし，</p>
<div class="math notranslate nohighlight">
\[\sum_{i=1}^{n} x_i^{2} \leq 1\]</div>
<p>なる領域の体積と定義される．ここで対称性から <span class="math notranslate nohighlight">\(0 \leq x_i \leq 1\)</span> の領域のみを考えれば，この体積は <span class="math notranslate nohighlight">\(V_n / 2^{n}\)</span> となる．従って <span class="math notranslate nohighlight">\(n\)</span> 個の一様乱数 <span class="math notranslate nohighlight">\(0 \leq x_i &lt; 1 \, (i=1, \ldots, n)\)</span> を発生させ，上式の条件を満足するかどうかを調べる試行を多数回行い，その確率を求めることによって <span class="math notranslate nohighlight">\(V_n / 2^{n}\)</span> を推定すればよい．</p>
<p>なお真の値は</p>
<div class="math notranslate nohighlight">
\[V_n = \frac{ \pi^{n/2} }{ \Gamma(n/2 + 1) }\]</div>
<p>によって与えられる．</p>
<p>例えば次元数と試行回数を標準入力から与える形式のプログラムの実行結果は以下のようになる．この例のように誤差は試行回数 <span class="math notranslate nohighlight">\(m\)</span> に対して， <span class="math notranslate nohighlight">\(1/\sqrt{m}\)</span> に比例して減少する．</p>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ ./a.out
<span class="m">2</span> <span class="m">1000</span>    <span class="c1"># キーボード入力(2次元，試行回数1000回)</span>
<span class="nv">approximation</span>  <span class="o">=</span>       <span class="m">0</span>.32240000E+01
exact <span class="nv">value</span>    <span class="o">=</span>       <span class="m">0</span>.31415927E+01
relative <span class="nv">error</span> <span class="o">=</span>       <span class="m">0</span>.26231044E-01
$ ./a.out
<span class="m">2</span> <span class="m">100000</span>  <span class="c1"># キーボード入力(2次元，試行回数100000回)</span>
<span class="nv">approximation</span>  <span class="o">=</span>       <span class="m">0</span>.31430400E+01
exact <span class="nv">value</span>    <span class="o">=</span>       <span class="m">0</span>.31415927E+01
relative <span class="nv">error</span> <span class="o">=</span>       <span class="m">0</span>.46067683E-03
</pre></div>
</td></tr></table></div>
<hr class="docutils" />
<dl class="footnote brackets">
<dt class="label" id="id20"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>もちろん数学や物理，更には数値解析の知識は必要になってくるわけだが，それはこれから学んでいくことになる．</p>
</dd>
<dt class="label" id="id21"><span class="brackets"><a class="fn-backref" href="#id8">2</a></span></dt>
<dd><p>1変数ならまだ良いのだが，多変数関数に拡張するとほとんどお手上げである．</p>
</dd>
<dt class="label" id="id22"><span class="brackets"><a class="fn-backref" href="#id12">3</a></span></dt>
<dd><p>Unix系OSの場合は1970年1月1日からの経過時間．</p>
</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="chap09.html" title="9. モジュールと構造型"
             >次へ</a> |</li>
        <li class="right" >
          <a href="chap07.html" title="7. 関数とサブルーチン"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Fortran演習</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Takanobu Amano.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.3 で生成しました。
    </div>
  </body>
</html>