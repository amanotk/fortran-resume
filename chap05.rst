.. -*- coding: utf-8 -*-

.. highlight:: fortran
  :linenothreshold: 1

====
配列
====

.. highlight:: fortran
  :linenothreshold: 1

大量のデータをまとめて扱うのに便利な配列について，その基本的な使い方や配列に関する組込み関数の使い方などを学ぼう．

    サンプルプログラム

    - :doc:`sample1.f90 <chap05_sample1>` : 配列の基本
    - :doc:`sample2.f90 <chap05_sample2>` : 配列の定数と初期化
    - :doc:`sample3.f90 <chap05_sample3>` : 動的配列
    - :doc:`sample4.f90 <chap05_sample4>` : 多次元配列
    - :doc:`sample5.f90 <chap05_sample5>` : 配列の入出力
    - :doc:`sample6.f90 <chap05_sample6>` : 配列に関する組込み関数2
    - :doc:`sample7.f90 <chap05_sample7>` : 部分配列と配列演算

.. contents:: この章の内容
    :depth: 2

基本的な使い方
==============

    :doc:`サンプルコード参照 <chap05_sample1>`

配列とは *同じ型* の複数のデータを効率的に扱うために用いるデータ構造 [#]_ である．配列も通常の変数と同じように宣言が必要であり，宣言時には配列であることを明示的に示さなければならない．配列を宣言すると計算機の *メモリ上の連続した領域* が確保され，それぞれのアドレスに添字を用いてアクセスできるようになる．具体的には以下のように宣言する．

::

    integer :: i
    integer :: n(10)  ! 整数型の長さ10の配列

    do i = 1, 10
      n(i) = i*i
    end do

上の例では4-6行目で配列の各要素に添字 ``i`` を用いて ``x(i)`` のようにアクセスしており(ここでは各要素へ値の代入)，添字でアクセスした各要素については通常の変数のように扱うことができる．Fortranでは配列の添字は ``1`` から始まるので，例えば上の例では ``x(1)`` が最初の要素であり，``x(10)`` が最後の要素ということになる．C言語を始めとする多くの言語では配列の添字は ``0`` から始まることになっているので注意して欲しい．ただしFortranでは，以下の2行目のような宣言によって宣言時に配列の添字の範囲を指定することができる．以下の例はどちらも長さ5の配列を宣言しているが，配列にアクセスするときの添字の範囲が異なる．

::

    integer :: a(5)   ! 長さ5の配列
    integer :: b(0:4) ! 長さ5の配列(ただし添字は0から4まで)

また，以下に配列 ``x`` の総和を計算する例を示す．

::

    integer :: i
    real(8) :: x(100) ! 実数型の長さ100の配列
    real(8) :: s

    s = 0.0_8
    do i = 1, 100
      s = s + x(i)
    end do

このように配列の各要素に対する処理には ``do`` ループを用いる事になる．

配列の定数と初期化
==================

    :doc:`サンプルコード参照 <chap05_sample2>`

配列は宣言する時に同時に初期化することも可能である．例えば

::

    integer :: a(5) = (/1, 2, 4, 8, 16/) ! 長さ5の配列を宣言時に初期化

のようにすればよい．ここで宣言した配列の長さと右辺の要素数は同じになっていなければならない．これを用いると ``parameter`` 属性を付けて定数配列を宣言することも出来る．

::

    integer, parameter :: b(3) = (/-1, 0, 1/) ! 長さ3の定数配列を宣言

通常の定数変数と同じように，定数として宣言された配列は参照は出来るが値の変更は出来ないようになっている．

配列名を指定せずに無名の定数配列を作ることも出来る．これには"``(/`` "と"``/)``"で全体を，"``,`` "で各要素を区切って記述する．例えば以下の例では長さ3の定数配列を出力する．

::

    write(*,*) (/1, 2, 3/)

動的割付け
==========

    :doc:`サンプルコード参照 <chap05_sample3>`

通常の配列はコンパイル時に静的に配列のサイズが決定される．予め必要な領域(メモリ)サイズが分かっていればこれで良いのだが，実行してみるまで必要な領域サイズが分からない場合にはこれでは対処できない．このような時には ``allocatable`` 属性を用いることで，実行時に動的に配列用にメモリを割り付けることができる．具体的な使い方は以下のようになる．

::

    integer :: n
    real(8), allocatable :: x(:) ! 動的配列(allocatable array)を宣言

    ! 標準入力から整数を読み込む
    read(*,*) n

    ! 長さnの配列用にメモリを割り付け
    allocate(x(n))

    !何かの処理

    ! メモリの開放
    deallocate(x)

``allocatable`` 属性を付けた配列はコンパイル時には長さが未定なので，上の例の2行目のように ``a(:)`` という形式で宣言する．この例では5行目で標準入力から整数を読み込み，それを長さとするように8行目でメモリを割り付けている．``allocate`` で確保したメモリは使い終わったらこの例のように ``deallocate`` で開放してやるのが作法である．いわゆるメモリリークという厄介なバグはこのような動的に割り付けたメモリの解放忘れによって発生するので気をつけよう [#]_．なおメモリが既に割りつけられているかどうかを確認するために ``allocated`` という関数も用意されている．この関数はメモリが割り付けられている場合には真を返すので，例えば

::

    ! 既にメモリが割り付けられている場合は何もしない
    if( .not. allocated(x) ) then
      allocate(x(n))
    end if

    ! 何かの処理

    ! 既にメモリが解放されている場合には何もしない
    if( allocated(x) ) then
      deallocate(x)
    end if

などのように使うことが出来る．

多次元配列
==========

    :doc:`サンプルコード参照 <chap05_sample4>`

ここまで扱った配列は1次元配列と呼ばれるものであったが，多次元の配列も使うことができる．分り易い例として1次元配列はベクトル，2次元配列は行列と考えればよいだろう．多次元配列の宣言には次元の分だけ(各次元の)長さを指定すれば良い．

::

    integer :: i, j
    real(8) :: a(10,10)

    do j = 1, 10
      do i = 1, 10
        write(*,*) a(i, j)
      end do
    end do

例えば上の例では2次元配列 ``a(10,10)`` を宣言して2重 ``do`` ループでその値を出力している．多次元配列の場合は配列の各要素にアクセスするために添字を次元の数だけ指定しなければならない．なお配列の次元数をrank，各次元の要素数の組をshape，全要素数をsizeなどと呼ぶことが一般的である．これらの言葉の意味は次の表を見てもらえばすぐに理解出来るであろう．

.. tabularcolumns:: |p{0.2 \textwidth}|p{0.2 \textwidth}|p{0.2 \textwidth}|p{0.2 \textwidth}|
.. list-table:: 配列宣言の例
    :widths: 20, 20, 20, 20
    :header-rows: 1

    * - 配列宣言
      - rank
      - shape
      - size

    * - ``a(10)``
      - 1
      - (10,)
      - 10

    * - ``b(2, 5)``
      - 2
      - (2, 5)
      - 10

    * - ``c(10,10,10)``
      - 3
      - (10,10,10)
      - 1000

    * - ``d(0:9,0:99)``
      - 2
      - (10, 100)
      - 1000

多次元配列の場合も ``allocatable`` 属性を指定して動的にメモリを割り付けることも出来る．この際の配列宣言や ``allocate`` によるメモリ割り付けは

::

    real(8), allocatable :: x(:,:,:)

    allocate(x(5,10,20))

の様に行う．配列のサイズは実行時に決定することが出来るのに対して，rankはコンパイル時に決定され，実行中には変更できないことに注意しよう．

.. _c5_array_io:

配列の入出力
============

    :doc:`サンプルコード参照 <chap05_sample5>`

配列データの入出力についてもこれまでと同様に各要素を ``read(*,*)`` や ``write(*,*)`` に対する入出力リストとして与える方法もあるが，例えば配列全体を入出力リストとして与えることなども出来る．詳細は :ref:`c6_file_io` で説明するが，ここではとりあえずアスキー形式(人間の目で読める形式)のことだけを考えることにする．

配列の各要素を出力するには，``do`` ループを用いて例えば

::

    integer :: i
    real(8) :: x(10)

    do i = 1, 10
      write(*,*) x(i)
    end do

のような処理を行えば良い．この場合は各要素が出力された後に改行が挿入されるので結果の出力は10行になる．これに対して

::

    write(*,*) x                    ! 改行せずに1行に全要素を出力
    write(*,*) (x(i), i = 1, 10)    ! 同上
    write(*,*) (x(i), i = 1, 10, 2) ! 1つ飛ばしで出力

などのように ``do`` ループと同じような書き方が可能であり，先ほどの例との違いは改行が挿入されるかどうかである．

配列の入力についても両方の書き方が可能である．

::

    ! 10個の要素を順に読み込む
    do i = 1, 10
      read(*,*) x(i)
    end do

    ! 同上
    read(*,*) (x(i), i = 1, 10)

    ! これでも良い
    read(*,*) x

例えば上の例で2-4行目と7行目は同じ処理をする．なおFortranはデフォルトで空白，Tab，カンマ，改行などを各要素の区切りとして解釈することに注意をして欲しい．すなわち

.. code-block:: bash

    1.0, 2.0, ... 9.0, 10.0

と

.. code-block:: bash

    1.0
    2.0
    ...
    9.0
    10.0

のどちらでも同じように(正しく)読み込まれることになる．ちなみに復習しておくと，予め存在するファイルの内容を上のような処理によって読み込むにはリダイレクトを使って

.. code-block:: bash

     $ ./a.out < data.dat

のようにすれば良い．(この例ではdata.datの内容をa.outに渡している．)

多次元配列の読み込みについては少し注意が必要である．例えば

.. code-block:: bash

     1.0  2.0  3.0
     4.0  5.0  6.0
     7.0  8.0  9.0
    10.0 11.0 12.0

というファイルを標準入力へのリダイレクトから3x4の2次元配列として読み込む場合に

::

    real(8) :: x(3,4)

    read(*,*) x

とすると，``x(1,1), x(2,1), x(3,1), x(1,2), ...`` にそれぞれ ``1.0, 2.0, 3.0, 4.0, ...`` が代入されることになる．これは入力が先頭から順々に行われ，またFortranの多次元配列のメモリ並びがこの順番になっているためである(メモリ並びについては :ref:`columnrow` 参照)．配列の形状が何であってもかならずこの順番で読み込まれるため，例えば

::

    real(8) :: x(2,6)

    read(*,*) x

であれば，``x(1,1), x(2,1), x(1,2), x(2,2), ...`` の順で ``1.0, 2.0, 3.0, 4.0, ...`` が代入されてしまう．このように多次元配列の読み込みは(初心者にとっては)必ずしも意図する結果にならないことがあるので注意して欲しい．

また ``read(*,*)`` は一度に行末までを読み込むようになっているため，

::

    integer :: i, j
    real(8) :: x(3,4)

    ! 注意: これは動かない !
    do j = 1, 4
      do i = 1, 3
        read(*,*) x(i,j)
      end do
    end do

のような2重ループの形式では正しく読み込むことが出来ないので注意して欲しい．


配列に関する組込み関数
======================

    :doc:`サンプルコード参照 <chap05_sample6>`

Fortranにはいくつか配列に関する便利な組込み関数が用意されている．細かい使い方についてはサンプルコードや自分で実際にコードを書いてみて動作確認をしてみるのが一番の近道である．

例えば以下の例ではベクトル同士の内積を計算する ``dot_product`` や行列同士もしくは行列とベクトルの積を計算する ``matmul`` の使い方を示している．

::

    integer, parameter :: n = 5
    integer :: i, j
    real(8) :: a(n,n), b(n), x(n)
    real(8) :: inner

    ! aとxに何らかの値を入れる

    ! 初期化
    do i = 1, n
      b(i) = 0.0_8
    end do

    ! 行列aとベクトルxの積をbに代入: b_{i} = a_{i,j} * x_{j}
    do j = 1, n
      do i = 1, n
        b(i) = b(i) + a(i,j) * x(j)
      end do
    end do

    ! 組み込み関数を使用して同じ計算を行う
    b = matmul(a, x)

    ! ベクトル同士の内積を計算
    inner = 0.0_8
    do i = 1, n
      inner = inner + b(i) * x(i)
    end do

    ! 組み込み関数を使用して同じ計算を行う
    inner = dot_product(b, x)

この例では9-18行目と21行目はどちらも行列とベクトルの積を求めるものである．同様に24-27行目と30行目も全く同じ処理(内積計算)を行なっている．組込み関数を用いることで非常に簡単に処理が記述できることがお分かり頂けるだろう．数学関数に加えてよく使われる組み込み関数をいくつか以下の表に挙げておこう．念のために言うとこれらは必ずしも記憶して置かなければいけないものでは無く，必要になった時に自分で調べて使いこなすことが出来ればそれで良い．(例えば富田・齋藤(2011，6章)が配列に関する組み込み関数について詳しい．)

.. tabularcolumns:: |p{0.4 \textwidth}|p{0.5 \textwidth}|
.. list-table:: 配列に関する組み込み関数の例
    :widths: 40, 50
    :header-rows: 1

    * - 関数名
      - 説明

    * - ``dot_product(x, y)``
      - ベクトル(1次元配列) ``x`` と ``y`` の内積を返す

    * - ``matmul(x, y)``
      - 行列(2次元配列)同士，もしくは行列とベクトル(1次元配列)の積を返す

    * - ``transpose(x)``
      - 行列(2次元配列)の転置を返す

    * - ``sum(x)``
      - 配列 ``x`` の各要素の和を返す

    * - ``product(x)``
      - 配列 ``x`` の各要素の積を返す

    * - ``size(x)``
      - 配列 ``x`` の全要素数(サイズ)を返す

    * - ``shape(x)``
      - 配列 ``x`` の形状を1次元の整数型配列として返す

    * - ``reshape(x, s)``
      - 配列 ``x`` の形状を新しい形状 ``s`` に変換したものを返す

    * - ``maxval(x)``
      - 配列 ``x`` の全要素の最大値を返す

    * - ``minval(x)``
      - 配列 ``x`` の全要素の最小値を返す

なお ``reshape`` を使うと多次元の配列定数を初期化することが出来る．以下はその例である．

::

    integer, parameter :: x(2,3) = reshape((/1, 2, 3, 4, 5, 6/), (/2, 3/))

``reshape`` の第1引数は任意の配列であり，この配列の形状を変更したものを返す．第2引数には新しい配列の形状を指定している．ここでは左辺の配列の形状が ``(2,3)`` であるので ``reshape`` の第2引数は ``(/2, 3/)`` と形状を1次元の整数配列として指定している．当然，元々の入力配列のサイズと新しい配列のサイズは同じでなければならない [#]_．

部分配列
========

    :doc:`サンプルコード参照 <chap05_sample7>`

これまでは各要素に添字を用いて例えば ``x(10)`` のような形でアクセスしていた．Fortranではこれに加えて *部分配列* という便利な機能があり，配列の複数の要素にまとめてアクセスすることが出来る．これには添字の代わりに ``x(lower:upper:stride)`` のような形式を用いる．``lower``，``upper``，``stride`` の意味は ``do`` 変数の指定方法(:ref:`c4_do`)と同じである．従って例えば

::

    integer :: x(10) = (/1, 2, 3, 4, 5, 6, 7, 8, 9, 10/)

    write(*,*) x(1:10:2) ! 1, 3, 5, 7, 9が出力される

のように書くことが出来る．``lower``，``upper``，``stride`` などは省略することも出来，その場合は ``lower`` は配列の最初の要素，``upper`` は最後の要素，``stride`` は1と解釈される．ただし ``stride`` はともかく ``lower``，``upper`` は明示的に書いておいた方が分かりやすい．またこれらの指定に変数を使う事もできる．

配列演算
========

    :doc:`サンプルコード参照 <chap05_sample7>`

さらに，Fortranには非常に強力な *配列演算* という機能が用意されている．例えば以下の例を見てみよう．

::

    integer, parameter :: n = 8
    integer :: i
    real(8) :: a(n), b(n), c(n)

    ! 代入
    do i = 1, n
       b(i) = a(i)
    end do

    ! 配列演算による代入(上のdoループと同じ)
    b = a

    write(*,*) 'b = ', b ! 配列bの全要素を出力

    ! 演算
    do i = 1, n
       c(i) = 0.5_8*a(i) + cos(b(i))
    end do

    ! 配列演算(上のdoループと同じ)
    c = 0.5_8*a + cos(b)

    write(*,*) 'c = ', c ! 配列cの全要素を出力

上の例の6-8行目と11行目，16-18行目と21行目は等価である．このようにFortranでは *配列同士の演算をあたかも通常の変数であるかのように記述することができる*．これを配列演算と呼ぶ．数学で用いるような直感的な表現が出来ることに加えて，これを用いることでかなりタイプ量を減らすことができるのが一目見て分かるだろう．タイプ量が少ないと当然無用なバグの混入を避けることができる．さらに，配列演算はコンパイラによる最適化の恩恵を受けやすいという利点がある．部分配列と配列演算を組み合わせることも当然可能である．例えば

::

    integer, parameter :: m = 10
    real(8) :: x(m), y(m/2)

    y = 2*x(1:m:2) + 1

のような使い方が出来る．また部分配列や配列演算の機能は多次元配列でも同様に使用することが出来る．ただし，配列演算は *同じ形状(次元およびサイズ)の配列に対してしか行うことが出来ない*．それ以外の場合には演算が定義されないのでこれは当たり前の話である．

また，数学におけるベクトルの内積やベクトルと行列の積の計算規則とは異なり，配列演算はあくまで各要素ごとの演算であるという点に注意しよう．例えば ``x(100)`` と ``y(100)`` のような2つのサイズの等しい1次元配列の積 ``x*y`` は同じサイズ100の配列となり，スカラー値を計算する内積の計算規則とは異なる．また行列 ``M(100,100)`` とベクトル ``x(100)`` の積を計算しようとして ``M*x`` と記述しても ``M`` と ``x`` は形状が異るのでエラーとなってしまう．このような場合は先に見た ``dot_product`` や ``matmul`` を使えば良い．

補足 :sup:`†`
==============

メモリ領域
----------

Fortranの通常の静的配列(static array)の場合はメモリはスタック(stack)と呼ばれる領域に保持される．環境によっては(おそらく多くのLinux環境のデフォルトでは)スタックに大きなメモリ領域を保持できないようになっている．この設定は例えばsh系のシェル(bashなど)では以下のように ``ulimit`` コマンド(csh系のシェルならば ``limit``)で確認することが出来る．

.. code-block:: bash

    $ ulimit -a
    core file size          (blocks, -c) 0
    data seg size           (kbytes, -d) unlimited
    file size               (blocks, -f) unlimited
    max locked memory       (kbytes, -l) unlimited
    max memory size         (kbytes, -m) unlimited
    open files                      (-n) 256
    pipe size            (512 bytes, -p) 1
    stack size              (kbytes, -s) 8192
    cpu time               (seconds, -t) unlimited
    max user processes              (-u) 709
    virtual memory          (kbytes, -v) unlimited

上の ``ulimit`` コマンドの出力結果から，この環境ではスタック領域が8MBに制限されているので大きな静的配列を確保することが出来ないことが分かる．プログラムの実行直後に原因不明の ``Segmentation fault`` などのエラーで終了してしまう場合はスタック領域が足りずにメモリが確保出来なかったことが原因かもしれない．

どうしても静的配列を使いたい場合には ``ulimit`` コマンドで使用可能なスタック領域を増やせば良い．もしくは静的配列の使用をやめて ``allocatable`` 配列を用いるようにすればスタック領域の制限は受けない．これは ``allocatable`` 属性付きで宣言された配列のメモリは( ``allocate`` によって)ヒープ(heap)と呼ばれる別の領域にメモリが確保されるためである．なおスタックとかヒープについて必ずしも理解している必要は無いが，原因不明のエラーが発生した時にはこのことをふと思い出して欲しい．

.. _columnrow:

Column majorとRow major
-----------------------

既に説明したように配列は計算機の連続したメモリ上に確保されることが保証されている．これは1次元の場合には分かりやすいが，多次元配列の場合はどうなっているのであろうか？計算機のメモリは1次元的なアドレスからなっているので，実は多次元配列であってもメモリは内部的には1次元的に連続な領域を指している．多次元配列は単にそれらを使いやすく表示したものに過ぎない．一般的にFortranでは例えば2次元配列 ``x(10,10)`` の場合は ``x(1,1)``, ``x(2,1)``, ..., ``x(10,1)``, ``x(1,2)``, ``x(2,2)``, ...のような並び，すなわち配列の一番左の添字がメモリの連続した方向となっている．これ をcolumn majorと呼ぶ．これに対してC言語などではrow majorと呼ばれるメモリ並びが採用されており一番右側の添字がメモリの連続する方向となっている(図参照)．従って，C言語で書かれたライブラリをFortranから呼び出す際(もしくはその逆)にはこの違いに注意しなければならない．

またこのことから，効率的なプログラムとするためには多次元配列のループの書き方も注意が必要である．以下の例を考えてみよう．

::

    integer :: i, j
    real(8) :: a(10,10), s


    ! 例1
    s = 0.0_8
    do j = 1, 10
      do i = 1, 10
        s = s + a(i, j)
      end do
    end do

    ! 例2
    s = 0.0_8
    do i = 1, 10
      do j = 1, 10
        s = s + a(i, j)
      end do
    end do

この例では5-11行目(例1)と13-19行目(例2)は全く同じ処理(配列内の全要素の総和計算)を行なっているが，多重 ``do`` ループの添字の順番が異なることに注目して欲しい．例1では左側の添字 ``i`` が内側のループで走り，例2では右側の添字 ``j`` が内側のループで走っている．基本的に計算機というのは単純作業(例えば ``if`` 分岐などがないループ)を一気に，メモリの連続している方向に順番に処理するのが得意になっている．従って，この例では左側の添字が内側ループで走る例1の方が効率の良いプログラムということになる [#]_．最初はそれほど気にすることは無いが，単に「動く」だけのプログラムでは無く，「良い」プログラムとなるように細かい点についても気を配れるようになって欲しい．

.. figure:: figure/storageorder.png
    :align: center
    :width: 600px

    Column majorとRow major．メモリは左から右に連続的に並んでいる．
    (C言語の場合は実際には配列添字は0から始まり，添字も ``[]`` で指定することに注意．)



配列境界チェック
----------------

配列の添字の範囲をはみ出した場合には何が起こるだろうか? 実はこの時何が起こるかは実行してみるまで分からない．何事も無かったかのように正常終了するように見える場合もあるし，"Segmentation fault"などのエラーが表示されて異常終了することもある．1つだけ言えることはそのようなプログラムは例え正しく動いているように見えたとしてもかなり危険な状態である．なぜならプログラムで自分が「使いたい」と要請したメモリ領域とは異なる領域へアクセスしていることになるので，自分のプログラムで用いているメモリ領域はおろか，OSがプログラムの実行に必要とする情報(コールスタックなどと呼ばれる)をも意図せず書き換えてしまうかもしれない．異常終了しなかったとしても，それはたまたま運が良かっただけなの話である．たった1行ソースコードを書き換えただけでも，プログラム中のメモリ配置が変わることで動作がおかしくなるかもしれない．(1行 ``write`` 文を入れるかどうかだけの違いで動作が変わるような場合もあるが，そういう時には大抵おかしなメモリ領域にアクセスしているものである．)

そもそも配列の添字範囲をはみ出すのは明らかなバグである．通常は効率を重視するため配列添字の境界チェックは行われないが，gfortranではコンパイル時に ``-fbounds-check`` というオプションをつけることでこの配列境界チェックを行うことが出来る．(多くのFortranコンパイラが同じようなオプションを有しているので他のコンパイラを用いる時にはチェックしてみて欲しい．) これによってもし境界をはみ出した場合にはその旨エラーが出力されてプログラムが終了する．

::

   program check
     implicit none

     integer :: i = 11
     integer :: x(10)

     x(i) = 1

     stop
   end program check

例えば上のソースコードをcheck.f90として保存し，コンパイル・実行した結果は以下のようになる．

.. code-block:: bash

     $ gfortran -fbounds-check check.f90
     $ ./a.out
    At line 7 of file check.f90
    Fortran runtime error: Index '11' of dimension 1 of array 'x' above upper bound of 10

配列 ``x`` の上限(10)を超えた11番目の要素にアクセスしているのでエラーが表示されているのが分かる．ただし，このようなチェックを逐一行うことで，当然実行時のパフォーマンスは犠牲になる．従って，デバッグの段階でこのような配列境界チェックを行い，時間のかかる計算を実行する際にはこのオプションは外しておこう．

..
.. 課題
..

.. include:: chap05_kadai.rst


----

.. [#]

   計算機の中でデータの塊を扱う形式のことを一般にデータ構造と呼ぶ．配列は最も単純なデータ構造の一つと考えることが出来る．

.. [#]

   プログラムが終了する際には当然全てのメモリが解放されるので必要以上に心配する必要は無い．また，Fortran 95以降では ``allocatable`` な配列は，スコープから外れた時(後述のサブルーチンなどから出た時)には自動的に ``deallocate`` されるということになったようである．従って通常はあえて ``deallocate`` しなくても良いかも知れない．ただし，一般的に借りたものは必ず返すというのがプログラミングでは礼儀になっているので，ちゃんと ``deallocate`` するように癖をつけておいた方が無難である．例えばC言語では ``malloc`` などでメモリを割り付けた場合は ``free`` で明示的に解放しない限りプログラム終了までメモリを保持し続ける．

.. [#]

   このように配列形状を変更できることを不思議に思うかもしれない．しかし，実際には1次元配列も多次元配列も中身は同じ1次元的なメモリ領域を指しており，使う側には便宜上違う次元のもののように見えているだけなのである．詳しくは :ref:`columnrow` を参照のこと．

.. [#]

   実際にはプログラムの構造やループ内でのメモリ使用量，CPUやコンパイラの性能に大きく依存する(かしこいコンパイラはループの順序を交換したりすることもある)．またこの程度の小さな配列ではほとんど差が見られないであろう．
