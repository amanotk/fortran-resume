

<!doctype html>

<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>5. 配列 &#8212; Fortran演習(地球惑星物理学演習)</title>
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="6. 書式指定・ファイル入出力・文字列処理" href="chap06.html" />
    <link rel="prev" title="4. 制御構造" href="chap04.html" />
<link rel="stylesheet" type="text/css" href="http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-99010794-2', 'auto');
  ga('send', 'pageview');

</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="chap06.html" title="6. 書式指定・ファイル入出力・文字列処理"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="chap04.html" title="4. 制御構造"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Fortran演習</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">5. 配列</a><ul>
<li><a class="reference internal" href="#id3">5.1. 基本的な使い方</a></li>
<li><a class="reference internal" href="#id5">5.2. 配列の定数と初期化</a></li>
<li><a class="reference internal" href="#id6">5.3. 動的割付け</a></li>
<li><a class="reference internal" href="#id8">5.4. 多次元配列</a></li>
<li><a class="reference internal" href="#c5-array-io">5.5. 配列の入出力</a><ul>
<li><a class="reference internal" href="#id10">5.5.1. 入力</a></li>
<li><a class="reference internal" href="#id12">5.5.2. 出力</a></li>
<li><a class="reference internal" href="#id13">5.5.3. 多次元配列について</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id14">5.6. 配列に関する組込み関数</a></li>
<li><a class="reference internal" href="#id16">5.7. 部分配列</a></li>
<li><a class="reference internal" href="#id17">5.8. 配列演算</a></li>
<li><a class="reference internal" href="#id18">5.9. 補足 <sup>†</sup></a><ul>
<li><a class="reference internal" href="#id19">5.9.1. メモリ領域</a></li>
<li><a class="reference internal" href="#column-majorrow-major">5.9.2. Column majorとRow major</a></li>
<li><a class="reference internal" href="#id21">5.9.3. 配列境界チェック</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id22">5.10. 第5章 演習課題</a><ul>
<li><a class="reference internal" href="#id23">5.10.1. 課題1</a></li>
<li><a class="reference internal" href="#id24">5.10.2. 課題2</a></li>
<li><a class="reference internal" href="#id25">5.10.3. 課題3</a></li>
<li><a class="reference internal" href="#id26">5.10.4. 課題4</a></li>
<li><a class="reference internal" href="#id27">5.10.5. 課題5</a></li>
<li><a class="reference internal" href="#id28">5.10.6. 課題6</a></li>
<li><a class="reference internal" href="#id29">5.10.7. 課題7</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="chap04.html"
                        title="前の章へ"><span class="section-number">4. </span>制御構造</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="chap06.html"
                        title="次の章へ"><span class="section-number">6. </span>書式指定・ファイル入出力・文字列処理</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="検索" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id59"><span class="section-number">5. </span>配列</a><a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>大量のデータをまとめて扱うのに便利な配列について，その基本的な使い方や配列に関する組込み関数の使い方などを学ぼう．</p>
<blockquote>
<div><p>サンプルプログラム</p>
<ul class="simple">
<li><p><a class="reference internal" href="chap05_sample1_f90.html"><span class="doc">sample1.f90</span></a> : 配列の基本</p></li>
<li><p><a class="reference internal" href="chap05_sample2_f90.html"><span class="doc">sample2.f90</span></a> : 配列の定数と初期化</p></li>
<li><p><a class="reference internal" href="chap05_sample3_f90.html"><span class="doc">sample3.f90</span></a> : 動的配列</p></li>
<li><p><a class="reference internal" href="chap05_sample4_f90.html"><span class="doc">sample4.f90</span></a> : 多次元配列</p></li>
<li><p><a class="reference internal" href="chap05_sample5_f90.html"><span class="doc">sample5.f90</span></a> : 配列の入出力1</p></li>
<li><p><a class="reference internal" href="chap05_sample6_f90.html"><span class="doc">sample6.f90</span></a> : 配列の入出力2</p></li>
<li><p><a class="reference internal" href="chap05_sample7_f90.html"><span class="doc">sample7.f90</span></a> : 配列に関する組込み関数</p></li>
<li><p><a class="reference internal" href="chap05_sample8_f90.html"><span class="doc">sample8.f90</span></a> : 部分配列と配列演算</p></li>
</ul>
</div></blockquote>
<div class="contents topic" id="id2">
<p class="topic-title">この章の内容</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id59">配列</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id60">基本的な使い方</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id61">配列の定数と初期化</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id62">動的割付け</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id63">多次元配列</a></p></li>
<li><p><a class="reference internal" href="#c5-array-io" id="id64">配列の入出力</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id65">配列に関する組込み関数</a></p></li>
<li><p><a class="reference internal" href="#id16" id="id66">部分配列</a></p></li>
<li><p><a class="reference internal" href="#id17" id="id67">配列演算</a></p></li>
<li><p><a class="reference internal" href="#id18" id="id68">補足 <sup>†</sup></a></p></li>
<li><p><a class="reference internal" href="#id22" id="id69">第5章 演習課題</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id60"><span class="section-number">5.1. </span>基本的な使い方</a><a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>配列とは <strong>同じ型</strong> の複数のデータを効率的に扱うために用いるデータ構造 <a class="footnote-reference brackets" href="#id30" id="id4">1</a> である．配列も通常の変数と同じように宣言が必要であり，宣言時には配列であることを明示的に示さなければならない．配列を宣言すると計算機の <strong>メモリ上の連続した領域</strong> が確保され，それぞれのアドレスに添字を用いてアクセスできるようになる．</p>
<p>具体的には以下のように配列を宣言する．</p>
<div class="literal-block-wrapper docutils container" id="id35">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample1_f90.html"><span class="doc">sample1.f90</span></a> 抜粋</span><a class="headerlink" href="#id35" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c">! 最も基本的な配列の宣言</span>
  <span class="kt">integer</span> <span class="kd">::</span> <span class="n">a</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

  <span class="c">! 配列の添字範囲を指定して宣言</span>
  <span class="kt">integer</span> <span class="kd">::</span> <span class="n">b</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>
  <span class="kt">integer</span> <span class="kd">::</span> <span class="n">c</span><span class="p">(</span><span class="mi">6</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<p>7行目が最も基本的な(ここでは整数型の)配列の宣言であり，この場合は長さ5の <code class="docutils literal notranslate"><span class="pre">a</span></code> という名前の配列を宣言している．この例では <code class="docutils literal notranslate"><span class="pre">a(1)</span></code> が最初の要素であり， <code class="docutils literal notranslate"><span class="pre">a(5)</span></code> が最後の要素ということになる．C言語を始めとする多くの言語では配列の添字は0から始まることになっているので注意して欲しい．ただしFortranでは，10-11行目のような宣言によって宣言時に配列の添字の範囲を指定することができる．これらの例はどちらも長さ5の配列を宣言しているが， <code class="docutils literal notranslate"><span class="pre">b</span></code> はから0から4まで， <code class="docutils literal notranslate"><span class="pre">c</span></code> は6から10までが正しい配列の添字の範囲である．配列の要素にアクセスするには</p>
<div class="literal-block-wrapper docutils container" id="id36">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample1_f90.html"><span class="doc">sample1.f90</span></a> 抜粋</span><a class="headerlink" href="#id36" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c">! doループで配列の各要素を処理する</span>
  <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span>
     <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span>
  <span class="k">end do</span>

<span class="k">  do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span>
     <span class="n">b</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span>
  <span class="k">end do</span>

  <span class="c">! 各要素同士の演算も出来る(添字に注意)</span>
  <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span>
     <span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">end do</span>
</pre></div>
</td></tr></table></div>
</div>
<p>のように <code class="docutils literal notranslate"><span class="pre">()</span></code> で添字を指定すればよい．ここで， <code class="docutils literal notranslate"><span class="pre">b</span></code> や <code class="docutils literal notranslate"><span class="pre">c</span></code> は添字の範囲が異なっていることに注意しよう．</p>
<p>また，以下は長さ100の配列 <code class="docutils literal notranslate"><span class="pre">x</span></code> の総和を計算する例である．</p>
<div class="literal-block-wrapper docutils container" id="id37">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample1_f90.html"><span class="doc">sample1.f90</span></a> 抜粋</span><a class="headerlink" href="#id37" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>49
50
51
52
53</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c">! 配列の和を求める</span>
  <span class="nb">sum</span> <span class="o">=</span> <span class="mf">0.0_8</span>
  <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span>
     <span class="nb">sum</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">+</span> <span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="k">end do</span>
</pre></div>
</td></tr></table></div>
</div>
<p>このように配列の各要素に対する処理には <code class="docutils literal notranslate"><span class="pre">do</span></code> ループを用いる事になる．</p>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id61"><span class="section-number">5.2. </span>配列の定数と初期化</a><a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>配列は宣言する時に同時に初期化することも可能である．例えば</p>
<div class="literal-block-wrapper docutils container" id="id38">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample2_f90.html"><span class="doc">sample2.f90</span></a> 抜粋</span><a class="headerlink" href="#id38" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>5</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="kt">integer</span> <span class="kd">::</span> <span class="n">a</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="o">/</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<p>のようにすればよい．ここで宣言した配列の長さと右辺の要素数は同じになっていなければならない．これを用いると <code class="docutils literal notranslate"><span class="pre">parameter</span></code> 属性を付けて定数配列を宣言することも出来る．</p>
<div class="literal-block-wrapper docutils container" id="id39">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample2_f90.html"><span class="doc">sample2.f90</span></a> 抜粋</span><a class="headerlink" href="#id39" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>8</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span> <span class="kd">::</span> <span class="n">b</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">/-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<p>通常の定数変数と同じように，定数として宣言された配列は参照は出来るが値の変更は出来ないようになっている．</p>
<p>配列名を指定せずに無名の定数配列を作ることも出来る．これには&quot;<code class="docutils literal notranslate"><span class="pre">(/</span></code> &quot;と&quot;<code class="docutils literal notranslate"><span class="pre">/)</span></code>&quot;で全体を，&quot;<code class="docutils literal notranslate"><span class="pre">,</span></code> &quot;で各要素を区切って記述する．例えば以下の例では長さ3の定数配列を出力する．</p>
<div class="literal-block-wrapper docutils container" id="id40">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample2_f90.html"><span class="doc">sample2.f90</span></a> 抜粋</span><a class="headerlink" href="#id40" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>11</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id62"><span class="section-number">5.3. </span>動的割付け</a><a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>通常の配列はコンパイル時に静的に配列のサイズが決定される．予め必要な領域(メモリ)サイズが分かっていればこれで良いのだが，実行してみるまで必要な領域サイズが分からない場合にはこれでは対処できない．このような時には <code class="docutils literal notranslate"><span class="pre">allocatable</span></code> 属性を用いることで，実行時に動的に配列用にメモリを割り付けることができる．具体的には以下のように <code class="docutils literal notranslate"><span class="pre">allocatable</span></code> な配列を宣言すればよい．</p>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">integer</span><span class="p">,</span> <span class="k">allocatable</span> <span class="kd">::</span> <span class="n">x</span><span class="p">(:)</span>
</pre></div>
</td></tr></table></div>
<p>ここでは整数型の <code class="docutils literal notranslate"><span class="pre">x</span></code> という配列を宣言しているが，その長さはコンパイル時には不定(実行するときまで分からない)ので <code class="docutils literal notranslate"><span class="pre">x(:)</span></code> のように長さが指定されていないことに注意しよう．これを配列として使う前には</p>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">allocate</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>のように <code class="docutils literal notranslate"><span class="pre">allocate</span></code> 関数によって，メモリを割り付ける必要がある．これによって，以降は <code class="docutils literal notranslate"><span class="pre">x</span></code> は(この場合は長さ100の)配列として使うことができる． <code class="docutils literal notranslate"><span class="pre">allocate</span></code> で確保したメモリは使い終わったら</p>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">deallocate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>のように <code class="docutils literal notranslate"><span class="pre">deallocate</span></code> で開放してやるのが作法である．いわゆるメモリリークという厄介なバグはこのような動的に割り付けたメモリの解放忘れによって発生するので気をつけよう <a class="footnote-reference brackets" href="#id31" id="id7">2</a>．</p>
<p>なお，メモリが既に割りつけられているかどうかを確認するために <code class="docutils literal notranslate"><span class="pre">allocated</span></code> という関数も用意されている．この関数はメモリが割り付けられている場合には真を返す．例えば</p>
<div class="literal-block-wrapper docutils container" id="id41">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample3_f90.html"><span class="doc">sample3.f90</span></a> 抜粋</span><a class="headerlink" href="#id41" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c">! 動的配列(実行時にしかサイズが分からない場合)</span>
  <span class="kt">integer</span><span class="p">,</span> <span class="k">allocatable</span> <span class="kd">::</span> <span class="n">x</span><span class="p">(:)</span>

  <span class="c">! 以下は動的(allocatable)配列の使い方</span>
  <span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="s1">&#39;Input array size: &#39;</span>

  <span class="c">! 配列サイズ</span>
  <span class="k">read</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="n">n</span>

  <span class="c">! allocateされていないことを確認してからallocate</span>
  <span class="k">if</span><span class="p">(</span> <span class="p">.</span><span class="nb">not</span><span class="p">.</span> <span class="nb">allocated</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">     allocate</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
  <span class="k">else</span>
<span class="k">     write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="s1">&#39;Error: already allocated&#39;</span>
  <span class="k">end if</span>

  <span class="c">! 確かにallocateされたか?</span>
  <span class="k">if</span><span class="p">(</span> <span class="nb">allocated</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">     write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="s1">&#39;Successfully allocated&#39;</span>
  <span class="k">end if</span>
</pre></div>
</td></tr></table></div>
</div>
<p>のように使うことができる．これは標準入力から与えられた整数を長さとする配列を割り付ける例である．単に <code class="docutils literal notranslate"><span class="pre">allocate</span></code> するだけでなく，その前に <code class="docutils literal notranslate"><span class="pre">allocated</span></code> で既にメモリが割り付けられているかどうか確認している．この場合はプログラムの全体像がひと目で分かる規模のためこの確認作業は冗長であるが，場合によってはこのようなチェックが必要なこともあるだろう．</p>
</div>
<div class="section" id="id8">
<h2><a class="toc-backref" href="#id63"><span class="section-number">5.4. </span>多次元配列</a><a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ここまで扱った配列は1次元配列と呼ばれるものであったが，多次元の配列も使うことができる．分り易い例として1次元配列はベクトル，2次元配列は行列と考えればよいだろう．多次元配列の宣言には次元の分だけ(各次元の)長さを指定すれば良い．具体的には以下のような宣言となる．</p>
<div class="literal-block-wrapper docutils container" id="id42">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample4_f90.html"><span class="doc">sample4.f90</span></a> 抜粋</span><a class="headerlink" href="#id42" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c">! 2次元配列 (10 x 10 =&gt; 計100要素)</span>
  <span class="kt">real</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="kd">::</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>

  <span class="c">! 3次元配列 (4 x 8 x 16 =&gt; 計512要素)</span>
  <span class="kt">real</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="kd">::</span> <span class="n">b</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

  <span class="c">! 動的配列も同様に宣言できる</span>
  <span class="kt">real</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="k">allocatable</span> <span class="kd">::</span> <span class="n">c</span><span class="p">(:,:)</span>

  <span class="c">! 動的配列: 4 x 8</span>
  <span class="k">if</span><span class="p">(</span> <span class="p">.</span><span class="nb">not</span><span class="p">.</span> <span class="nb">allocated</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">     allocate</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
  <span class="k">end if</span>
</pre></div>
</td></tr></table></div>
</div>
<p>7行目は2次元配列，10行目は3次元配列を宣言している．このように多次元配列を宣言するには各次元の長さをカンマ区切りで指定すればよい．13行目のように多次元の動的配列も宣言することができるが，次元だけはあらかじめ指定しなければならないので <code class="docutils literal notranslate"><span class="pre">c(:,:)</span></code> のように次元の数だけ <code class="docutils literal notranslate"><span class="pre">:</span></code> をカンマ区切りで指定する．多次元の動的配列にメモリを割り付けるには17行目のように <code class="docutils literal notranslate"><span class="pre">allocate</span></code> の際に次元の数だけ長さを指定する必要がある．（このように多次元配列の次元数はコンパイル時に決定され，実行時には変更できない．）</p>
<p>宣言した配列には，次元の数だけ添字を指定して各要素にアクセスすればよい．例えば</p>
<div class="literal-block-wrapper docutils container" id="id43">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample4_f90.html"><span class="doc">sample4.f90</span></a> 抜粋</span><a class="headerlink" href="#id43" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span> 
     <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span>
        <span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">j</span>
     <span class="k">end do</span>
<span class="k">  end do</span>
</pre></div>
</td></tr></table></div>
</div>
<p>のような形である．</p>
<p>なお配列の次元数をrank(次元)，各次元の要素数の組をshape(形状)，全要素数をsize(サイズ)などと呼ぶことが一般的である．これらの言葉の意味は次の表を見てもらえばすぐに理解出来るであろう．</p>
<table class="colwidths-given docutils align-default" id="id44" style="width: 80%">
<caption><span class="caption-text">配列宣言の例</span><a class="headerlink" href="#id44" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>配列宣言</p></th>
<th class="head"><p>rank (次元)</p></th>
<th class="head"><p>shape (形状)</p></th>
<th class="head"><p>size (サイズ)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">a(10)</span></code></p></td>
<td><p>1</p></td>
<td><p>(10,)</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">b(2,</span> <span class="pre">5)</span></code></p></td>
<td><p>2</p></td>
<td><p>(2, 5)</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">c(10,10,10)</span></code></p></td>
<td><p>3</p></td>
<td><p>(10,10,10)</p></td>
<td><p>1000</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">d(0:9,0:99)</span></code></p></td>
<td><p>2</p></td>
<td><p>(10, 100)</p></td>
<td><p>1000</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="c5-array-io">
<span id="id9"></span><h2><a class="toc-backref" href="#id64"><span class="section-number">5.5. </span>配列の入出力</a><a class="headerlink" href="#c5-array-io" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>配列データの入出力についてもこれまでと同様に各要素を <code class="docutils literal notranslate"><span class="pre">read(*,*)</span></code> や <code class="docutils literal notranslate"><span class="pre">write(*,*)</span></code> に対する入出力リストとして与える方法もあるが，例えば配列全体を入出力リストとして与えることなども出来る．詳細は <a class="reference internal" href="chap06.html#c6-file-io"><span class="std std-ref">ファイル入出力</span></a> で説明するが，ここではとりあえずアスキー形式(人間の目で読める形式)のことだけを考えることにする．</p>
<div class="section" id="id10">
<h3><span class="section-number">5.5.1. </span>入力<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>配列の読み込みには少し注意が必要である．</p>
<div class="literal-block-wrapper docutils container" id="id45">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample5_f90.html"><span class="doc">sample5.f90</span></a> 抜粋</span><a class="headerlink" href="#id45" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="kt">integer</span> <span class="kd">::</span> <span class="n">i</span>
  <span class="kt">real</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="kd">::</span> <span class="n">x</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">z</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

  <span class="c">! doループで全要素を順に読み込む</span>
  <span class="c">! この場合は改行があっても構わない</span>
  <span class="k">read</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="n">x</span>

  <span class="c">! このように書いても動作は同じ</span>
  <span class="k">read</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

  <span class="c">! よく理解していない場合にはこの形式は使わない方がよい</span>
  <span class="c">! 1行に一つの要素が書かれている場合の読み込みはこれでよい</span>
  <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span>
     <span class="k">read</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="n">z</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="k">end do</span>
</pre></div>
</td></tr></table></div>
</div>
<p>これは標準入力から3つの長さ10の配列 <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> のデータを読み込む例である．ここで与えるデータの改行の扱いに注意が必要である．ここでは入力として， <a class="reference external" href="sample/chap05/sample5.dat">sample5.dat</a> をリダイレクトを用いて</p>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ ./a.out &lt; sample5.dat
</pre></div>
</td></tr></table></div>
<p>のように与えることを想定している．</p>
<p>9行目の <code class="docutils literal notranslate"><span class="pre">read</span></code> は以下のsample5.datの1行目のデータを全て読み込む．ここで改行や空白，カンマ，タブなどはFortranが自動的に無視して，数値だけを読み込んでいることに注意しよう．</p>
<div class="literal-block-wrapper docutils container" id="id46">
<div class="code-block-caption"><span class="caption-text">sample5.dat 抜粋</span><a class="headerlink" href="#id46" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="m">1</span>.0, <span class="m">2</span>.0, <span class="m">3</span>.0, <span class="m">4</span>.0, <span class="m">5</span>.0, <span class="m">6</span>.0, <span class="m">7</span>.0, <span class="m">8</span>.0, <span class="m">9</span>.0, <span class="m">10</span>.0
</pre></div>
</td></tr></table></div>
</div>
<p>12行目の <code class="docutils literal notranslate"><span class="pre">read</span></code> は以下のsample5.datの3-12行目のデータを全て読み込む．</p>
<div class="literal-block-wrapper docutils container" id="id47">
<div class="code-block-caption"><span class="caption-text">sample5.dat 抜粋</span><a class="headerlink" href="#id47" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="m">0</span>.1
<span class="m">0</span>.2
<span class="m">0</span>.3
<span class="m">0</span>.4
<span class="m">0</span>.5
<span class="m">0</span>.6
<span class="m">0</span>.7
<span class="m">0</span>.8
<span class="m">0</span>.9
<span class="m">1</span>.0
</pre></div>
</td></tr></table></div>
</div>
<p>最後に16-18行目の <code class="docutils literal notranslate"><span class="pre">do</span></code> ループ中の <code class="docutils literal notranslate"><span class="pre">read</span></code> は</p>
<div class="literal-block-wrapper docutils container" id="id48">
<div class="code-block-caption"><span class="caption-text">sample5.dat 抜粋</span><a class="headerlink" href="#id48" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="m">1</span>.1
<span class="m">1</span>.2
<span class="m">1</span>.3
<span class="m">1</span>.4
<span class="m">1</span>.5
<span class="m">1</span>.6
<span class="m">1</span>.7
<span class="m">1</span>.8
<span class="m">1</span>.9
<span class="m">2</span>.0
</pre></div>
</td></tr></table></div>
</div>
<p>を読み込んでいる．ここで注意しなければならないのは16-18行目のような <code class="docutils literal notranslate"><span class="pre">do</span></code> ループと <code class="docutils literal notranslate"><span class="pre">read</span></code> を組み合わせた読み方では</p>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="m">1</span>.1, <span class="m">1</span>.2, <span class="m">1</span>.3, <span class="m">1</span>.4, <span class="m">1</span>.5, <span class="m">1</span>.6, <span class="m">1</span>.7, <span class="m">1</span>.8, <span class="m">1</span>.9, <span class="m">2</span>.0
</pre></div>
</td></tr></table></div>
<p>のような改行なしの形式のデータをうまく読み込むことができない，ということである <a class="footnote-reference brackets" href="#id32" id="id11">3</a>．</p>
<p>あまり細かいことを考えたくない人は特に理由がない限りは <a class="reference internal" href="chap05_sample5_f90.html"><span class="doc">sample5.f90</span></a> の9行目，もしくは12行目のように <strong>一文で配列データを全て読む</strong> ( <code class="docutils literal notranslate"><span class="pre">do</span></code> ループは使わない)ようにするのが無難である．</p>
</div>
<div class="section" id="id12">
<h3><span class="section-number">5.5.2. </span>出力<a class="headerlink" href="#id12" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>配列の出力の仕方を見てみよう．</p>
<div class="literal-block-wrapper docutils container" id="id49">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample5_f90.html"><span class="doc">sample5.f90</span></a> 抜粋</span><a class="headerlink" href="#id49" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c">! doループで全要素を順に出力</span>
  <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span>
     <span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="k">end do</span>

<span class="k">  write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="n">x</span>                    <span class="c">! 改行せずに1行に全要素を出力</span>
  <span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>    <span class="c">! これも同じ</span>
  <span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">z</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c">! 1つ飛ばしで出力</span>
</pre></div>
</td></tr></table></div>
</div>
<p>21-23行目のように <code class="docutils literal notranslate"><span class="pre">do</span></code> ループを用いて行ってもよいが，25-26行目のように1行で出力することもできる．違いは <code class="docutils literal notranslate"><span class="pre">write</span></code> を一度呼び出しするごとに改行が挿入されるという点だけである．また27行目のように1つ飛ばしで出力することも可能である．</p>
</div>
<div class="section" id="id13">
<h3><span class="section-number">5.5.3. </span>多次元配列について<a class="headerlink" href="#id13" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>多次元配列の読み込みについては少し注意が必要である．例えば以下の <a class="reference external" href="sample/chap05/sample6.dat">sample6.dat</a></p>
<div class="literal-block-wrapper docutils container" id="id50">
<div class="code-block-caption"><span class="caption-text">sample6.dat</span><a class="headerlink" href="#id50" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span> <span class="m">1</span>.0  <span class="m">2</span>.0  <span class="m">3</span>.0
 <span class="m">4</span>.0  <span class="m">5</span>.0  <span class="m">6</span>.0
 <span class="m">7</span>.0  <span class="m">8</span>.0  <span class="m">9</span>.0
<span class="m">10</span>.0 <span class="m">11</span>.0 <span class="m">12</span>.0
</pre></div>
</td></tr></table></div>
</div>
<p>を2次元配列として読み込む例を考えてみよう．</p>
<div class="literal-block-wrapper docutils container" id="id51">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample6_f90.html"><span class="doc">sample6.f90</span></a> 抜粋</span><a class="headerlink" href="#id51" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="kt">real</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="kd">::</span> <span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>

  <span class="c">! 配列のメモリが連続した要素に順に読み込まれる</span>
  <span class="k">read</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="n">x</span>
</pre></div>
</td></tr></table></div>
</div>
<p>ここでもリダイレクトを用いて</p>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ ./a.out &lt; sample6.dat
</pre></div>
</td></tr></table></div>
<p>のように読み込むことを想定している．11行目の <code class="docutils literal notranslate"><span class="pre">read</span></code> で3x4の2次元配列 <code class="docutils literal notranslate"><span class="pre">x</span></code> にデータを読み込んでいることが分かるであろう．</p>
<p>ここで，sample6.dat の <strong>見た目</strong> は4x3の行列のように見えるのに対して，Fortranでは3x4の2次元配列を宣言して読み込んでいることに気をつけよう．このプログラムを実行すると， <code class="docutils literal notranslate"><span class="pre">x(1,1),</span> <span class="pre">x(2,1),</span> <span class="pre">x(3,1),</span> <span class="pre">x(1,2),</span> <span class="pre">...</span></code> にそれぞれ <code class="docutils literal notranslate"><span class="pre">1.0,</span> <span class="pre">2.0,</span> <span class="pre">3.0,</span> <span class="pre">4.0,</span> <span class="pre">...</span></code> が代入されることになる．これは入力が先頭から順々に行われることと，Fortranの多次元配列のメモリ並びがこの順番になっているためである(メモリ並びについては <a class="reference internal" href="#columnrow"><span class="std std-ref">Column majorとRow major</span></a> 参照)．</p>
<p>配列の形状が何であってもかならずこの順番で読み込まれるため，例えば</p>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">real</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="kd">::</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>

<span class="k">read</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="n">x</span>
</pre></div>
</td></tr></table></div>
<p>であれば，<code class="docutils literal notranslate"><span class="pre">x(1,1),</span> <span class="pre">x(2,1),</span> <span class="pre">x(1,2),</span> <span class="pre">x(2,2),</span> <span class="pre">...</span></code> の順で <code class="docutils literal notranslate"><span class="pre">1.0,</span> <span class="pre">2.0,</span> <span class="pre">3.0,</span> <span class="pre">4.0,</span> <span class="pre">...</span></code> が代入されてしまう．このように多次元配列の読み込みは(初心者にとっては)必ずしも意図する結果にならないことがあるので注意して欲しい．配列はあくまで規則的にデータを並べただけのものであり，数学的な行列の概念とは必ずしも一致しないのである．</p>
<p>なお，ここでも <code class="docutils literal notranslate"><span class="pre">read</span></code> 一文でデータを全て読み込まなければならないことに再度注意しよう．以下のような2重ループ</p>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">integer</span> <span class="kd">::</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span>
<span class="kt">real</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="kd">::</span> <span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>

<span class="c">! 注意: これは動かない !</span>
<span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span>
  <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span>
    <span class="k">read</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
  <span class="k">end do</span>
<span class="k">end do</span>
</pre></div>
</td></tr></table></div>
<p>では正しく読み込むことが出来ない．</p>
</div>
</div>
<div class="section" id="id14">
<h2><a class="toc-backref" href="#id65"><span class="section-number">5.6. </span>配列に関する組込み関数</a><a class="headerlink" href="#id14" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Fortranにはいくつか配列に関する便利な組込み関数が用意されている．細かい使い方についてはサンプルコードや自分で実際にコードを書いてみて動作確認をしてみるのが一番の近道である．</p>
<p>例えば以下の例では行列とベクトルの積を計算する <code class="docutils literal notranslate"><span class="pre">matmul</span></code> ，およびベクトル同士の内積を計算する <code class="docutils literal notranslate"><span class="pre">dot_product</span></code> の使い方を示している．（ここでは <code class="docutils literal notranslate"><span class="pre">a</span></code> は2次元配列， <code class="docutils literal notranslate"><span class="pre">b</span></code> および <code class="docutils literal notranslate"><span class="pre">x</span></code> は1次元配列である．）</p>
<div class="literal-block-wrapper docutils container" id="id52">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample7_f90.html"><span class="doc">sample7.f90</span></a> 抜粋</span><a class="headerlink" href="#id52" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c">! 行列aとベクトルxの積をbに代入: b_{i} = a_{i,j} * x_{j}</span>
  <span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span>
    <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span>
      <span class="n">b</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">b</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="k">end do</span>
<span class="k">  end do</span>

<span class="k">  write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="s1">&#39;b = &#39;</span><span class="p">,</span> <span class="n">b</span>

  <span class="c">! 組み込み関数を使用して同じ計算を行う</span>
  <span class="n">b</span> <span class="o">=</span> <span class="nb">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

  <span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="s1">&#39;b = &#39;</span><span class="p">,</span> <span class="n">b</span>

  <span class="c">! ベクトル同士の内積を計算</span>
  <span class="n">inner</span> <span class="o">=</span> <span class="mf">0.0_8</span>
  <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span>
    <span class="n">inner</span> <span class="o">=</span> <span class="n">inner</span> <span class="o">+</span> <span class="n">b</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="k">end do</span>

<span class="k">  write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="s1">&#39;inner product 1 = &#39;</span><span class="p">,</span> <span class="n">inner</span>

  <span class="c">! 組み込み関数を使用して同じ計算を行う</span>
  <span class="n">inner</span> <span class="o">=</span> <span class="nb">dot_product</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

  <span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="s1">&#39;inner product 2 = &#39;</span><span class="p">,</span> <span class="n">inner</span>
</pre></div>
</td></tr></table></div>
</div>
<p>この例では29-33行目と38行目はどちらも行列とベクトルの積を求めるものである．同様に43-46行目と51行目も全く同じ処理(内積計算)を行なっている．組込み関数を用いることで非常に簡単に処理が記述できることが分かるだろう．数学関数に加えてよく使われる組み込み関数をいくつか以下の表に挙げておこう．念のために言うとこれらは必ずしも記憶して置かなければいけないものでは無く，必要になった時に自分で調べて使いこなすことが出来ればそれで良い．(例えば富田・齋藤(2011，6章)が配列に関する組み込み関数について詳しい．)</p>
<table class="colwidths-given docutils align-default" id="id53" style="width: 100%">
<caption><span class="caption-text">配列に関する組み込み関数の例</span><a class="headerlink" href="#id53" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>関数名</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">dot_product(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>ベクトル(1次元配列) <code class="docutils literal notranslate"><span class="pre">x</span></code> と <code class="docutils literal notranslate"><span class="pre">y</span></code> の内積を返す</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">matmul(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>行列(2次元配列)同士，もしくは行列とベクトル(1次元配列)の積を返す</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">transpose(x)</span></code></p></td>
<td><p>行列(2次元配列)の転置を返す</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sum(x)</span></code></p></td>
<td><p>配列 <code class="docutils literal notranslate"><span class="pre">x</span></code> の各要素の和を返す</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">product(x)</span></code></p></td>
<td><p>配列 <code class="docutils literal notranslate"><span class="pre">x</span></code> の各要素の積を返す</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">size(x)</span></code></p></td>
<td><p>配列 <code class="docutils literal notranslate"><span class="pre">x</span></code> の全要素数(サイズ)を返す</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">shape(x)</span></code></p></td>
<td><p>配列 <code class="docutils literal notranslate"><span class="pre">x</span></code> の形状を1次元の整数型配列として返す</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">reshape(x,</span> <span class="pre">s)</span></code></p></td>
<td><p>配列 <code class="docutils literal notranslate"><span class="pre">x</span></code> の形状を新しい形状 <code class="docutils literal notranslate"><span class="pre">s</span></code> に変換したものを返す</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">maxval(x)</span></code></p></td>
<td><p>配列 <code class="docutils literal notranslate"><span class="pre">x</span></code> の全要素の最大値を返す</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">minval(x)</span></code></p></td>
<td><p>配列 <code class="docutils literal notranslate"><span class="pre">x</span></code> の全要素の最小値を返す</p></td>
</tr>
</tbody>
</table>
<p>なお <code class="docutils literal notranslate"><span class="pre">reshape</span></code> を使うと多次元の配列定数を初期化することが出来る．以下はその例である．</p>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span> <span class="kd">::</span> <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">((</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="o">/</span><span class="p">),</span> <span class="p">(</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p><code class="docutils literal notranslate"><span class="pre">reshape</span></code> の第1引数は任意の配列であり，この配列の形状を変更したものを返す．第2引数には新しい配列の形状を指定している．ここでは左辺の配列の形状が <code class="docutils literal notranslate"><span class="pre">(2,3)</span></code> であるので <code class="docutils literal notranslate"><span class="pre">reshape</span></code> の第2引数は <code class="docutils literal notranslate"><span class="pre">(/2,</span> <span class="pre">3/)</span></code> と形状を1次元の整数配列として指定している．当然，元々の入力配列のサイズと新しい配列のサイズは同じでなければならない <a class="footnote-reference brackets" href="#id33" id="id15">4</a>．</p>
</div>
<div class="section" id="id16">
<h2><a class="toc-backref" href="#id66"><span class="section-number">5.7. </span>部分配列</a><a class="headerlink" href="#id16" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>これまでは各要素に添字を用いて例えば <code class="docutils literal notranslate"><span class="pre">x(10)</span></code> のような形でアクセスしていた．Fortranではこれに加えて <em>部分配列</em> という便利な機能があり，配列の複数の要素にまとめてアクセスすることが出来る．これには添字の代わりに <code class="docutils literal notranslate"><span class="pre">x(lower:upper:stride)</span></code> のような形式を用いる．<code class="docutils literal notranslate"><span class="pre">lower</span></code>，<code class="docutils literal notranslate"><span class="pre">upper</span></code>，<code class="docutils literal notranslate"><span class="pre">stride</span></code> の意味は <code class="docutils literal notranslate"><span class="pre">do</span></code> 変数の指定方法(<a class="reference internal" href="chap04.html#c4-do"><span class="std std-ref">決まった回数の繰り返し(do)</span></a>)と同じである．従って例えば</p>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">integer</span> <span class="kd">::</span> <span class="n">x</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="o">/</span><span class="p">)</span>

<span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">2</span><span class="p">)</span> <span class="c">! 1, 3, 5, 7, 9が出力される</span>
</pre></div>
</td></tr></table></div>
<p>のように書くことが出来る．<code class="docutils literal notranslate"><span class="pre">lower</span></code>，<code class="docutils literal notranslate"><span class="pre">upper</span></code>，<code class="docutils literal notranslate"><span class="pre">stride</span></code> などは省略することも出来，その場合は <code class="docutils literal notranslate"><span class="pre">lower</span></code> は配列の最初の要素，<code class="docutils literal notranslate"><span class="pre">upper</span></code> は最後の要素，<code class="docutils literal notranslate"><span class="pre">stride</span></code> は1と解釈される．ただし <code class="docutils literal notranslate"><span class="pre">stride</span></code> はともかく <code class="docutils literal notranslate"><span class="pre">lower</span></code>，<code class="docutils literal notranslate"><span class="pre">upper</span></code> は明示的に書いておいた方が分かりやすい．またこれらの指定に変数を使う事もできる．</p>
</div>
<div class="section" id="id17">
<h2><a class="toc-backref" href="#id67"><span class="section-number">5.8. </span>配列演算</a><a class="headerlink" href="#id17" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>さらに，Fortranには非常に強力な <strong>配列演算</strong> という機能が用意されている．例えば</p>
<div class="literal-block-wrapper docutils container" id="id54">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample8_f90.html"><span class="doc">sample8.f90</span></a> 抜粋</span><a class="headerlink" href="#id54" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>11</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="kt">real</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="kd">::</span> <span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<p>のように定義された配列 <code class="docutils literal notranslate"><span class="pre">a</span></code> ， <code class="docutils literal notranslate"><span class="pre">b</span></code> ， <code class="docutils literal notranslate"><span class="pre">c</span></code> に対して，以下のような処理を行なう．</p>
<div class="literal-block-wrapper docutils container" id="id55">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample8_f90.html"><span class="doc">sample8.f90</span></a> 抜粋</span><a class="headerlink" href="#id55" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="c">! 代入</span>
  <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span>
     <span class="n">b</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="k">end do</span>

  <span class="c">! 配列演算による代入(上のdoループと同じ)</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">a</span>

  <span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="s1">&#39;b = &#39;</span><span class="p">,</span> <span class="n">b</span>

  <span class="c">! 演算</span>
  <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span>
     <span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.5_8</span><span class="o">*</span><span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="nb">cos</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
  <span class="k">end do</span>

  <span class="c">! 配列演算(上のdoループと同じ)</span>
  <span class="n">c</span> <span class="o">=</span> <span class="mf">0.5_8</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="nb">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

  <span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span> <span class="s1">&#39;c = &#39;</span><span class="p">,</span> <span class="n">c</span>
</pre></div>
</td></tr></table></div>
</div>
<p>ここで，上の例の27-29行目と32行目，37-39行目と42行目はそれぞれ等価である．このようにFortranでは <strong>配列同士の演算をあたかも通常の変数であるかのように記述することができる</strong> ．これを配列演算と呼ぶ．数学で用いるような直感的な表現が出来ることに加えて，これを用いることでかなりタイプ量を減らすことができるのが一目見て分かるだろう．タイプ量が少ないと当然無用なバグの混入を避けることができる．さらに，配列演算はコンパイラによる最適化の恩恵を受けやすいという利点がある．</p>
<p>部分配列と配列演算を組み合わせることも当然可能である．例えば</p>
<div class="literal-block-wrapper docutils container" id="id56">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample8_f90.html"><span class="doc">sample8.f90</span></a> 抜粋</span><a class="headerlink" href="#id56" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>10</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="kt">real</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="kd">::</span> <span class="n">x</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<p>のように定義された配列 <code class="docutils literal notranslate"><span class="pre">x</span></code> ， <code class="docutils literal notranslate"><span class="pre">y</span></code> に対して</p>
<div class="literal-block-wrapper docutils container" id="id57">
<div class="code-block-caption"><span class="caption-text"><a class="reference internal" href="chap05_sample8_f90.html"><span class="doc">sample8.f90</span></a> 抜粋</span><a class="headerlink" href="#id57" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>49</pre></div></td><td class="code"><div class="highlight"><pre><span></span>  <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="p">:</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</td></tr></table></div>
</div>
<p>のような記述ができる．部分配列や配列演算の機能は多次元配列に対しても同様に使用することができるが，配列演算は <strong>同じ形状(次元およびサイズ)の配列に対してしか行うことが出来ない</strong> ことに注意しよう．それ以外の場合には演算が定義されないのでこれは当たり前の話である．</p>
<p>また，数学におけるベクトルの内積やベクトルと行列の積の計算規則とは異なり，配列演算はあくまで各要素ごとの演算であるという点に注意しよう．例えば <code class="docutils literal notranslate"><span class="pre">x(100)</span></code> と <code class="docutils literal notranslate"><span class="pre">y(100)</span></code> のような2つのサイズの等しい1次元配列の積 <code class="docutils literal notranslate"><span class="pre">x*y</span></code> は同じサイズ100の配列となり，スカラー値を計算する内積の計算規則とは異なる．また行列 <code class="docutils literal notranslate"><span class="pre">M(100,100)</span></code> とベクトル <code class="docutils literal notranslate"><span class="pre">x(100)</span></code> の積を計算しようとして <code class="docutils literal notranslate"><span class="pre">M*x</span></code> と記述しても <code class="docutils literal notranslate"><span class="pre">M</span></code> と <code class="docutils literal notranslate"><span class="pre">x</span></code> は形状が異るのでエラーとなってしまう．このような場合は先に見た <code class="docutils literal notranslate"><span class="pre">dot_product</span></code> や <code class="docutils literal notranslate"><span class="pre">matmul</span></code> を使えば良い．</p>
</div>
<div class="section" id="id18">
<h2><a class="toc-backref" href="#id68"><span class="section-number">5.9. </span>補足 <sup>†</sup></a><a class="headerlink" href="#id18" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id19">
<h3><span class="section-number">5.9.1. </span>メモリ領域<a class="headerlink" href="#id19" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Fortranの通常の静的配列(static array)の場合はメモリはスタック(stack)と呼ばれる領域に保持される．環境によっては(おそらく多くのLinux環境のデフォルトでは)スタックに大きなメモリ領域を保持できないようになっている．この設定は例えばsh系のシェル(bashなど)では以下のように <code class="docutils literal notranslate"><span class="pre">ulimit</span></code> コマンド(csh系のシェルならば <code class="docutils literal notranslate"><span class="pre">limit</span></code>)で確認することが出来る．</p>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ <span class="nb">ulimit</span> -a
core file size          <span class="o">(</span>blocks, -c<span class="o">)</span> <span class="m">0</span>
data seg size           <span class="o">(</span>kbytes, -d<span class="o">)</span> unlimited
file size               <span class="o">(</span>blocks, -f<span class="o">)</span> unlimited
max locked memory       <span class="o">(</span>kbytes, -l<span class="o">)</span> unlimited
max memory size         <span class="o">(</span>kbytes, -m<span class="o">)</span> unlimited
open files                      <span class="o">(</span>-n<span class="o">)</span> <span class="m">256</span>
pipe size            <span class="o">(</span><span class="m">512</span> bytes, -p<span class="o">)</span> <span class="m">1</span>
stack size              <span class="o">(</span>kbytes, -s<span class="o">)</span> <span class="m">8192</span>
cpu <span class="nb">time</span>               <span class="o">(</span>seconds, -t<span class="o">)</span> unlimited
max user processes              <span class="o">(</span>-u<span class="o">)</span> <span class="m">709</span>
virtual memory          <span class="o">(</span>kbytes, -v<span class="o">)</span> unlimited
</pre></div>
</td></tr></table></div>
<p>上の <code class="docutils literal notranslate"><span class="pre">ulimit</span></code> コマンドの出力結果から，この環境ではスタック領域が8MBに制限されているので大きな静的配列を確保することが出来ないことが分かる．プログラムの実行直後に原因不明の <code class="docutils literal notranslate"><span class="pre">Segmentation</span> <span class="pre">fault</span></code> などのエラーで終了してしまう場合はスタック領域が足りずにメモリが確保出来なかったことが原因かもしれない．</p>
<p>どうしても静的配列を使いたい場合には <code class="docutils literal notranslate"><span class="pre">ulimit</span></code> コマンドで使用可能なスタック領域を増やせば良い．もしくは静的配列の使用をやめて <code class="docutils literal notranslate"><span class="pre">allocatable</span></code> 配列を用いるようにすればスタック領域の制限は受けない．これは <code class="docutils literal notranslate"><span class="pre">allocatable</span></code> 属性付きで宣言された配列のメモリは( <code class="docutils literal notranslate"><span class="pre">allocate</span></code> によって)ヒープ(heap)と呼ばれる別の領域にメモリが確保されるためである．なおスタックとかヒープについて必ずしも理解している必要は無いが，原因不明のエラーが発生した時にはこのことをふと思い出して欲しい．</p>
</div>
<div class="section" id="column-majorrow-major">
<span id="columnrow"></span><h3><span class="section-number">5.9.2. </span>Column majorとRow major<a class="headerlink" href="#column-majorrow-major" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>既に説明したように配列は計算機の連続したメモリ上に確保されることが保証されている．これは1次元の場合には分かりやすいが，多次元配列の場合はどうなっているのであろうか？計算機のメモリは1次元的なアドレスからなっているので，実は多次元配列であってもメモリは内部的には1次元的に連続な領域を指している．多次元配列は単にそれらを使いやすく表示したものに過ぎない．一般的にFortranでは例えば2次元配列 <code class="docutils literal notranslate"><span class="pre">x(10,10)</span></code> の場合は <code class="docutils literal notranslate"><span class="pre">x(1,1)</span></code>, <code class="docutils literal notranslate"><span class="pre">x(2,1)</span></code>, ..., <code class="docutils literal notranslate"><span class="pre">x(10,1)</span></code>, <code class="docutils literal notranslate"><span class="pre">x(1,2)</span></code>, <code class="docutils literal notranslate"><span class="pre">x(2,2)</span></code>, ...のような並び，すなわち配列の一番左の添字がメモリの連続した方向となっている．これ をcolumn majorと呼ぶ．これに対してC言語などではrow majorと呼ばれるメモリ並びが採用されており一番右側の添字がメモリの連続する方向となっている(図参照)．従って，C言語で書かれたライブラリをFortranから呼び出す際(もしくはその逆)にはこの違いに注意しなければならない．</p>
<p>またこのことから，効率的なプログラムとするためには多次元配列のループの書き方も注意が必要である．以下の例を考えてみよう．</p>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">integer</span> <span class="kd">::</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span>
<span class="kt">real</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="kd">::</span> <span class="n">a</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">s</span>


<span class="c">! 例1</span>
<span class="n">s</span> <span class="o">=</span> <span class="mf">0.0_8</span>
<span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span>
  <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
  <span class="k">end do</span>
<span class="k">end do</span>

<span class="c">! 例2</span>
<span class="n">s</span> <span class="o">=</span> <span class="mf">0.0_8</span>
<span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span>
  <span class="k">do </span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
  <span class="k">end do</span>
<span class="k">end do</span>
</pre></div>
</td></tr></table></div>
<p>この例では5-11行目(例1)と13-19行目(例2)は全く同じ処理(配列内の全要素の総和計算)を行なっているが，多重 <code class="docutils literal notranslate"><span class="pre">do</span></code> ループの添字の順番が異なることに注目して欲しい．例1では左側の添字 <code class="docutils literal notranslate"><span class="pre">i</span></code> が内側のループで走り，例2では右側の添字 <code class="docutils literal notranslate"><span class="pre">j</span></code> が内側のループで走っている．基本的に計算機というのは単純作業(例えば <code class="docutils literal notranslate"><span class="pre">if</span></code> 分岐などがないループ)を一気に，メモリの連続している方向に順番に処理するのが得意になっている．従って，この例では左側の添字が内側ループで走る例1の方が効率の良いプログラムということになる <a class="footnote-reference brackets" href="#id34" id="id20">5</a>．最初はそれほど気にすることは無いが，単に「動く」だけのプログラムでは無く，「良い」プログラムとなるように細かい点についても気を配れるようになって欲しい．</p>
<div class="figure align-center" id="id58">
<a class="reference internal image-reference" href="_images/storageorder.png"><img alt="_images/storageorder.png" src="_images/storageorder.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text">Column majorとRow major．メモリは左から右に連続的に並んでいる．
(C言語の場合は実際には配列添字は0から始まり，添字も <code class="docutils literal notranslate"><span class="pre">[]</span></code> で指定することに注意．)</span><a class="headerlink" href="#id58" title="この画像へのパーマリンク">¶</a></p>
</div>
</div>
<div class="section" id="id21">
<h3><span class="section-number">5.9.3. </span>配列境界チェック<a class="headerlink" href="#id21" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>配列の添字の範囲をはみ出した場合には何が起こるだろうか? 実はこの時何が起こるかは実行してみるまで分からない．何事も無かったかのように正常終了するように見える場合もあるし，&quot;Segmentation fault&quot;などのエラーが表示されて異常終了することもある．1つだけ言えることはそのようなプログラムは例え正しく動いているように見えたとしてもかなり危険な状態である．なぜならプログラムで自分が「使いたい」と要請したメモリ領域とは異なる領域へアクセスしていることになるので，自分のプログラムで用いているメモリ領域はおろか，OSがプログラムの実行に必要とする情報(コールスタックなどと呼ばれる)をも意図せず書き換えてしまうかもしれない．異常終了しなかったとしても，それはたまたま運が良かっただけなの話である．たった1行ソースコードを書き換えただけでも，プログラム中のメモリ配置が変わることで動作がおかしくなるかもしれない．(1行 <code class="docutils literal notranslate"><span class="pre">write</span></code> 文を入れるかどうかだけの違いで動作が変わるような場合もあるが，そういう時には大抵おかしなメモリ領域にアクセスしているものである．)</p>
<p>そもそも配列の添字範囲をはみ出すのは明らかなバグである．通常は効率を重視するため配列添字の境界チェックは行われないが，gfortranではコンパイル時に <code class="docutils literal notranslate"><span class="pre">-fbounds-check</span></code> というオプションをつけることでこの配列境界チェックを行うことが出来る．(多くのFortranコンパイラが同じようなオプションを有しているので他のコンパイラを用いる時にはチェックしてみて欲しい．) これによってもし境界をはみ出した場合にはその旨エラーが出力されてプログラムが終了する．</p>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">program </span><span class="n">check</span>
  <span class="k">implicit none</span>

<span class="k">  </span><span class="kt">integer</span> <span class="kd">::</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">11</span>
  <span class="kt">integer</span> <span class="kd">::</span> <span class="n">x</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

  <span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="k">stop</span>
<span class="k">end program </span><span class="n">check</span>
</pre></div>
</td></tr></table></div>
<p>例えば上のソースコードをcheck.f90として保存し，コンパイル・実行した結果は以下のようになる．</p>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span> $ gfortran -fbounds-check check.f90
 $ ./a.out
At line <span class="m">7</span> of file check.f90
Fortran runtime error: Index <span class="s1">&#39;11&#39;</span> of dimension <span class="m">1</span> of array <span class="s1">&#39;x&#39;</span> above upper bound of <span class="m">10</span>
</pre></div>
</td></tr></table></div>
<p>配列 <code class="docutils literal notranslate"><span class="pre">x</span></code> の上限(10)を超えた11番目の要素にアクセスしているのでエラーが表示されているのが分かる．ただし，このようなチェックを逐一行うことで，当然実行時のパフォーマンスは犠牲になる．従って，デバッグの段階でこのような配列境界チェックを行い，時間のかかる計算を実行する際にはこのオプションは外しておこう．</p>
</div>
</div>
<div class="section" id="id22">
<h2><a class="toc-backref" href="#id69"><span class="section-number">5.10. </span>第5章 演習課題</a><a class="headerlink" href="#id22" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><p><a class="reference external" href="chap05_kadai.pdf">課題PDFダウンロード</a></p>
</div></blockquote>
<div class="section" id="id23">
<h3><span class="section-number">5.10.1. </span>課題1<a class="headerlink" href="#id23" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>サンプルプログラムをコンパイル・実行して動作を確認せよ．さらに，適宜修正してその実行結果を確認せよ．</p>
</div>
<div class="section" id="id24">
<h3><span class="section-number">5.10.2. </span>課題2<a class="headerlink" href="#id24" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>与えられた月日(例えば4月1日であれば4と1)を標準入力から読み込み，その日が1年のうちで何日目かを表示するプログラムを作成せよ．ただし閏年は無視して考えて良い．以下のような配列を用いるとよいだろう．</p>
<div class="highlight-fortran notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">integer</span><span class="p">,</span> <span class="k">parameter</span> <span class="kd">::</span> <span class="n">days</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="o">=</span> <span class="p">&amp;</span>
     <span class="p">&amp;</span> <span class="p">(</span><span class="o">/</span><span class="mi">31</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="o">/</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>実行結果は例えば以下のようなものになる．</p>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ ./a.out
 Input month and day :
<span class="m">4</span>    <span class="c1"># キーボード入力</span>
<span class="m">1</span>    <span class="c1"># キーボード入力</span>
 day of year :           <span class="m">91</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="id25">
<h3><span class="section-number">5.10.3. </span>課題3<a class="headerlink" href="#id25" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>学生のテストの点数を自動的に処理するプログラムを作成せよ．すなわち，標準入力から学生の人数および人数分のテストの点を順に読み込み，最高点，最低点，平均点，標準偏差をそれぞれ表示するプログラムを作成せよ．ただし標準偏差はデータ数 <span class="math notranslate nohighlight">\(N\)</span> ，各データの値 <span class="math notranslate nohighlight">\(x_i (i=1,\ldots,N)\)</span> ，平均値 <span class="math notranslate nohighlight">\(\bar{x}\)</span> を用いて</p>
<div class="math notranslate nohighlight">
\[\sigma = \sqrt{\frac{1}{N} \sum_{i=1}^{N} (x_i - \bar{x})^2}\]</div>
<p>と定義される．</p>
<p>データファイル <a class="reference external" href="data/score1.dat">score1.dat</a> を手元にコピーして，以下のようにリダイレクトによって作成したプログラムに読み込ませ，結果を確認せよ．実行結果は例えば以下のようなものになる．</p>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ ./a.out &lt; score1.dat
 Best               :           <span class="m">98</span>
 Worst              :            <span class="m">6</span>
 Average            :    <span class="m">46</span>.399999999999999
 Standard deviation :    <span class="m">25</span>.115201240152015
</pre></div>
</td></tr></table></div>
<p>なおデータファイルには，1行目にデータ数 <span class="math notranslate nohighlight">\(N\)</span> ，それ以降に各データ <span class="math notranslate nohighlight">\(x_i\)</span> が記述されているので，まずはデータ数を読み込み配列のメモリを <code class="docutils literal notranslate"><span class="pre">allocate</span></code> した後に各データを読み込めば良い．( <a class="reference internal" href="chap05_sample3_f90.html"><span class="doc">sample3.f90</span></a> を参照せよ．)</p>
</div>
<div class="section" id="id26">
<h3><span class="section-number">5.10.4. </span>課題4<a class="headerlink" href="#id26" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>標準入力から2つのベクトルを読み込み，両者の内積を計算し表示するプログラムを作成せよ． <code class="docutils literal notranslate"><span class="pre">do</span></code> ループを用いて地道に計算した結果と組込み関数 <code class="docutils literal notranslate"><span class="pre">dot_product</span></code> を用いた結果を比較すること．</p>
<p>以下はデータファイル <a class="reference external" href="data/vector.dat">vector.dat</a> を入力とした場合の結果である．</p>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ ./a.out &lt; vector.dat
 Inner product with <span class="k">do</span> loop     :    <span class="m">5</span>.4454054113084460E-017
 Inner product with dot_product :    <span class="m">9</span>.8770817913429454E-017
</pre></div>
</td></tr></table></div>
<p>ただしデータは，ベクトルの長さ <span class="math notranslate nohighlight">\(N\)</span> ，1つ目のベクトルの要素( <span class="math notranslate nohighlight">\(N\)</span> 個)，2つ目のベクトルの各要素( <span class="math notranslate nohighlight">\(N\)</span> 個)，の順に並んでいるものとする．</p>
</div>
<div class="section" id="id27">
<h3><span class="section-number">5.10.5. </span>課題5<a class="headerlink" href="#id27" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>標準入力からベクトルと行列を読み込み，積を計算して表示するプログラムを作成せよ．これについても2重<code class="docutils literal notranslate"><span class="pre">do</span></code> ループを用いて地道に計算した結果と，組込み関数 <code class="docutils literal notranslate"><span class="pre">matmul</span></code> を用いた結果を比較すること．</p>
<p>以下はデータファイル <a class="reference external" href="data/matvec.dat">matvec.dat</a> を入力とした場合の結果である．これと同じ結果が得られることを確認せよ．</p>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ /a.out &lt; matvec.dat
 Matrix-vector product with <span class="k">do</span> loop
 -0.10000000000000001
 -0.89999999999999991
 -0.50000000000000000
  <span class="m">0</span>.50000000000000000
 -1.5000000000000000
  <span class="m">1</span>.5000000000000000
  <span class="m">1</span>.2000000000000000
 -2.3999999999999999
 Matrix-vector product with matmul
 -0.10000000000000001
 -0.89999999999999991
 -0.50000000000000000
  <span class="m">0</span>.50000000000000000
 -1.5000000000000000
  <span class="m">1</span>.5000000000000000
  <span class="m">1</span>.2000000000000002
 -2.3999999999999999
</pre></div>
</td></tr></table></div>
<p>データは，ベクトルの長さ <span class="math notranslate nohighlight">\(N\)</span> ，ベクトルの要素( <span class="math notranslate nohighlight">\(N\)</span> 個)，行列の各要素( <span class="math notranslate nohighlight">\(N^2\)</span> 個)，が順に並んでいるものとする．また行列の要素は <span class="math notranslate nohighlight">\(a_{11}, a_{21}, a_{31} \ldots\)</span> の順に読み込まれることと，ベクトルと行列の積 <span class="math notranslate nohighlight">\(b_{i} = \sum_{j} a_{i,j} x_{j}\)</span> の添字の順番に注意せよ．</p>
<p><code class="docutils literal notranslate"><span class="pre">matvec.dat</span></code> は以下のようなファイルになっているが，行列の部分をFortranで読み込むとあたかも転置行列を読み込んだような形になることに注意せよ．（実際に読み込んで確かめてみよ．）</p>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ cat matvec.dat
 <span class="m">8</span>

   <span class="m">0</span>.1
   <span class="m">1</span>.0
   <span class="m">1</span>.0
   <span class="m">0</span>.5
   <span class="m">0</span>.5
  -1.0
  -1.0
   <span class="m">0</span>.2

  -1.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0
   <span class="m">1</span>.0   -2.0    <span class="m">1</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0
   <span class="m">0</span>.0    <span class="m">1</span>.0   -2.0    <span class="m">1</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0
   <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">1</span>.0   -2.0    <span class="m">1</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0
   <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">1</span>.0   -2.0    <span class="m">1</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0
   <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">1</span>.0   -2.0    <span class="m">1</span>.0    <span class="m">0</span>.0
   <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">1</span>.0   -2.0    <span class="m">1</span>.0
   <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">0</span>.0    <span class="m">2</span>.0   -2.0
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>プログラムの入力は数学的な「ベクトル」や「行列」を読んでいる訳ではなく，単なる数値の羅列を決められた順番で読み込む．それをどのように「ベクトル」や「行列」として解釈するのかはプログラムを書く人間が決めることである．( <a class="reference internal" href="#c5-array-io"><span class="std std-ref">配列の入出力</span></a> を理解するまで熟読せよ．)</p>
</div>
</div>
<div class="section" id="id28">
<h3><span class="section-number">5.10.6. </span>課題6<a class="headerlink" href="#id28" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>標準入力から与えられた整数 <span class="math notranslate nohighlight">\(n ( \ge 2)\)</span> 以下の全ての素数( <span class="math notranslate nohighlight">\(1\)</span> は素数に含めない)を表示するプログラムを作成せよ．以下のエラトステネスのふるいと呼ばれるアルゴリズムを用いるとよい．</p>
<p>各整数 <span class="math notranslate nohighlight">\(i=2,\ldots,n\)</span> について順に</p>
<blockquote>
<div><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(i\)</span> が素数でなければ無視( <span class="math notranslate nohighlight">\(i+1\)</span> の処理へ)</p></li>
<li><p><span class="math notranslate nohighlight">\(i\)</span> が素数であれば <span class="math notranslate nohighlight">\(i\)</span> から <span class="math notranslate nohighlight">\(n\)</span> の整数のうち <span class="math notranslate nohighlight">\(i\)</span> の倍数のものを消去(素数以外と判定)</p></li>
</ul>
</div></blockquote>
<p>の処理を行う．なお各整数が素数かどうかを判定するには長さ <span class="math notranslate nohighlight">\(n\)</span> の論理型配列を用いれば良い．この配列を全て <code class="docutils literal notranslate"><span class="pre">.true.</span></code> に初期化し，素数でないと判定されたものは <code class="docutils literal notranslate"><span class="pre">.false.</span></code> を代入して消去する．</p>
<p>実行結果は例えば以下のようなものになる．</p>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ ./a.out
<span class="m">30</span>                            <span class="c1"># キーボード入力</span>
 prime number :            <span class="m">2</span>
 prime number :            <span class="m">3</span>
 prime number :            <span class="m">5</span>
 prime number :            <span class="m">7</span>
 prime number :           <span class="m">11</span>
 prime number :           <span class="m">13</span>
 prime number :           <span class="m">17</span>
 prime number :           <span class="m">19</span>
 prime number :           <span class="m">23</span>
 prime number :           <span class="m">29</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="id29">
<h3><span class="section-number">5.10.7. </span>課題7<a class="headerlink" href="#id29" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>標準入力から3つの整数 <code class="docutils literal notranslate"><span class="pre">L</span></code>, <code class="docutils literal notranslate"><span class="pre">M</span></code>, <code class="docutils literal notranslate"><span class="pre">N</span></code> を読み込み， 形状が <code class="docutils literal notranslate"><span class="pre">(L,</span> <span class="pre">M,</span> <span class="pre">N)</span></code> の整数型の3次元配列，および長さ <code class="docutils literal notranslate"><span class="pre">L*M*N</span></code> の整数型の1次元配列を作成せよ．その上で，</p>
<blockquote>
<div><ul class="simple">
<li><p>組み込み関数 <code class="docutils literal notranslate"><span class="pre">size</span></code>, <code class="docutils literal notranslate"><span class="pre">shape</span></code>, <code class="docutils literal notranslate"><span class="pre">lbound</span></code>, <code class="docutils literal notranslate"><span class="pre">ubound</span></code> の引数に上記の2つの配列をそれぞれ与えた結果を出力し，その動作を確認せよ．</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reshape</span></code> を用いて1次元配列の中身を3次元配列にコピーできることを確認せよ．（ここで1次元配列に適当な値を代入してからコピーすることで <code class="docutils literal notranslate"><span class="pre">reshape</span></code> の動作を確認することもできる．）</p></li>
</ul>
</div></blockquote>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span>$ ./a.out
 Input three positive integers <span class="o">(</span>L, M, N<span class="o">)</span> :
<span class="m">2</span>, <span class="m">5</span>, <span class="m">7</span>
 --- 3D array ---
 size   <span class="o">(</span>should be equal to L*M*N<span class="o">)</span>               :           <span class="m">70</span>
 shape  <span class="o">(</span>should be equal to 1D array <span class="o">(</span>/L, M, N/<span class="o">)</span> :            <span class="m">2</span>           <span class="m">5</span>           <span class="m">7</span>
 lbound <span class="o">(</span>should be equal to 1D array <span class="o">(</span>/1, <span class="m">1</span>, <span class="m">1</span>/<span class="o">)</span> :            <span class="m">1</span>           <span class="m">1</span>           <span class="m">1</span>
 ubound <span class="o">(</span>should be equal to 1D array <span class="o">(</span>/L, M, N/<span class="o">)</span> :            <span class="m">2</span>           <span class="m">5</span>           <span class="m">7</span>
 --- 1D array ---
 size   <span class="o">(</span>should be equal to L*M*N<span class="o">)</span>               :           <span class="m">70</span>
 shape  <span class="o">(</span>should be equal to 1D array <span class="o">(</span>/L*M*N/<span class="o">)</span>   :           <span class="m">70</span>
 lbound <span class="o">(</span>should be equal to 1D array <span class="o">(</span>/1/<span class="o">)</span>       :            <span class="m">1</span>
 ubound <span class="o">(</span>should be equal to 1D array <span class="o">(</span>/L*M*N/<span class="o">)</span>   :           <span class="m">70</span>
</pre></div>
</td></tr></table></div>
<p>なお， <code class="docutils literal notranslate"><span class="pre">L</span></code>, <code class="docutils literal notranslate"><span class="pre">M</span></code>, <code class="docutils literal notranslate"><span class="pre">N</span></code> の値はそれぞれせいぜい100程度かそれ以下にしておいた方が良い．</p>
<hr class="docutils" />
<dl class="footnote brackets">
<dt class="label" id="id30"><span class="brackets"><a class="fn-backref" href="#id4">1</a></span></dt>
<dd><p>計算機の中でデータの塊を扱う形式のことを一般にデータ構造と呼ぶ．配列は最も単純なデータ構造の一つと考えることが出来る．</p>
</dd>
<dt class="label" id="id31"><span class="brackets"><a class="fn-backref" href="#id7">2</a></span></dt>
<dd><p>プログラムが終了する際には当然全てのメモリが解放されるので必要以上に心配する必要は無い．また，Fortran 95以降では <code class="docutils literal notranslate"><span class="pre">allocatable</span></code> な配列は，スコープから外れた時(後述のサブルーチンなどから出た時)には自動的に <code class="docutils literal notranslate"><span class="pre">deallocate</span></code> されるということになったようである．従って通常はあえて <code class="docutils literal notranslate"><span class="pre">deallocate</span></code> しなくても良いかも知れない．ただし，一般的に借りたものは必ず返すというのがプログラミングでは礼儀になっているので，ちゃんと <code class="docutils literal notranslate"><span class="pre">deallocate</span></code> するように癖をつけておいた方が無難である．例えばC言語では <code class="docutils literal notranslate"><span class="pre">malloc</span></code> などでメモリを割り付けた場合は <code class="docutils literal notranslate"><span class="pre">free</span></code> で明示的に解放しない限りプログラム終了までメモリを保持し続ける．</p>
</dd>
<dt class="label" id="id32"><span class="brackets"><a class="fn-backref" href="#id11">3</a></span></dt>
<dd><p>どうやら <code class="docutils literal notranslate"><span class="pre">read</span></code> は改行までを一区切りとして読み込むようである．これがFortranの標準なのかgfortran独自の仕様なのかは不明である．</p>
</dd>
<dt class="label" id="id33"><span class="brackets"><a class="fn-backref" href="#id15">4</a></span></dt>
<dd><p>このように配列形状を変更できることを不思議に思うかもしれない．しかし，実際には1次元配列も多次元配列も中身は同じ1次元的なメモリ領域を指しており，使う側には便宜上違う次元のもののように見えているだけなのである．詳しくは <a class="reference internal" href="#columnrow"><span class="std std-ref">Column majorとRow major</span></a> を参照のこと．</p>
</dd>
<dt class="label" id="id34"><span class="brackets"><a class="fn-backref" href="#id20">5</a></span></dt>
<dd><p>実際にはプログラムの構造やループ内でのメモリ使用量，CPUやコンパイラの性能に大きく依存する(かしこいコンパイラはループの順序を交換したりすることもある)．またこの程度の小さな配列ではほとんど差が見られないであろう．</p>
</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="chap06.html" title="6. 書式指定・ファイル入出力・文字列処理"
             >次へ</a> |</li>
        <li class="right" >
          <a href="chap04.html" title="4. 制御構造"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Fortran演習</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Takanobu Amano.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.3 で生成しました。
    </div>
  </body>
</html>