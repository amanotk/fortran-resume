% Fortran 演習
% 天野孝伸 (amano@eps.s.u-tokyo.ac.jp)

# はじめに
この演習では8日間という短い期間でFortranによるプログラミングの基礎を学ぶことになる. ここで学ぶ内容は今後の演習に必須のものとなるので, 心して取り組んで頂きたい. とは言っても, プログラミング言語を用いて自分のやりたいことを思うがままに実現できるようになるのはそれほど簡単なことでは無く, 8日間の演習では短か過ぎると思われる. プログラミング言語の文法自体は英語や日本語などの自然言語に比べたら格段に簡単だが, それでもそれを使いこなすのにはある程度の訓練が必要なのである. 特にプログラミング初心者の人がこの演習の内容を全て理解するのは難しいので, 分からない内容があっても落ち込むことは無い. (興味を持ってやっていればそのうちに自然と身に付くものである.) 最低限の目標は, Fortranというプログラミング言語の基礎を覚え, 自分で簡単なプログラムの作成および実行が出来るようになること(=この後の演習の内容についていけるようになること)である. このレジュメで節のタイトルに「^†^」がついている項目がいくつかあるが, この内容は演習の課題をこなすためには必ずしも知らなくて良い内容である. ただし, 知っておくと色々と便利なことが多いので余裕があればこの内容もマスターしておくと良い.

なお演習時には言語仕様を事細かに解説するようなことはしない. そんなことをしていては時間が足りないし, 何より退屈なだけである. また言語仕様の詳細を理解したからと言ってプログラムを書けるようになるわけではなく, 全く実用的では無い. その代わりに, 各事項を理解する助けになるようサンプルプログラムを多数用意してある. 大事なのは自分でサンプルプログラムを修正, 実行し, その動作を自分の目で確認することである. また毎日の課題に取り組むことで, 「習うより慣れよ」の精神で実践的に基礎を身につけて行って欲しい. このレジュメについても教科書的なものでは無く, サンプルプログラムの解説といった位置付けである. なお最初に断っておくと, このレジュメは*未完成*である. 用語が統一されていなかったり, 間違いなどを含んでいる可能性も大いにあるので, その点については注意して欲しい. 内容としてはどちらかと言うと教科書には書いていないようなことを随時盛り込んでいく予定である(あくまで予定である). 最新版は以下のURLでPDFとして(PDF版の方がカラーで見やすい)公開していくので, 必要な場合は各自でダウンロードして欲しい.

<http://www-space.eps.s.u-tokyo.ac.jp/~amano/education/fortran/resume.pdf>

また, この演習では説明しないような内容(細かい文法事項など)については必要であれば以下を適宜参考にすると良い^[基礎的には本演習で扱う事項さえ理解してしまえば, 分からないことは本で探すよりインターネットで探した方が早いので, 自分で必要性を感じなければ教科書などは特に購入する必要は無い. 更に言うと巷には古い(参考にしないほうが良い)Fortranの本があふれているので注意して欲しい. 大抵はどこかの大学の年配の先生が書いた~~古臭い~~年季の入ったテキストを基に教科書としたものであるが, お世辞にも薦められないような本がごく最近にも出版されている. 偏見たっぷりに言うと, サンプルプログラムが全部大文字で記述されているような本はかなりの確率でこの部類に入ると思って良い.]. 高木(2009)は非常に良くまとまっているので, これがあれば困ることは少ないであろう. 紙の本が良いという人は富田・齋藤(2011)がよくまとまっている. 少し古いバージョンがWebで参照でき, 多くの人にはこれで十分である. 牛島(2007)は少し初心者には分かりづらいかもしれないが, モジュールに関する記述が実践的である. 数値計算についても少し触れられているが, 本格的に取り組む場合は専門の文献も併せて参考にした方が良い.

#. 高木征弘 (2009) 『地球物理学演習テキスト Fortran90/95入門』
#. 富田博之, 齋藤泰洋 (2011) 『Fortran90/95プログラミング』 (培風館)
#. 牛島省 (2007) 『数値計算のためのFortran 90/95 プログラミング入門』 (森北出版)

なおサンプルプログラムは

<http://www-space.eps.s.u-tokyo.ac.jp/~amano/education/fortran/sample.tar.gz>

にまとめて置いてある. このレジュメの各章ごとにディレクトリに分類して(例えば3章なら`sample/chap03`)置いてあるので適宜手元にコピーして参照して欲しい.

ちなみに, `.tar.gz`形式のファイルの解凍はUnix系のマシンではコマンドラインで

```{style=shell}
 $ tar -zxvf sample.tar.gz
```

などのように実行すれば良い. (イマドキのLinux環境であればダブルクリックでも解凍出来てしまうと思う.)

レジュメとこれらのサンプルプログラムがあれば自習も十分に可能であるので, 興味のある人はどんどん進めてもらって構わない. 自習用に個人マシンにFortranの開発環境を用意することも出来る. 一番簡単なのはLinuxをインストールすることだが, Windowsでもいくつか方法が考えられる. MacならXcodeとMacPortsなどをインストールすることで使えるようになるだろう. 分からない人は教員やTAに相談してみよう.

## プログラミングを学ぶ意義
いま

$$
x = \cos x
$$

なる非線形方程式の解を知りたいとしよう. 残念ながら解析的には解は得られない. しかし逐次近似など, 繰り返し計算で近似解を求める方法は色々と知られている. だからと言って紙と鉛筆で計算するのは大変なので計算機に任せよう, というのが基本的な考え方である. とは言っても計算機は自分で考えることはできない. どのような処理を行うかを逐一丁寧に教えてやらなければならない. これがプログラミングというものである. 計算機を使って処理の自動化をする際の作法と言ってもよい.

もちろん, 上の方程式の解を求めるだけなら何もプログラミングを学ぶ必要は無い. そのようなことをやってくれるソフトウェアは探せばいくらでも見つかるだろう. ところが汎用のソフトウェアは決められた計算をするには十分であるが, ちょっとでも違うことをやろうと思うと途端に困ってしまう. 誰もやったことのないような最先端の仕事をするには結局のところ必要なものは自分で作らなければいけない. そのためにもここでプログラミングを学んでおくことは非常に重要である(と思う).

さて, 自分のやりたいことを計算機で実現するにはどのような手続を処理させるかをまず整理しなければならない. この手続のことをアルゴリズムと言う. 例えば上の例で言えば, 非線形方程式を数値的に解くための手法のことである. アルゴリズムが決まればそれをプログラミング言語で記述し, 計算機に実行させることができる.  本演習ではFortranというプログラミング言語の使い方を覚えることが主たる目的であるので, アルゴリズムについては詳しく説明しない. しかし, プログラミング言語の文法は世の中に数多ある言語で様々であるが, アルゴリズムは言語が何であろうと変わらないので, 実際にはアルゴリズムの理解の方が重要であることを十分に認識しておいて欲しい.

## プログラミング言語について
これから学ぶのは正確にはFortran 90/95と呼ばれる規格の言語である. 90とか95というのは1990年とか1995年に規格が定められたという意味である.  Fortran 90とFortran 95ではあまり違いが無いのでこのように記述することが多い. 10年ほど前まではFortran 77という規格が幅を効かせていたのだが, 最近ではopen sourceのコンパイラ(後述)が普及したこともあって, 今から勉強するならFortran 90/95が良い選択肢である. (より新しい規格としてFortran 2003も存在し, その主な違いはオブジェクト指向プログラミングのサポートである. これは明らかに本演習の範囲を超えているので扱わないことにする.) ただし太古の昔から脈々と受け継がれてきたプログラムなどは今でも古めかしいFortran 77のままで現役で使われている. そのようなプログラムに出会ってしまった時には諦めてFortran 77も勉強しよう. (実はそういうことは結構あるのだが, いくつかの違いさえ理解してしまえば, それほど難しいことでは無い.) 本演習では単にFortranと言った場合にはFortran 90/95を指している.

ちなみにプログラミング言語というのは星の数ほどあり, よく知られたものだけでも C/C++, C#, Java, Javascript, Perl, Python, Ruby, Lispなどがある. 正直に言えば今更Fortranを学ぶのは時代遅れであると言っても良い. 多くの言語の文法がC言語に近くできているのに対してFortranは仲間外れの部類である. また, C言語を習得した人がFortranを習得するのは比較的容易いが, その逆は必ずしも真ではない. しかし一応フォローしておくとFortranにもメリットはあって, 分野にも依るが時代遅れと言われながらもしぶとく今でも現役で使われ続けている言語であり, この傾向はまだしばらく続くであろう^[例えば, スーパーコンピューターを用いた大規模シミュレーションなどには今でもFortranプログラムが良く使われている.]. また, Fortranは細かいことを考える必要があまり無い比較的簡単な言語でもあるので, 初心者にはとっつきやすいと同時にプログラミングの専門家では無い科学者向きの言語であるとも言える.

ただし基本的な考え方は他の言語でもあまり変わらないので, 興味のある人はぜひ他の言語にも挑戦してもらいたい. おすすめは(少しとっつきにくいところはあるものの)比較的簡単な言語でありながら応用範囲の広いPythonである^[実はPythonを使うとCやFortranの半分以下の行数でやりたいことが実現出来る場合が多く, 最近の計算機能力を考えると大規模計算をするのでなければ実用上はほとんどPythonで事足りてしまう. 実際に世界的に科学や工学の多くの分野でPythonの導入が進んでいる.].  またC言語は教養として知っておくと非常に役に立つ.

\clearpage

# プログラムの作成と実行
まずは計算機が実行するプログラムの作成および実行する方法を学び, Fortranプログラムの基本的な構造について理解しよう.

> サンプルプログラム
>
> - chap02/sample1.f90 : Hello, world
> - chap02/sample2.f90 : Fortranプログラムの基本構造
> - chap02/dot.Xmodmap : CapsLockと左Controlの交換
> - chap02/dot.eamcs.el : emacsの設定

## Hello, world !
プログラミング言語を学ぶ時には "Hello, world !" を表示するプログラムから始めるのが慣例になっている. 以下に示したものがその最初のプログラムである.

```{style=f90}
program sample
  write(*,*) 'Hello, world !'
  stop
end program sample
```

これはソースコードと呼ばれ, 人間が読める形式で記述されるテキストファイルである. 拡張子はFortran 90/95の場合は `.f90` とする^[Fortran 77では`.f`である.]. プログラムを実行するには, これをコンパイラと呼ばれるプログラムを用いて実行形式(計算機が読み込んで実行することができる形式)に変換してやる必要がある. これをコンパイルと言う. この演習ではgfortranというコンパイラを用いることにしよう. (Intel製のifortというコンパイラがLinux環境では個人利用では無償で使うことが出来ていたのだが, Intelの方針転換で最近は使えなくなってしまったようだ.) カレントディレクトリに `sample1.f90` というファイルがあることを確認して, ターミナルで以下のコマンドを実行しよう.

```{style=shell}
$ gfortran sample1.f90
$ ./a.out
Hello, world !
```

1行目でgfortranコマンドによってコンパイルを実行している. コンパイルが成功すると`a.out`という名前の実行形式のファイルが作成される. 2行目で作成された`a.out`を実行し, 結果が3行目に表示されている. このように"Hello, world !"が表示されれば成功である.

ちなみに

```{style=shell}
$ gfortran sample1.f90 -o hello
```

のように`-o`オプションを使って作成される実行形式のファイル名を指定することが出来る. 上の場合は`hello`というファイルが作成されるのでこれを実行すると先ほどと同じ結果が得られるはずである. なおコンパイラに渡すことの出来るオプションは他にも山ほど存在するので, 興味がある人は

```{style=shell}
$ man gfortran
```

で調べて欲しい. まあよく使うようなオプションはせいぜい数個程度であろう. このように, どんなプログラムであっても基本的にはemacsやvi等のエディタでソースコードを編集し, コンパイル, 最後に実行という流れになる^[そうでない場合もあるのだが, とりあえず今は気にしないことにしよう.].

## ソースコードの基本
以下に示すサンプルを例にとってFortranのソースコードの基本的な構造を説明しよう.

```{style=f90}
! これ以降は「コメント」として無視される.
! ソースコードは人間が直感的に理解できないので, 適宜コメントを入れてプログラムの
! 内容を理解しやすくすることを推奨.
! 日本語も入力できるが, 環境によっては文字化けする可能性がある.

program sample ! ここにコメントを書いても良い
  ! 空行は無視される

  ! 標準出力に文字列を表示(シングルクオートもしくはダブルクオートで囲む）
  write(*,*) 'Hello, world 2 !'

  ! 複数の文字列や変数をカンマで区切って並べてもよい
  write(*,*) "This is ", "also ", "OK"

  ! 1文が複数行に渡る場合には `&` を用いる.
  write(*,*) &
       & 'This is a continuation line'

  ! プログラムを終了する. 多くの場合無くても構わないがあったほうが無難.
  stop
end program sample
```

### 使用可能な文字
ソースコードの編集に用いることが出来るのは半角の英数字および下線(アンダースコア)といくつかの四則演算などに使う特殊文字である. (要するに日本語は使えないと思えば良い.) なおFortranは英字の大文字と小文字を区別しない(`fortran`, `Fortran`, `FORTRAN` は全て同一と解釈される)という現代においては大変珍しい言語の一つである. これは歴史的な事情によるものである. 古いFortran 77のソースコードには大文字だけで記述されているものも多く存在するが, 単に読みにくくなるだけなのでそのような意味のないことはやめよう.

### コメント
ソースコードには計算機に実行させる命令だけでなくコメント(注釈)を含めることができる. Fortranでは "!" から行末までがコメントとみなされる. コメントはプログラムの実行とは無関係であり, コンパイル時には単純に無視される. ソースコードはプログラミング言語固有のキーワードなどで記述されているため人間には理解しづらいのに対して, コメントには人間が理解できるように自由に説明を加えることができる. コメントはソースコードの可読性を良くするものなので積極的に活用すべきである^[自分が3日前に書いたコードが何をしているか理解できないというのは日常茶飯事である.]. なおコメントには日本語を用いても問題ないが, それ以外の部分に日本語を使うとコンパイル時にエラーとなる. 特に気づきにくいのがソースコード中に全角スペースが混じってしまってコンパイルが通らないという現象である. エディタにemacsを用いている場合は, 後に見るように設定によってこの問題を回避出来る.

### プログラムの構造
Fortranのソースコードは以下のように `program` と `end program` で囲まれる. 以下のコードの `program_name` は基本的に何でも良く, 分り易い名前を付けるのがよい. ただしFortranの予約語(`program`などのキーワード)は使えない. また後述の組込み関数と同じ名前にしてしまうとその組込み関数は使えなくなってしまうので注意して欲しい. `stop` はプログラムを終了するという意味であり, `end program` の直前では省略しても通常は問題無いのだが, 入れておいた方がお行儀が良いのでそうしておこう.

```{style=f90}
program program_name

  ここに処理を記述する

  stop
end program program_name
```

また

```{style=f90}
  write(*,*) 'This will be printed out to the termnal.'
```

とすると標準出力(ターミナル)に文字列を表示することができる. `write(*,*)` はここではとりあえず文字列を出力するためのオマジナイと思っておいて欲しい. プログラミング言語を学ぶ時にはこの「オマジナイ」というやつが多く出てくるのだが, そのうち意味がわかるようになるので心配しなくて良い. なお `read(*,*)` で標準入力(ターミナルからのキーボード入力)を読み込むことが出来るが, これについては変数を学んでから説明しよう. なお先ほどのサンプルの13行目の様に複数の文字列や後で説明する変数をカンマで区切って並べても良い. これを入出力リストと呼ぶ.

### 継続行
Fortranでは1行が132文字以下でなければいけないという制限が課せられている. 1行に収まらない長い文を記述するには行の最後に `&` を記述することで, 次の行へと継続することが出来る. 実際には80文字とか100文字とか(要するにエディタの表示範囲で)改行する方がプログラムが読みやすくなる. サンプルの16-17行目のような形で記述すればよい. 17行目の `&` は必ずしも必要では無いが, あった方が読みやすいので入れておくことを推奨する. なおemacsでは改行したい位置で `C-c RET` と打つと `&` を自動で挿入して字下げまでしてくれる^[このようにキーバインドを表す際には `C` がControl, `M` がMetaキーを表す. 例えば `C-x` はControlキーを押しながら `x` キーを押すことを, `M-x` はEscapeキーを押して*離してから* `x` キーを押すことを意味する.].

## ソースコード編集にまつわるエトセトラ^†^
ソースコードの編集に用いるソフトウェアはテキスト形式のファイルが編集できるものであればどんなものであっても構わない. しかし世の中には専用に開発された便利なものがあるので利用しない手は無い. この演習ではemacsの使用を推奨することにする. Visual Studio や Eclipse などを使ったことのある人にはビックリするほど簡易な環境ではあるが, リモートマシンでソースコードの編集をする機会が多い人間にはその方が良いのである. ちなみに emacs はそのようないわゆる統合開発環境に負けないくらいの機能も有している. ただ単に使いこなすのが難しいだけなので, 興味のある人は自分でどんどん調べてカスタマイズしていくと良い.

以下ではemacsで(Fortranに限らず)ソースコードを編集する際に知っておいた方が良いことや, 便利な設定などをほんの一部だけ紹介する. 知らなくても効率が悪くなるだけで何かが出来なくなるわけではないので興味のない人は無視してもらって構わない.

### `Control` と `CapsLock` の交換
まずemacsでは `Control` をかなり多様するので `A` のキーの左の `CapsLock` を `Control` と交換して使用する人がほとんどである(多分). Linuxでこれを実現するための古典的な方法は `xmodmap` というコマンドを用いるものである. ホームディレクトリに `.Xmodmap` というファイルを作り, 以下の様な内容で保存する.

```
remove Lock = Caps_Lock
remove Control = Control_L
keycode 37 = Caps_Lock
keycode 66 = Control_L
add Lock = Caps_Lock
add Control = Control_L
```

そして

```{style=shell}
$ xmodmap ~/.Xmodmap
```

というコマンドを実行すると `CapsLock` と 左の `Control` キーが交換されたハズだ. ログイン時に自動でこのコマンドを実行するように設定しておくと良い.

ただし最近では `xmodmap` によるカスタマイズは使えない環境もあるようだ. この時は単に `CapsLock` と `Control` を交換するだけであれば

```{style=shell}
$ setxkbmap -option ctrl:swapcaps
```

とするのが手っ取り早い.

いずれにせよログイン時に自動でこれらのコマンドを実行して欲しいわけだが, これには `~/.xsession` や `~/.xinitrc` などのファイルに上記のコマンドを書き込むことで実現出来ることが多い. ただし自動実行の設定は環境依存の話であるので自分の環境に合わせて適宜やり方を調べて欲しい. またこのようなキーボードのカスタマイズの仕方は他にも複数の方法があるようなので必要な人は自分で調べてみよう.

なお, 同様にviユーザーは `Escape` を多用するのでスペースキーの左もしくは右のキー(普通の日本語キーボードでは「無変換」とか「変換」)を `Escape` として使う人が多いようである.

### 基本的な編集作業
まずマウスを使わずに作業できるようになることを目標にしよう. なぜなら将来リモートマシンにログインして作業する際にはマウスを使うことは出来ないからだ^[出来ないことも無いのだが, やっぱり何をするのにも遅くてイライラするので.].

既にこれまでの演習で学んだことだとは思うがemacsでは(`Control`キーと`CapsLock`を交換しておけば)キーボードのホームポジションから手を動かさずに全ての作業が出来るようになっている. これにはカーソルキーに対応する `C-n` (↓ `next-line`), `C-p` (↑ `previous-line`), `C-f` (→ `forward-char`), `C-b` (← `backward-char`), と `Delete` キーに対応する `C-h` は必須である. また `C-a` (行頭へ移動), `C-e` (行末へ移動) や, `C-k` (カーソルから行末までを削除) もよく使うので覚えておこう. ちなみにemacsとは関係無いが, 多くの環境で Alt-Tabによってウィンドウの切り替えが出来る. またターミナルでのコマンドライン編集時にもemacsと同じキーバインドが使える場合が多いので, これらを覚えておくだけでマウスの使用頻度が激減すること請け合いである.

viユーザーの名誉のために述べておくと, 当然のようにviでも(`Escape`の場所を適切にしておけば)ホームポジションから一切手を動かす必要が無い. 更に言うとviでは片手でコーヒーを飲みながらカーソル移動が出来るので, 少なくともこの点ではviの方が優れている(なので余裕があればviも勉強しよう).

### Tabの利用
ソースコードは適切に字下げされていると格段に見やすくなるし, 明らかな文法間違いに気づくきっかけにもなるので字下げの徹底を強く推奨する. emacsでは Tabキーを押すと自動でカーソルのある行の字下げをしてくれる. 複数行を一気に字下げしたい場合には字下げしたい領域を選択して `M-x indent-region` もしくは `M-C-\` で選択された領域の字下げが出来る. ファイル全体を字下げしたい時には `C-x h M-C-\` とすれば良い.

またFortranは`program`に限らず, 実行ブロックが`end ???`で終わるようになっている. emacsでは`end`まで入力した状態でTabキーを押すと自動で`end`の後に適切なキーワードを挿入してくれる. (例えば`program sample`の場合はTabキーによって`end`の後に`program sample`が挿入される.) これは非常に便利なので是非利用して欲しい.

### コメントアウト
ソースコードを編集していると(特にデバッグ中は)複数行をまとめてコメントアウトしたいことが多々ある. そんな時に各行の先頭にいちいち"!"を挿入するのはバカバカしい. emacsでは領域を選択して `M-x comment-region` とするとまとめてコメントアウトしてくれるようになっている. ちなみにコメントアウトした領域を元に戻す時は `M-x uncomment-region` とすれば良い. なお多くのemacsのデフォルト環境で `.f90` のファイルを開いた場合には(自動でf90-modeというモードになり) `C-;` が `M-x comment-region` に設定されている. 同様に `C-u C-;` が `M-x uncomment-region` である.

### 全角スペースの表示
前述の通りソースコードに全角スペースが含まれているとコンパイルが出来ない(しかもエラーメッセージからはそれが分からない)という厄介な問題が存在する. これは初心者ほど陥りやすい罠であるが, emacsの設定でこの問題を回避することが出来る. 例えば以下の様な設定を `.emacs` などの設定ファイルに書いておくと全角スペースが "□" と表示されるので一目瞭然である.

```
(require 'whitespace)
(setq whitespace-style '(face trailing spaces tabs space-mark tab-mark))
(setq whitespace-space-regexp "\\(\x3000+\\)")
(setq whitespace-display-mappings
      '((space-mark ?\x3000 [?\□])
        (tab-mark   ?\t   [?\xBB ?\t])
        ))
(set-face-attribute 'whitespace-trailing nil
                    :background "navy")
(global-whitespace-mode 1)
```

なお上の設定では行末のスペースやタブなども表示するように設定されているが, このあたりは完全に好みである. 以下はemacsでソースコードを編集中のスクリーンショットである.

![Emacsのスクリーンショット](figure/emacs.png)

### 複数ファイルの編集
真のemacs使いはいちいちemacsを立ち上げたり終了したりはしない. 常にemacsを立ち上げておき, 複数のファイル(emacsではバッファと呼ぶ)を縦横無尽に切り替えながら編集するのである^[emacs上でコンパイルしたり, emacsをターミナル代わりに使う人もいるのだが少しばかりマニアックな話題なので各自で調べて欲しい.]. `C-x f` で新しいファイルを開くことは当然出来るとして, 過去に編集していたバッファに切り替える方法を覚えておこう. `C-x b` でミニバッファに既に開いているバッファ名(ファイル名)を入力するとそのバッファに移ることが出来る. またTabによる補完も使うことが出来る. `C-x C-b` では現在開いているバッファの一覧が表示され, 選択することでそのバッファに移ることが出来る.

なお最近ではemacsにもタブ(タブブラウザのあれである)を導入することが出来るらしい. 興味のある人は `tabbar.el` で調べてみよう.

### まとめ
細かいことはどうでもいいという実践派の人は以下の表を頭に入れておけばよい. 正確には体が勝手に覚えるものなのだが.

\clearpage

Table: これだけは知っとけemacsのキーバインド

キーバインド      説明
---------------   --------------------------------------------------------
`C-p`             ↑
`C-n`             ↓
`C-f`             →
`C-b`             ←
`C-a`             行頭へ移動
`C-e`             行末へ移動
`C-h`             `Delete`
`C-k`             カーソル位置から行末までを削除
`C-@`/`C-space`   領域選択を開始
`C-w`             選択範囲を切り取り
`M-w`             選択範囲をコピー
`C-y`             コピーした内容を貼り付け
`C-;`             選択領域をコメントアウト
`C-u C-;`         選択されたコメントアウトされている領域のコメントを外す
`C-c RET`         継続行の挿入
`M-C-\`           選択された領域の字下げ
`C-x h M-C-\`     ファイルの全てを選択して字下げ
`C-x f`           ファイルを開く
`C-x b`           バッファの切替え
`C-x C-b`         バッファ一覧の表示
`C-s`             前方検索
`C-r`             後方検索
`M-%`             置換(置換前にその都度確認をする)


\clearpage

# 変数・データ型・基本的な計算
ここでは計算機でデータを扱うには必須となる変数とデータ型および基本的な計算の仕方について学ぼう.

> サンプルプログラム
>
> - chap03/sample1.f90 : 変数の基本
> - chap03/sample2.f90 : データ型と精度および定数
> - chap03/sample3.f90 : `read`の使い方
> - chap03/sample4.f90 : 基本的な算術演算および代入
> - chap03/sample5.f90 : 組込み関数
> - chap03/sample6.f90 : 型変換

## 変数
プログラム中で何らかの値を保持するためには変数を用いる必要がある. 例えば一度には出来ないような複雑な計算の途中結果などは変数に格納することになる. 要するにデータの入れ物である. 変数を用いるにあたって,

- 変数は宣言しなければならないこと
- 変数には型があること

という2点に注意しなければならない. 変数の宣言は

```{style=f90}
  データ型 :: 変数名
```

のような形で行う. (ここで"`::`"は必須ではないが, 宣言と同時に初期化をしたり, 後で出てくる変数の属性を指定する時には必要となる. 従ってこの演習では変数宣言時には常に"`::`"を用いることにする.)

例えば以下のコードは `n` と `x` という2つの変数を宣言し,  `n` には `10` を `x` には `0.1` を代入している.  `=` は数学で用いる記号とは異なり, `=` の左側の変数に右側の値を代入する(データを格納する)という意味である.

```{style=f90}
  integer :: n ! 整数型の変数の宣言
  real :: x    ! 実数型の変数の宣言

  n = 10  ! 代入
  x = 0.1 ! 代入
```

上の例では`n`は整数(`integer`)を, `x`は実数(`real`)を表す変数であるが, これはそれぞれ1行目や2行目のように変数を宣言をした時点で確定する. 面倒なように思われるかもしれないが, *変数は使う前に用途に合わせて* 宣言しなければならない. これはすぐ後に述べるように計算機が表現できる値に限界があり, また人間のように臨機応変に状況に対処できないからである.

なおFortranには暗黙の型宣言という悪しき慣習があり, 宣言されていない変数でも変数の名前に応じて自動的に型を仮定して宣言されたものとみなす. 詳細は省くがこれは明らかにバグの元であり, この機能は使わないことを強く推奨する. `program`文の直後に

```{style=f90}
  implicit none
```

と書くことでこの暗黙の型宣言を禁止することができ, 全ての変数を明示的に宣言しなければコンパイルエラーとなる. 以降, 本演習では必ず `implicit none` を使うこととする^[巷で流行りのスクリプト言語では変数宣言は要らないじゃないかという人もいるかもしれないが, それは動的型付き言語だからそれでも良いのである. CやFortranのような静的型付き言語ではその限りではない.]. なおgfortranでは`-fimplicit-none`というオプションを用いると, デフォルトで`implicit none`を指定した状態にすることが出来る.


## データ型と精度
標準のFortranで用いることができるデータ型として以下のようなものがある.

型名        キーワード   用途
---------   ----------   --------------------------------------------
整数型      `integer`    整数(厳密な表現)
実数型      `real`       実数(近似的な表現)
複素数型    `complex`    複素数(実部と虚部を表す2つの実数型の組み合わせ)
文字型      `character`  文字を表す
論理型      `logical`    真偽値(`.true.` または `.false.`)

Table: 使用可能なデータ型

注意しなければならないのは, 特に実数型の `real` (従って当然 `complex` も)はあくまで実数の近似表現であるという点である. 例えば `1.0` を代入したとしても, これが厳密に1を表しているわけではない. これは10進数を2進数で無理やり表そうとするために起きる問題であり, 回避する手段は無い. そうは言っても多くの場合において十分な精度で実数を近似できているので問題が無いのである. これとは対照に, 整数型 `integer` は厳密に整数を表現することが出来る.

しかしながら整数型にしても実数型にしても, どんな値でも表現できるというわけではない. 具体的には各データ型に何バイト^[通常1バイトは8ビット, すなわち1バイトあたり2^8^ = 256通りの表現が可能である.]の領域を持たせるかによって表現できる値の範囲が変わる. Fortranでは確保する領域の大きさを変数の宣言時に明示的に指定することが出来る. すなわち

```{style=f90}
  integer(kind=4)    :: n  ! 4バイトの整数
  real(kind=8)       :: x  ! 8バイトの実数
  complex(kind=8)    :: z  ! 16バイトの複素数(8バイトの実数 x 2)
```

のように型名の後に `()` でデータ領域の大きさを指定できる. これを`kind`パラメータと呼ぶ. なお, `real(8)` のように`kind=`は省略して構わない. (`kind`パラメータを用いると移植性の高いプログラムを作成することが出来るが, これは本演習の守備範囲を超えるので以降では`kind=`は省略することとする.) ちなみに特に何も指定しない場合は `integer` が4バイト, `real` が4バイトとなっていることが多いが, これは処理系依存である. 処理系依存などの細かいことはとりあえず忘れると, 結果的に表すことのできる値の範囲は以下のようになっていると思えばよい. (実数の値の範囲については[実数の精度と誤差]でもう少し細かく説明する.)

型名              最小値           最大値          備考
---------------   ---------------  --------------  ---------------------------------
`integer(2)`      $-2^{15}$        $2^{15}-1$
`integer(4)`      $-2^{31}$        $2^{31}-1$
`integer(8)`      $-2^{63}$        $2^{63}-1$
`real(4)`         約$10^{-38}$     約$10^{+38}$    最大・最小は絶対値, 精度は約7桁
`real(8)`         約$10^{-308}$    約$10^{+308}$   最大・最小は絶対値, 精度は約16桁

Table: 各データ型の表現できる値の範囲

なお`real(4)`を単精度, `real(8)`を倍精度, `real(16)`を4倍精度と呼ぶのが通例である. 特に実数型については, 単精度の約7桁という精度では心もとないので現在では倍精度を用いるのが一般的である. 本演習では特段の理由がない限り`real(8)`, `complex(8)`を用いる(`complex(8)`では実部と虚部がそれぞれ`real(8)`となる).

なお複素数型`complex`の定数は`(実部, 虚部)`という形で表す. 例えば

```{style=f90}
  complex(8) :: x = (1.0_8, 1.0_8)
```

は倍精度複素数型の変数`x`の値を$1 + i$に初期化している.

また文字型(`character`)では通常`kind=1`なので^[ASCIIコードは1バイトで足りるため.], `kind`パラメータを指定する必要がない. `character`で複数の文字(文字列)を表すには

```{style=f90}
  character(len=256)  :: char   ! 256文字分
```

以下のように`len=`で文字数を指定することになる. (この場合は`len=`を省略することも出来る.)

論理型(`logical`)は真偽値を表すために用いるので, 通常は`kind`パラメータは指定する必要は無い.


## 定数
数値などを直接ソースコードに記述するとそれは定数(定数リテラル)と呼ばれる. 例えば `99` や `1.5` などのような表現である. 定数に `_4` や `_8` などを付けることによって`kind`パラメータを指定することも出来る. 先ほどの例では `99_4`, `1.5_8` などのように書くことが出来る. 論理型の定数は `.true.` もしくは `.false.` のどちらかである. 文字型の定数は既に最初のサンプルで見たように`'`(シングルクォート)もしくは`"`(ダブルクォート)で囲まれた文字列, 例えば `'earth'` や `"physics"` などである.

また`parameter`属性を用いて定数の変数を使用することも可能である. これを名前付き定数と呼ぶ.

```{style=f90}
  integer(4), parameter :: n  = 100_4
  real(8), parameter    :: pi = 3.141592653589_8
  integer(4) :: m
  real(8)    :: f, g

  m = 2048_4    ! 4バイトの整数2048を代入
  f = 3.1415_8  ! 8バイトの実数3.1415を代入
  g = 3.0e+10_8 ! 3 x 10^10
```

上記の例では`n`を4バイトの整数, `pi`は8バイトの実数として, それぞれ値を指定している. これらの変数は`parameter`が指定されているため定数として扱われ, プログラム中で誤って `pi = 1.0_8` などとして値を変更しようとするとコンパイルエラーとなる. プログラム中で絶対に変更されない値を扱う場合にはこのように名前付き定数として宣言しておくと値が変更される心配が無いので安心である. (信じられないかもしれないが, プログラムの規模が大きくなってくると, このようなミスによるバグに悩まされることがしばしば起こる.)

また実数で例えば$3 \times 10^{10}$を表現するには上の例の8行目のように`3.0e+10_8`のように書けば良い. ちなみにFortran 77の慣習では倍精度での定数値を表現するのに`e`の代わりに`d`を使っていたので, これを`3.0d+10`と書くと倍精度, すなわち`3.0e+10_8`と同じ意味となる. このように実数の定数に`e`や`d`を用いる表現は今でもかなり頻繁に見られるので知っておくと良い.

## 標準入力から変数への値の代入
以下のように変数 `x` を宣言しておいて `read(*,*)` を用いると, プログラムの実行時にキーボードからの入力された内容を読み込み, 変数(この場合は`x`)に代入することが出来る.

```{style=f90}
  integer :: x

  read(*,*) x
  write(*,*) 'You typed : ', x
```

この例では入力された値が `3` なら "You typed : 3" などと表示される. `read(*,*)` の意味は後述するのでここでは再びオマジナイであると思っておこう.

## 算術演算
Fortranでは最も基本的な演算である四則演算およびべき乗を以下のように計算することが出来る. 当然変数同士での演算も可能である.

```{style=f90}
  write(*,*) 12 + 4  ! 和 => 16
  write(*,*) 12 - 4  ! 差 => 8
  write(*,*) 12 * 4  ! 積 => 48
  write(*,*) 12 / 4  ! 商 => 3
  write(*,*) 2**3    ! べき乗 => 8
```

演算実行の優先順位は *べき乗 > 乗算 = 除算 > 加算, 減算* の順となっているが, 可読性のために, 分かりづらい場合には括弧 `()` で明示的に演算の順番が分かるようにしておくと良い.

## 代入
既に学んだように `=` 演算子を用いて左辺で指定する変数に値を代入することが出来る. この時, 右辺には任意の演算を含んでも良い. 例えば

```{style=f90}
  real(8) :: x, y, z

  read(*,*) x, y
  z = 0.5_8 * (x + y)
```

は`x`と`y`を標準入力から読み込み, その平均値を`z`に代入する. なお, `read(*,*)`の場合も, `write(*,*)`と同様に複数の変数を並べて指定することができる.

## 組込み関数
Fortranには標準で使える関数が多く用意されており, 組込み関数と呼ばれる. 関数というと数学の関数を思い浮かべるかもしれないが, 必ずしも数学関数ばかりではない. 関数というのは単に入力値を受け取り何らかの値を返す機能(function)のことである. 例えば数学では $f(x) = \sin(x)$ と書いた時には $x$ という入力に対して $\sin(x)$ という値を返すことを意味する. Fortranでも以下のように入力値`x`対して`sin(x)`とすることで関数値を計算することが出来る. なお関数に渡すパラメータ(ここでは`x`)のことを*引数*と呼び, 関数が返す値のことを*返値*と呼ぶ.

```{style=f90}
  real(8) :: x, y

  read(*,*) x ! キーボードから実数を読み込む
  y = sin(x)
```

この他にも`cos(x)`, `tan(x)`, `sqrt(x)`, `exp(x)`, `log(x)` など様々な関数が用意されているので, 必要に応じて調べて欲しい^[例えば 高木(2009, 3章).]. なお, 自分で独自の関数を定義して用いる方法は後に学ぶことになる.

## 型変換
異なる型同士の演算を行う場合や, 代入する際に左辺と右辺で型が異なる場合には*より一般的な型へと変換された後に演算や代入が実行される*. この機能は便利なようで時に注意が必要な場合がある.

例えば以下の例を考えよう.

```{style=f90}
  real(8)    :: x

  x = 2 / 3
```

`x = 0.666...` となるかと思いきや, 実際には`x = 0`となってしまう. これは左辺が整数同士の演算として行われるため(`2 / 3`は`0`)である. これを回避するには例えば `x = 2.0_8 / 3` や `x = 2 / 3.0_8` とすれば良い. どちらかが実数であればもう一方も実数に変換されてから計算されるので, 演算結果も実数となる. ただし `x = 2.0 / 3` のようにしてしまうと`x`は倍精度(`real(8)`)で宣言されているにも関わらず `2.0` は単精度の実数(`real(4)`)と解釈され, 右辺の計算結果も単精度実数となる. これが左辺の`x`に代入される時に倍精度(`real(8)`)に変換されるため, 結果的には精度が失われることになってしまう.

以下の組込み関数を用いて明示的に型変換を行うことも出来る. 例えば, `real(1, kind=8)`によって整数`1`が倍精度実数の`1.0_8`に変換される. ここでも2番目の引数を指定し忘れると精度が失われるので注意が必要である. ただし `kind=` は省略可能であり, `real(1, 8)` とするだけでも良い.

関数名                 説明
--------------------   ------------------------------------------------------------
`int(x)`               `integer`へ変換(切捨て)
`int(x, kind=k)`       `integer(k)`へ変換(切捨て)
`real(x)`              `real`へ変換
`real(x, kind=k)`      `real(k)`へ変換
`cmplx(x)`             `complex`へ変換(実部が`x`, 虚部は`0`)
`cmplx(x, y)`          `complex`へ変換(実部が`x`, 虚部は`y`)
`cmplx(x, y, kind=k)`  `complex(k)`へ変換(実部が`x`, 虚部は`y`)


\clearpage

# 制御構造
ここではプログラムの動作を制御するための文法について学ぼう. と言っても覚えなければいけないことは`if` による条件分岐, `do`による繰り返し, `select`による条件分岐のみである. `goto` という構文も存在するのだが, これはバグのもとになることから一般的には使わないほうが良いとされており, 従ってここでも敢えて扱わない.

> サンプルプログラム
>
> - chap04/sample1.f90 : 条件分岐(if)
> - cahp04/sample2.f90 : 反復処理(doループ1)
> - chap04/sample3.f90 : 反復処理(doループ2)
> - chap04/sample4.f90 : 反復処理(doループ3)
> - chap04/sample5.f90 : 条件分岐(select)

## 条件分岐(if)
`if`による条件分岐は例えばユーザーの入力によって動作を変更する場合などに用いる. 典型的な使い方は以下のようなものである.

```{style=f90}
  integer :: n

  read(*,*) n  ! 整数値を標準入力から読み込む

  if ( n == 0 ) then
    write(*,*) n, 'is zero'
  else if ( n > 0 ) then
    write(*,*) n, 'is positive'
  else if ( n < 0 ) then
    write(*,*) n, 'is negative'
  end if
```

このように `if` に続く `()` の中に条件式を記述し, その条件が真(`.true.`)の時には`then`に続く処理が実行され, 偽(`.false.`)の時には`else if`以下で更に条件判定をすることになる. また

```{style=f90}
  if( 条件式 ) then
    処理
  end if
```

や

```{style=f90}
  if( 条件式 ) then
    処理1
  else
    処理2
  end if
```

の用に書くことも出来る. 構文自体はそれほど難しくないので, ここで注意すべきは条件判定の部分だけであろう. 以下の表に条件式に用いられることの多い演算子をまとめてある. なおFortran 77では `>` のような演算子(関係演算子と呼ばれる)は正式にはサポートされていなかった. このため古いコードには `.gt.` のような演算子を見かけることもあるかも知れないが, 自分で新しくプログラムを作成する際にはこのような古い形式は使うべきではない. 新しい形式は `/=` 以外のものについてはC言語を始めとする他の多くの言語と同じなのでこちらを用いることを強く推奨する. ちなみにC言語などでは `/=` ではなく `!=` が用いられる.

特に実数の値が等しいかどうかを判定する際には注意が必要である. すなわち, 実数に対しては`==`を使うことは出来ない. なぜなら2つの実数がほぼ等しいように見えても`==`による判定では全てのビットが厳密に等しくなければ真とは判定されないからである. 従って, 代わりに例えば差の絶対値 `abs(A-B)` が十分小さいかどうかで判定しなくてはならない^[`abs(x)`は`x`の絶対値を返す組込み関数である.].

演算子      Fortran 77形式   意味
---------   --------------   ------------------------------------------
`A >  B`    `A .gt. B`       `A`の方が`B`よりも大きければ真
`A >= B`    `A .ge. B`       `A`が`B`以上であれば真
`A <  B`    `A .lt. B`       `A`の方が`B`よりも小さければ真
`A <= B`    `A .le. B`       `A`が`B`以下であれば真
`A == B`    `A .eq. B`       `A`と`B`が厳密に等しければ真
`A /= B`    `A .ne. B`       `A`と`B`が等しくなければ真

Table: 条件演算子

また条件判定が複雑な時には以下の論理演算子を用いることになるだろう.

演算子       意味          使い方
----------   -----------   ---------------------------------------------
`.and.`      論理積        `(条件式1) .and. (条件式2)`
`.or.`       論理和        `(条件式1) .or.  (条件式2)`
`.not.`      否定          `.not. (条件式)`
`.eqv.`      論理等価      `(条件式1) .eqv. (条件式2)`
`.neqv.`     論理非等価    `(条件式1) .neqv. (条件式2)`

Table: 論理演算子

使い方は例えば

```{style=f90}
  integer :: n

  if ( 2 < n .and. n < 5 ) then
    write(*,*) 'n is larger than 2 and smaller than 5'
  end if
```

と言った具合である. `2 < n < 5` のような数学的な書き方はできないので注意が必要である.

さらに複雑な条件分岐の場合には以下のように`if`文を入れ子で使うことも出来る.

```{style=f90}
  if ( 条件1 ) then
    if ( 条件2 ) then
      処理1
    else
      処理2
    end if
  end if
```

ただし何重にも深く入れ子になった`if`文の実行効率はあまり良くないので出来るかぎり浅い条件分岐に留めておいた方が良い.

## 反復処理
### 決まった回数の繰り返し(do)
決まった繰り返しの処理をするために用いるのが `do` (従ってこの反復処理は`do`ループと呼ばれる)である. これも使い方は至ってシンプルである.

```{style=f90}
  integer :: i

  do i = 1, 10, 2
    write(*,*) i
  end do
```

とすれば `1, 3, 5, 7, 9` が出力される. より一般には

```{style=f90}
  do i = lower, upper, stride
    繰り返し処理
  end do
```

のような形で書くことになる. 上の例では整数型変数 `i` は `do`変数と呼ばれ, `do` ループの中で `i` の値が `lower` から `upper` まで `stride` ずつ変化する. `stride` は省略することも可能であり, その場合は `1` と解釈される. また `stride` は負の値であっても良い(当然この時は `lower > upper` でなければループ内の処理は実行されない). 通常`do`変数は整数型でなければならないが, 実数型などでもコンパイル出来てしまう環境もあり, そのような場合は思わぬバグの原因となってしまう. 間違いを未然に防ぐためにも `do`変数には整数型を用いること.

また`if`文の場合と同様に`do`ループに関しても以下のように入れ子(多重ループ)にすることが出来る.

```{style=f90}
  integer :: i, j

  do i = 1, 9
    do j = 1, 9
      write(*,*) i, j, i*j
    end do
  end do
```

### 条件を指定した繰り返し(do while)
繰り返しの処理には基本的に先ほどの`do`ループを用いれば良いのだが, これを少し違った形式で行う`do while`なる構文も用意されている. これは

```{style=f90}
  do while( 条件式 )
    繰り返し処理
  end do
```

のような形で用い, `()`内の条件式が真(`.true.`)の間は繰り返し処理が行われる. 例えば

```{style=f90}
  integer :: i

  i = 1
  do while(i < 10)
    write(*,*) i
    i = i + 2
  end do
```

の例では`1, 3, 5, 7, 9` が出力されることになる. 繰り返し回数が予め分からない処理ではこのような形式を用いるとスマートに書ける場面にもしばしば遭遇する. 例えば反復計算によって実数型の値の収束判定をする場合などは

```{style=f90}
  real(8) :: x

  do while(abs(x) > 1.0e-8_8)
    繰り返し処理
  end do
```

などのように非常にスッキリと記述できる. この例では `abs(x)` の値が$10^{-8}$以下になるまで反復を続ける.

### 複雑な処理(exitとcycle)
単純な繰り返しだけでなく, より柔軟な制御を行うには`exit`や`cycle`を用いる. `exit`では`do`ループの中から途中で抜けることが出来, `cycle`ではループ内のそれ以降の処理を行わずにループ先頭に戻ることがで出来る. これらを用いると意図的に作った無限ループから条件を満たした時だけ抜け出すようなプログラムも簡単に作ることができる. 例えば以下の例を見てみよう.

```{style=f90}
  integer :: i

  do while( .true. )        ! 無限ループ
    read(*,*) i             ! 標準入力から整数値を読み込む

    if ( i == 0 ) then
      exit                  ! 0ならループを抜ける
    else if ( i < 0 ) then
      cycle                 ! 負ならループ先頭(4行目)に戻る
    end if

    write(*,*) i            ! 値を標準出力に表示
  end do
```

この例では標準入力からの整数の入力値が正の時だけその値を表示し, 負の時は表示しない. また0を入力値として受け取るとループを抜けるようになっている. なお, 同じ処理を実現する方法は1つとは限らない. 例えば, 以下のループも全く同じ処理を行っていることが分かるかと思う.


```{style=f90}
  integer :: i

  read(*,*) i

  do while( i /= 0 )
    if ( i > 0 ) then
      write(*,*) i
    end if

    read(*,*) i
  end do
```

このように複数の方法がある場合にはより分かりやすい方(すなわち間違いが発生しにくい方)を採用すれば良い.

## 条件分岐(select)
`select`構文を用いても条件分岐を行うことも出来る. 基本的には `if` を用いれば同じことは実現出来るのだが, 場合によっては`select`を用いた方がよりスッキリとした形で書ける事があるので知っておいて損はない. 典型的には整数や文字列の値で場合分けを制御する際に用いる(実数型には用いることは出来ない). 以下は入力された整数`score`(テストの点だと思おう)の値によって場合分けをする例である.

```{style=f90}
  integer :: score

  read(*,*) score

  select case(score)
  case(0)              ! 0点
     write(*,*) 'zero'
  case(1:29)           ! 1-29点
     write(*,*) 'poor'
  case(30:59)          ! 30-59点
     write(*,*) 'fair'
  case(60:89)          ! 60-89点
     write(*,*) 'good'
  case(90:100)         ! 90-100点
     write(*,*) 'excellent'
  case default         ! それ以外
     write(*,*) 'invalid input'
  end select
```

`case`では単一の値もしくは値の範囲を指定する. 範囲の指定は`case(下限:上限)`のような形ですれば良い. また指定した範囲外の値に対する処理は`case deafault`によって行えば良い.

```{style=f90}
  character(len=128) :: input

  read(*,*) input

  select case(input)
  case('apple', 'orange', 'banana')
     write(*,*) 'food'
  case('earth', 'mars', 'venus')
     write(*,*) 'planet'
  case default
     write(*,*) 'others'
  end select
```

上の例は文字列の値によって分岐する例である. このように1つの`case`で複数の値をカンマで区切って指定することも出来る.


\clearpage

# 配列
大量のデータをまとめて扱うのに便利な配列について, その基本的な使い方や配列に関する組込み関数の使い方などを学ぼう.

> サンプルプログラム
>
> - chap05/sample1.f90 : 配列の基本
> - chap05/sample2.f90 : 動的配列
> - chap05/sample3.f90 : 多次元配列と配列に関する組込み関数1
> - chap05/sample4.f90 : 配列に関する組込み関数2
> - chap05/sample5.f90 : 配列の入出力
> - chap05/sample6.f90 : 部分配列と配列演算

## 基本的な使い方
配列とは*同じ型*の複数のデータを効率的に扱うために用いるデータ構造^[計算機の中でデータの塊を扱う形式のことを一般にデータ構造と呼ぶ. 配列は最も単純なデータ構造の一つと考えることが出来る.]である. 配列も通常の変数と同じように宣言が必要であり, 宣言時には配列であることを明示的に示さなければならない. 配列を宣言すると計算機の*メモリ上の連続した領域*が確保され, それぞれのアドレスに添字を用いてアクセスできるようになる. 具体的には以下のように宣言する.

```{style=f90}
  integer :: i
  integer :: n(10)  ! 整数型の長さ10の配列

  do i = 1, 10
    n(i) = i*i
  end do
```

上の例では4-6行目で配列の各要素に添字`i`を用いて`x(i)`のようにアクセスしており(ここでは各要素へ値の代入), 添字でアクセスした各要素については通常の変数のように扱うことができる. Fortranでは配列の添字は `1` から始まるので, 例えば上の例では`x(1)`が最初の要素であり, `x(10)`が最後の要素ということになる. C言語を始めとする多くの言語では配列の添字は`0`から始まることになっているので注意して欲しい. ただしFortranでは, 以下の2行目のような宣言によって宣言時に配列の添字の範囲を指定することができる. 以下の例はどちらも長さ5の配列を宣言しているが, 配列にアクセスするときの添字の範囲が異なる.

```{style=f90}
  integer :: a(5)   ! 長さ5の配列
  integer :: b(0:4) ! 長さ5の配列(ただし添字は0から4まで)
```

また, 以下に配列`x`の総和を計算する例を示す.

```{style=f90}
  integer :: i
  real(8) :: x(100) ! 実数型の長さ100の配列
  real(8) :: s

  s = 0.0_8
  do i = 1, 100
    s = s + x(i)
  end do
```

このように配列の各要素に対する処理には`do`ループを用いる事になる.

## 配列の定数と初期化
配列の定数は"`(/`"と"`/)`"で各要素を"`,`"で区切って記述することが出来る. 例えば以下の例では長さ3の定数配列を出力する.

```{style=f90}
  write(*,*) (/1, 2, 3/)
```

また配列を宣言する時に初期化することも可能である. 例えば

```{style=f90}
  integer :: c(5) = (/1, 2, 4, 8, 16/) ! 長さ5の配列を宣言時に初期化
```

のようにすればよい. ここで宣言した配列の長さと右辺の要素数は同じになっていなければならない. これを用いると`parameter`属性を付けて配列変数を定数として宣言することが出来る.

```{style=f90}
  integer, parameter :: d(3) = (/-1, 0, 1/) ! 長さ3の定数配列を宣言
```

通常の定数変数と同じように, 定数として宣言された配列は参照は出来るが値の変更は出来ないようになっている.

## 動的割付け(`allocatable`)
通常の配列はコンパイル時に静的に配列のサイズが決定される. 予め必要な領域(メモリ)サイズが分かっていればこれで良いのだが, 実行してみるまで必要な領域サイズが分からない場合にはこれでは対処できない. このような時には`allocatable`属性を用いることで, 実行時に動的に配列用にメモリを割り付けることができる. 具体的な使い方は以下のようになる.

```{style=f90}
  integer :: n
  real(8), allocatable :: x(:) ! 動的配列(allocatable array)を宣言

  ! 標準入力から整数を読み込む
  read(*,*) n

  ! 長さnの配列用にメモリを割り付け
  allocate(x(n))

  何かの処理

  ! メモリの開放
  deallocate(x)
```

`allocatable`属性を付けた配列はコンパイル時には長さが未定なので, 上の例の2行目のように`a(:)`という形式で宣言する. この例では5行目で標準入力から整数を読み込み, それを長さとするように8行目でメモリを割り付けている. `allocate`で確保したメモリは使い終わったらこの例のように`deallocate`で開放してやるのが作法である. いわゆるメモリリークという厄介なバグはこのような動的に割り付けたメモリの解放忘れによって発生するので気をつけよう^[プログラムが終了する際には当然全てのメモリが解放されるので必要以上に心配する必要は無い. また, Fortran 95以降では`allocatable`な配列は, スコープから外れた時(後述のサブルーチンなどから出た時)には自動的に`deallocate`されるということになったようである. 従って通常はあえて`deallocate`しなくても良いかも知れない. ただし, 一般的に借りたものは必ず返すというのがプログラミングでは礼儀になっているので, ちゃんと`deallocate`するように癖をつけておいた方が無難である. 例えばC言語では`malloc`などでメモリを割り付けた場合は`free`で明示的に解放しない限りプログラム終了までメモリを保持し続ける.]. なおメモリが既に割りつけられているかどうかを確認するために`allocated`という関数も用意されている. この関数はメモリが割り付けられている場合には真を返すので, 例えば

```{style=f90}
  ! 既にメモリが割り付けられている場合は何もしない
  if( .not. allocated(x) ) then
    allocate(x(n))
  end if

  何かの処理

  ! 既にメモリが解放されている場合には何もしない
  if( allocated(x) ) then
    deallocate(x)
  end if
```

などのように使うことが出来る.

## 多次元配列
ここまで扱った配列は1次元配列と呼ばれるものであったが, 多次元の配列も使うことができる. 分り易い例として1次元配列はベクトル, 2次元配列は行列と考えればよいだろう. 多次元配列の宣言には次元の分だけ(各次元の)長さを指定すれば良い.

```{style=f90}
  integer :: i, j
  real(8) :: a(10,10)

  do j = 1, 10
    do i = 1, 10
      write(*,*) a(i, j)
    end do
  end do
```

例えば上の例では2次元配列`a(10,10)`を宣言して2重`do`ループでその値を出力している. 多次元配列の場合は配列の各要素にアクセスするために添字を次元の数だけ指定しなければならない. なお配列の次元数をrank, 各次元の要素数の組をshape, 全要素数をsizeなどと呼ぶことが一般的である. これらの言葉の意味は次の表を見てもらえばすぐに理解出来るであろう.

配列宣言       rank           shape           size
------------   -------------  --------------  ---------------
`a(10)`         1              (10,)           10
`b(2, 5)`       2              (2, 5)          10
`c(10,10,10)`   3              (10,10,10)      1000
`d(0:9,0:99)`   2              (10, 100)       1000

Table: 配列の例

多次元配列の場合も`allocatable`属性を指定して動的にメモリを割り付けることも出来る. この際の配列宣言や`allocate`によるメモリ割り付けは

```{style=f90}
  real(8), allocatable :: x(:,:,:)

  allocate(x(5,10,20))
```

の様に行う. 配列のサイズは実行時に決定することが出来るのに対して, rankはコンパイル時に決定され, 実行中には変更できないことに注意しよう.

## 配列の入出力
配列データの入出力についてもこれまでと同様に各要素を`read(*,*)`や`write(*,*)`に対する入出力リストとして与える方法もあるが, 例えば配列全体を入出力リストとして与えることなども出来る. 詳細は[ファイル入出力]で説明するが, ここではとりあえずアスキー形式(人間の目で読める形式)のことだけを考えることにする.

配列の各要素を出力するには, `do`ループを用いて例えば

```{style=f90}
  integer :: i
  real(8) :: x(10)

  do i = 1, 10
    write(*,*) x(i)
  end do
```

のような処理を行えば良い. この場合は各要素が出力された後に改行が挿入されるので結果の出力は10行になる. これに対して


```{style=f90}
  write(*,*) x                    ! 改行せずに1行に全要素を出力
  write(*,*) (x(i), i = 1, 10)    ! 同上
  write(*,*) (x(i), i = 1, 10, 2) ! 1つ飛ばしで出力
```

などのように`do`ループと同じような書き方が可能であり, 先ほどの例との違いは改行が挿入されるかどうかである.

配列の入力についても両方の書き方が可能である.

```{style=f90}
  ! 10個の要素を順に読み込む
  do i = 1, 10
    read(*,*) x(i)
  end do

  ! 同上
  read(*,*) (x(i), i = 1, 10)

  ! これでも良い
  read(*,*) x
```

例えば上の例で2-4行目と7行目は同じ処理をする. なおFortranはデフォルトで空白, Tab, カンマ, 改行などを各要素の区切りとして解釈することに注意をして欲しい. すなわち

```{style=shell}
1.0, 2.0, ... 9.0, 10.0
```

と

```{style=shell}
1.0
2.0
...
9.0
10.0
```

のどちらでも同じように(正しく)読み込まれることになる. ちなみに復習しておくと, 予め存在するファイルの内容を上のような処理によって読み込むにはリダイレクトを使って

```{style=shell}
 $ ./a.out < data.dat
```

のようにすれば良い. (この例ではdata.datの内容をa.outに渡している.)

多次元配列の読み込みについては少し注意が必要である. 例えば

```{style=shell}
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0
10.0 11.0 12.0
```

というファイルを標準入力へのリダイレクトから3x4の2次元配列として読み込む場合に

```{style=f90}
  real(8) :: x(3,4)

  read(*,*) x
```

とすると, `x(1,1), x(2,1), x(3,1), x(1,2), ...` にそれぞれ `1.0, 2.0, 3.0, 4.0, ...` が代入されることになる. これは入力が先頭から順々に行われ, またFortranの多次元配列のメモリ並びがこの順番になっているためである(メモリ並びについては[Column majorとRow major]参照). 配列の形状が何であってもかならずこの順番で読み込まれるため, 例えば


```{style=f90}
  real(8) :: x(2,6)

  read(*,*) x
```

であれば, `x(1,1), x(2,1), x(1,2), x(2,2), ...` の順で `1.0, 2.0, 3.0, 4.0, ...` が代入されてしまう. このように多次元配列の読み込みは(初心者にとっては)必ずしも意図する結果にならないことがあるので注意して欲しい.

## 配列に関する組込み関数
Fortranにはいくつか配列に関する便利な組込み関数が用意されている. 細かい使い方についてはサンプルコードや自分で実際にコードを書いてみて動作確認をしてみるのが一番の近道である.

例えば以下の例ではベクトル同士の内積を計算する`dot_product`や行列同士もしくは行列とベクトルの積を計算する`matmul`の使い方を示している.

```{style=f90}
  integer, parameter :: n = 5
  integer :: i, j
  real(8) :: a(n,n), b(n), x(n)
  real(8) :: inner

  ! aとxに何らかの値を入れる

  ! 初期化
  do i = 1, n
    b(i) = 0.0_8
  end do

  ! 行列aとベクトルxの積をbに代入: b_{i} = a_{i,j} * x_{j}
  do j = 1, n
    do i = 1, n
      b(i) = b(i) + a(i,j) * x(j)
    end do
  end do

  ! 組み込み関数を使用して同じ計算を行う
  b = matmul(a, x)

  ! ベクトル同士の内積を計算
  inner = 0.0_8
  do i = 1, n
    inner = inner + b(i) * x(i)
  end do

  ! 組み込み関数を使用して同じ計算を行う
  inner = dot_product(b, x)
```

この例では9-18行目と21行目はどちらも行列とベクトルの積を求めるものである. 同様に24-27行目と30行目も全く同じ処理(内積計算)を行なっている. 組込み関数を用いることで非常に簡単に処理が記述できることがお分かり頂けるだろう. 数学関数に加えてよく使われる組み込み関数をいくつか以下の表に挙げておこう. 念のために言うとこれらは必ずしも記憶して置かなければいけないものでは無く, 必要になった時に自分で調べて使いこなすことが出来ればそれで良い. (例えば富田・齋藤(2011, 6章)が配列に関する組み込み関数について詳しい.)

関数名                  説明
---------------------   ----------------------------------------------------
`dot_product(x, y)`     ベクトル(1次元配列)`x`と`y`の内積を返す
`matmul(x, y)`          行列(2次元配列)同士, もしくは行列とベクトル(1次元配列)の積を返す
`transpose(x)`          行列(2次元配列)の転置を返す
`sum(x)`                配列`x`の各要素の和を返す
`product(x)`            配列`x`の各要素の積を返す
`size(x)`               配列`x`の全要素数(サイズ)を返す
`shape(x)`              配列`x`の形状を1次元の整数型配列として返す
`reshape(x, s)`         配列`x`の形状を新しい形状`s`に変換したものを返す

Table: 配列に関する組み込み関数の例

<!--
`maxval(x)`             配列`x`の全要素の最大値を返す
`minval(x)`             配列`x`の全要素の最小値を返す
-->

なお`reshape`を使うと多次元の配列定数を初期化することが出来る. 以下はその例である.

```{style=f90}
  integer, parameter :: x(2,3) = reshape((/1, 2, 3, 4, 5, 6/), (/2, 3/))
```

`reshape`の第1引数は任意の配列であり, この配列の形状を変更したものを返す. 第2引数には新しい配列の形状を指定している. ここでは左辺の配列の形状が`(2,3)`であるので`reshape`の第2引数は`(/2, 3/)`と形状を1次元の整数配列として指定している. 当然, 元々の入力配列のサイズと新しい配列のサイズは同じでなければならない^[このように配列形状を変更できることを不思議に思うかもしれない. しかし, 実際には1次元配列も多次元配列も中身は同じ1次元的なメモリ領域を指しており, 使う側には便宜上違う次元のもののように見えているだけなのである. 詳しくは[Column majorとRow major]を参照のこと.].

## 部分配列
これまでは各要素に添字を用いて例えば`x(10)`のような形でアクセスしていた. Fortranではこれに加えて*部分配列*という便利な機能があり, 配列の複数の要素にまとめてアクセスすることが出来る. これには添字の代わりに `x(lower:upper:stride)` のような形式を用いる. `lower`, `upper`, `stride`の意味は[`do`変数の指定方法][決まった回数の繰り返し(do)]と同じである. 従って例えば

```{style=f90}
  integer :: x(10) = (/1, 2, 3, 4, 5, 6, 7, 8, 9, 10/)

  write(*,*) x(1:10:2) ! 1, 3, 5, 7, 9が出力される
```

のように書くことが出来る. `lower`, `upper`, `stride`などは省略することも出来, その場合は`lower`は配列の最初の要素, `upper`は最後の要素, `stride`は1と解釈される. ただし`stride`はともかく`lower`, `upper`は明示的に書いておいた方が分かりやすい. またこれらの指定に変数を使う事もできる.

## 配列演算
さらに, Fortranには非常に強力な*配列演算*という機能が用意されている. 例えば以下の例を見てみよう.

```{style=f90}
  integer, parameter :: n = 8
  integer :: i
  real(8) :: a(n), b(n), c(n)

  ! 代入
  do i = 1, n
     b(i) = a(i)
  end do

  ! 配列演算による代入(上のdoループと同じ)
  b = a

  write(*,*) 'b = ', b ! 配列bの全要素を出力

  ! 演算
  do i = 1, n
     c(i) = 0.5_8*a(i) + cos(b(i))
  end do

  ! 配列演算(上のdoループと同じ)
  c = 0.5_8*a + cos(b)

  write(*,*) 'c = ', c ! 配列cの全要素を出力
```

上の例の6-8行目と11行目, 16-18行目と21行目は等価である. このようにFortranでは*配列同士の演算をあたかも通常の変数であるかのように記述することができる*. これを配列演算と呼ぶ. 数学で用いるような直感的な表現が出来ることに加えて, これを用いることでかなりタイプ量を減らすことができるのが一目見て分かるだろう. タイプ量が少ないと当然無用なバグの混入を避けることができる. さらに, 配列演算はコンパイラによる最適化の恩恵を受けやすいという利点がある. 部分配列と配列演算を組み合わせることも当然可能である. 例えば

```{style=f90}
  integer, parameter :: m = 10
  real(8) :: x(m), y(m/2)

  y = 2*x(1:m:2) + 1
```

のような使い方が出来る. また部分配列や配列演算の機能は多次元配列でも同様に使用することが出来る. ただし, 配列演算は*同じ形状(次元およびサイズ)の配列に対してしか行うことが出来ない*. それ以外の場合には演算が定義されないのでこれは当たり前の話である.

また, 数学におけるベクトルの内積やベクトルと行列の積の計算規則とは異なり, 配列演算はあくまで各要素ごとの演算であるという点に注意しよう. 例えば`x(100)`と`y(100)`のような2つのサイズの等しい1次元配列の積`x*y`は同じサイズ100の配列となり, スカラー値を計算する内積の計算規則とは異なる. また行列`M(100,100)`とベクトル`x(100)`の積を計算しようとして`M*x`と記述しても`M`と`x`は形状が異るのでエラーとなってしまう. このような場合は先に見た`dot_product`や`matmul`を使えば良い.

## 補足^†^
### メモリ領域
Fortranの通常の静的配列(static array)の場合はメモリはスタック(stack)と呼ばれる領域に保持される. 環境によっては(おそらく多くのLinux環境のデフォルトでは)スタックに大きなメモリ領域を保持できないようになっている. この設定は例えばsh系のシェル(bashなど)では以下のように`ulimit`コマンド(csh系のシェルならば`limit`)で確認することが出来る.

```{style=shell}
$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
file size               (blocks, -f) unlimited
max locked memory       (kbytes, -l) unlimited
max memory size         (kbytes, -m) unlimited
open files                      (-n) 256
pipe size            (512 bytes, -p) 1
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 709
virtual memory          (kbytes, -v) unlimited
```

上の`ulimit`コマンドの出力結果から, この環境ではスタック領域が8MBに制限されているので大きな静的配列を確保することが出来ないことが分かる. プログラムの実行直後に原因不明の`Segmentation fault`などのエラーで終了してしまう場合はスタック領域が足りずにメモリが確保出来なかったことが原因かもしれない.

どうしても静的配列を使いたい場合には`ulimit`コマンドで使用可能なスタック領域を増やせば良い. もしくは静的配列の使用をやめて`allocatable`配列を用いるようにすればスタック領域の制限は受けない. これは`allocatable`属性付きで宣言された配列のメモリは(`allocate`によって)ヒープ(heap)と呼ばれる別の領域にメモリが確保されるためである. なおスタックとかヒープについて必ずしも理解している必要は無いが, 原因不明のエラーが発生した時にはこのことをふと思い出して欲しい.

### Column majorとRow major
既に説明したように配列は計算機の連続したメモリ上に確保されることが保証されている. これは1次元の場合には分かりやすいが, 多次元配列の場合はどうなっているのであろうか？計算機のメモリは1次元的なアドレスからなっているので, 実は多次元配列であってもメモリは内部的には1次元的に連続な領域を指している. 多次元配列は単にそれらを使いやすく表示したものに過ぎない. 一般的にFortranでは例えば2次元配列`x(10,10)`の場合は`x(1,1)`, `x(2,1)`, ..., `x(10,1)`, `x(1,2)`, `x(2,2)`, ... のような並び, すなわち配列の一番左の添字がメモリの連続した方向となっている. これ
をcolumn majorと呼ぶ. これに対してC言語などではrow majorと呼ばれるメモリ並びが採用されており一番右側の添字がメモリの連続する方向となっている(図参照). 従って, C言語で書かれたライブラリをFortranから呼び出す際(もしくはその逆)にはこの違いに注意しなければならない.

またこのことから, 効率的なプログラムとするためには多次元配列のループの書き方も注意が必要である. 以下の例を考えてみよう.

```{style=f90}
  integer :: i, j
  real(8) :: a(10,10), s


  ! 例1
  s = 0.0_8
  do j = 1, 10
    do i = 1, 10
      s = s + a(i, j)
    end do
  end do

  ! 例2
  s = 0.0_8
  do i = 1, 10
    do j = 1, 10
      s = s + a(i, j)
    end do
  end do
```

この例では5-11行目(例1)と13-19行目(例2)は全く同じ処理(配列内の全要素の総和計算)を行なっているが, 多重`do`ループの添字の順番が異なることに注目して欲しい. 例1では左側の添字`i`が内側のループで走り, 例2では右側の添字`j`が内側のループで走っている.  基本的に計算機というのは単純作業(例えば`if`分岐などがないループ)を一気に, メモリの連続している方向に順番に処理するのが得意になっている. 従って, この例では左側の添字が内側ループで走る例1の方が効率の良いプログラムということになる^[実際にはプログラムの構造やループ内でのメモリ使用量, CPUやコンパイラの性能に大きく依存する(かしこいコンパイラはループの順序を交換したりすることもある). またこの程度の小さな配列ではほとんど差が見られないであろう.]. 最初はそれほど気にすることは無いが, 単に「動く」だけのプログラムでは無く, 「良い」プログラムとなるように細かい点についても気を配れるようになって欲しい.

![Column majorとRow major. メモリは左から右に連続的に並んでいる. (C言語の場合は実際には配列添字は0から始まり, 添字も`[]`で指定することに注意.)](figure/storageorder.png)

### 配列境界チェック
配列の添字の範囲をはみ出した場合には何が起こるだろうか? 実はこの時何が起こるかは実行してみるまで分からない. 何事も無かったかのように正常終了するように見える場合もあるし, "Segmentation fault"などのエラーが表示されて異常終了することもある. 1つだけ言えることはそのようなプログラムは例え正しく動いているように見えたとしてもかなり危険な状態である. なぜならプログラムで自分が｢使いたい｣と要請したメモリ領域とは異なる領域へアクセスしていることになるので, 自分のプログラムで用いているメモリ領域はおろか, OSがプログラムの実行に必要とする情報(コールスタックなどと呼ばれる)をも意図せず書き換えてしまうかもしれない. 異常終了しなかったとしても, それはたまたま運が良かっただけなの話である. たった1行ソースコードを書き換えただけでも, プログラム中のメモリ配置が変わることで動作がおかしくなるかもしれない. (1行`write`文を入れるかどうかだけの違いで動作が変わるような場合もあるが, そういう時には大抵おかしなメモリ領域にアクセスしているものである.)

そもそも配列の添字範囲をはみ出すのは明らかなバグである. 通常は効率を重視するため配列添字の境界チェックは行われないが, gfortranではコンパイル時に`-fbounds-check`というオプションをつけることでこの配列境界チェックを行うことが出来る. (多くのFortranコンパイラが同じようなオプションを有しているので他のコンパイラを用いる時にはチェックしてみて欲しい.) これによってもし境界をはみ出した場合にはその旨エラーが出力されてプログラムが終了する.

```{style=f90}
program check
  implicit none

  integer :: i = 11
  integer :: x(10)

  x(i) = 1

  stop
end program check
```

例えば上のソースコードをcheck.f90として保存し, コンパイル･実行した結果は以下のようになる.

```{style=shell}
 $ gfortran -fbounds-check check.f90
 $ ./a.out
At line 7 of file check.f90
Fortran runtime error: Index '11' of dimension 1 of array 'x' above upper bound of 10
```

配列`x`の上限(10)を超えた11番目の要素にアクセスしているのでエラーが表示されているのが分かる. ただし, このようなチェックを逐一行うことで, 当然実行時のパフォーマンスは犠牲になる. 従って, デバッグの段階でこのような配列境界チェックを行い, 時間のかかる計算を実行する際にはこのオプションは外しておこう.

\clearpage

# 書式指定・ファイル入出力・文字列処理
ここではこれまではオマジナイとして使ってきた`write(*,*)`や`read(*,*)`の意味を理解し, ファイル入出力や, 出力時の書式指定の仕方, さらには文字列処理の方法について学ぼう.

> サンプルプログラム
>
> - chap06/sample1.f90 : 書式指定
> - chap06/sample2.f90 : ファイル入出力(アスキー形式)
> - chap06/sample3.f90 : ファイル入出力(バイナリ形式)
> - chap06/sample4.f90 : 文字列処理
> - chap06/sample5.f90 : ファイル各行の逐次処理

## 書式指定
実は`write(*,*)`の2つめの引数は出力される値の書式を表す*編集記述子*を指定するためのもので, "`*`"はデフォルトの書式を意味している(従って一般にコンパイラによって出力の書式は異なる). ここに決められた形式で書式を指定することで桁を揃えたりして, 綺麗な出力を得ることが出来る. 例えば

```{style=f90}
  character(len=128) :: fmt
  integer :: year = 2014

  write(*, '(i6)') year

  fmt = '(i6)'
  write(*, fmt) year
```

のように`*`の代わりの編集記述子(ここでは`'(i6)'`や`fmt`)を指定することになる. 4行目のように直接指定しても良いし, 7行目のように文字型の変数を用いてもどちらでも構わない.

さて, 問題は書式の指定の仕方(上の例では`i6`)についてである. 書式指定の詳細については適宜他の文献^[高木(2009, 8章)が詳しい.]を参照してもらうとして, ここでは以下の表に挙げる典型的な例を理解しておけば良い.

+----------+---------+---------+-------------------------------------------------------+
|データ型  |  記述子 |  例     | 例の説明                                              |
+==========+=========+=========+=======================================================+
|整数型    | `I`     |  `i6`   | 6桁で出力する.                                        |
+----------+---------+---------+-------------------------------------------------------+
|          |         |  `i8.6` | 8桁で出力する. ただし6桁に満たない部分は0で埋められる.|
+----------+---------+---------+-------------------------------------------------------+
|実数      | `F`     | `f12.5` | 12桁で出力, うち5桁が小数点以下.                      |
+----------+---------+---------+-------------------------------------------------------+
|          | `E`     | `e20.7` | 科学的表記[^1]の20桁で出力, うち7桁が小数点以下.      |
+----------+---------+---------+-------------------------------------------------------+
|文字型    | `A`     | `a`     | 与えられた文字型の字数に対応する桁数を確保して出力.   |
+----------+---------+---------+-------------------------------------------------------+
|          |         | `a30`   | 30桁で右寄せの出力.                                   |
+----------+---------+---------+-------------------------------------------------------+
|空白      | `X`     | `5X`    | 指定された数だけ空白を出力. この場合は5桁.            |
+----------+---------+---------+-------------------------------------------------------+
|改行      | `/`     | `/`     | 改行される.                                           |
+----------+---------+---------+-------------------------------------------------------+

Table: 編集記述子の使い方の例

[^1]: 科学的表記とは$3 \times 10^{10}$のような表記法のことである. Fortranの出力では`0.3e+11`のような形になる.

上の表は編集記述子の使い方の典型的な例を示している. 基本的には*編集記述子*と*表示桁数*の組み合わせの形で表すことになっている. 以下にいくつか注意点を挙げておこう:

- 数値データは指定された書式で出力が出来ない場合の出力は**全て"`*`"が出力されてしまう**ので気をつけよう. 実数データの出力では符号, 小数点, 指数部の桁数を考慮しなくてはならないので, `E`型記述子では $全桁数 \geq 小数部の桁数 + 6$ となっている必要がある. `F`型編集記述子の場合はデータ(整数部の桁数)に依存するが少なくとも$全桁数 \geq 小数部の桁数 + 2$が必要である. これは以下のような例によって確認することが出来る.

```{style=f90}
  write(*,'(f5.3)') 3.1415      ! これはOK
  write(*,'(f5.3)') 3.1415 * 10 ! これはダメ
  write(*,'(e9.3)') 3.1415      ! これはOK
  write(*,'(e5.3)') 3.1415      ! これはダメ
```

- 文字型データでは, 桁数が渡された文字数よりも少ない場合は文字型の先頭から桁数分だけが出力される.

- 複数の編集記述子をカンマ"`,`"で区切って並べることが出来る. この際に, 編集記述子ではない通常の文字列も同様にカンマで区切って並べることが出来る. ただし指定子の文字列が"`'`"(シングルクオート)で区切られている場合には, その中の文字列は"`"`"(ダブルクオート)で囲まなければならない. 使い方は以下の通りである.

```{style=f90}
  ! 複数の記述子を並べる
  write(*,'(e10.3, e10.3, e10.3)') x, y, z

  ! 文字列および改行を使う
  write(*,'("x = ", e10.3, /, "y = ", e10.3, /, "z = ", e10.3)') x, y, z
```

- 同じ書式指定子を複数回繰り返す場合には書式指定子の前に繰り返す回数を指定する省略記法が使える. 例えば`'(a10, 3i5)'` は `'(a10, i5, i5, i5)'`と等しい.

なお`read(*,*)`についても同様の指定が可能であるが, それほど必要な場面はないかもしれない. 一つ考えられるのはスペースを含んだ文字列(例えばファイルの1行分)を一つの文字型変数に読み込みたいときであろう. このときには

```{style=f90}
 character(128) :: text

 read(*, '(a)') text
```

のように`'(a)'`を指定しないとスペースまでの文字列が`text`に取り込まれてしまう. これはFortranがデフォルトでスペースや改行などを変数の区切りとして読み込んでしまうからである.

また書式指定は`write(*, fmt='(a)')`のように行うこともできる^[このような引数の渡し方はこの後の`open`文などでも出てくる. これは[キーワード引数][optional属性とキーワード引数^†^]と呼ばれ, これによって関数やサブルーチンに順番を気にすること無く引数を渡すことが出来る.]. 他には改行を抑制するために`advance='no'`のような指定も使うことがしばしばあるので覚えておいて損はない. Fortranでは通常`write`文によって最後に自動的に改行が挿入されてしまうが,

```{style=f90}
  write(*, fmt='(a)', advance='no') 'Input some text : '
```

のようにすれば`'Input some text : '`が表示された後に改行されない.

## ファイル入出力
### `open`と`close`
これまではファイルから何らかのデータを読み込んだり, ファイルに出力する時にはシェルのリダイレクト機能を用いてきた. しかし, これだと例えば複数のファイルから別々に違うデータを読み込んだり, 複数ファイルへの出力などの柔軟は処理はできない. このような場合にはソースコードの中で明示的に入出力に用いるファイルを指定し, そのファイルに対する入出力処理を行うように指定しなければならない. Fortranプログラムからファイルを開くには`open`文を用いることになる. 例えば以下の例は予め存在しないファイル`filename.dat`を新規作成して開く. (この例では, ファイルが既に存在している時にはエラーとなる.)

```{style=f90}
  open(unit=10, iostat=ios, file='filename.dat', action='write', &
       & form='formatted', status='new')
```

`open`には多くの引数を指定することになる. (あまりに多いので通常は[キーワード引数][optional属性とキーワード引数^†^]で必要なものだけ渡す.) それぞれの意味は以下の様なものである.

unit

  : 装置番号を指定する. 装置番号とはファイルを特徴付ける一意な整数である. なお標準入力は5, 標準出力は6, 標準エラー出力は0, と予め決められているのでこれら以外の値を指定すること. 1つのプログラム中で同時に複数のファイルを開く際には違う値を指定しなければならない. 自分でプログラムを書く際には10以上の重複しない整数にしておくのが無難である.

iostat

  : ここに指定した変数に`open`文の終了ステータスが格納される. ファイルが正常に開けた場合には`0`, そうでない場合には`0`以外の値が返される. この変数をチェックすることでエラーチェックをするのが定石である.


file

  : ファイル名を指定する.

action

  : ファイルに対する操作を指定する. 読み取り専用なら`read`, 書き込み専用なら`write`, 読み書きどちらもしたい場合には`readwrite`を指定する. デフォルトでは(可能ならば)`readwrite`となる.

form

  : アスキー形式(書式付き)なら`formatted`, バイナリ形式(書式なし)なら`unformatted`を指定する. デフォルトでは`formatted`となる.

status

  : ファイルの状態を指定する. `new`はファイルの新規作成を意味し, そのファイルが既に存在する時にはエラーが発生する. `replace`も新規作成であるが, そのファイルが既に存在する場合は中身を破棄して空のファイルとして開く. `old`は既に存在するファイルを開く. このときそのファイルが存在していない場合はエラーが発生する. 他にも処理系依存の`unknown`があり, これがデフォルトである.

ファイルが正常に開けたかどうかは以下のようにチェックすることが出来る.

```{style=f90}
  if (ios /= 0) then
     write(*,*) 'Failed to open'
     stop
  end if
```

いちいちチェックするのは面倒なようだが, プログラミングにおいてこのようなエラーチェックは非常に大切なのでいつもチェックする癖をつけよう. プログラム作成の際にその半分がエラーチェックになるというのもよくある話である^[書き殴りでその後2度と使わないようなコードの場合はそれほど気にする必要はないかもしれないが.].

以下にいくつかよく使う例を挙げておこう. (念の為に言っておくと`open`に渡す引数の詳細を覚えておく必要は無い. 大まかな使い方さえ知っておけば, 後はgoogleで検索する方が早い.)

- ファイルを新規作成する. ただしファイルが既に存在する場合にはその中身を破棄する(上書き).

```{style=f90}
  open(unit=10, iostat=ios, file='ascii.dat', action='write', &
       & form='formatted', status='replace')
```

- 既に存在するファイルを開き, 位置をファイル終端に指定する(`position='append'`). 既存のファイルの終端にデータを追加する場合に用いる.

```{style=f90}
  open(unit=10, iostat=ios, file='ascii.dat', action='write', &
       & form='formatted', status='old', position='append')
```

- 既に存在するファイルを読み込み専用で開き, 位置をファイル先頭に指定する(`position='rewind'`). 既存のファイルの先頭からデータを読み込む場合に用いる. ただし`position=rewind`は必ずしも指定しなくても良い.

```{style=f90}
  open(unit=10, iostat=ios, file='ascii.dat', action='read', &
       & form='formatted', status='old', position='rewind')
```

なお, `open`で開いたファイルは`close`で閉じるのが作法である. ファイルを閉じないままプログラムが異常終了してしまうと, せっかくの結果が正しく出力されないこともあり得るので注意して欲しい. `close`には`open`で開いた時に用いた装置番号を指定する. 例えば装置番号が10であれば

```{style=f90}
  close(10)
```

とすれば良い.

### アスキー(書式付き)入出力
アスキー形式とかテキスト形式と呼ばれるファイルはテキストエディタや`cat`などのコマンドで人間が理解できる形で表示できるファイルである. アスキー形式でファイルを開くには`open`で`form='formatted'`と指定するのは既に説明した通りである.

開いたファイルへの入出力をするには, `write`や`read`に装置番号を指定しなければならない. 実はこれまで使ってきた`write(*,*)`や`read(*,*)`の1番目の引数は装置番号を意味するものである. ここでも"`*`"はデフォルトの装置番号を意味し, 通常は`write`であれば標準出力の6, `read`であれば標準入力の5を指定したことと同じ意味となる. ここに`open`文で指定した装置番号を代わりに指定することで, `write`の出力先, `read`の入力先ファイルが指定出来る.

なお装置番号が何であっても2番目の引数には同じように編集記述子を指定すれば良い. 従って例えば

```{style=f90}
  integer :: i, j

  write(10, *)      i   ! デフォルトの書式
  write(10, '(i6)') j   ! 6桁で出力
```

などのように出力が出来る.

### バイナリ(書式なし)入出力
バイナリ形式とは一般にテキスト形式以外の人間がそのままでは解釈できない形式のファイルの総称である. アスキー形式での入出力では計算機の内部表現(メモリ上のビット列)を人間に解釈できる形式に逐一変換して入出力を行っている. Fortranでは`open`で`form='unformatted'`を指定して開いたファイルに対してはこのような変換が行われず, メモリ上のビット列が(ほぼ)そのまま出力されることになる. アスキー形式への変換が行われないため, 編集記述子は指定することは出来ず, `write(10)`, `read(20)` のような形で装置番号のみを指定して入出力を行う.

バイナリ入出力を行うメリットとして, まず高速であることが挙げられる. これはテキスト形式への変換を行わないことに加えて, テキスト形式での入出力に比べてデータ量を少なく抑えることが出来るためである. また内部的に2進数で表されている実数は10進数では正確に表現出来ないことから, 実数型のデータはアスキー形式への変換に伴い情報が失われてしまうが, バイナリ形式での入出力ではこの問題がない.

デメリットは人間の目ではデータの中身が判別出来ないことである. 従って, バイナリで出力されたデータを読み込むにはどのような形式で出力されたのかを予め正確に知っていなければならない. 例えば,

```{style=f90}
  write(10) x
  write(10) y
```

と出力されたデータを読み込むには

```{style=f90}
  read(10) x
  read(10) y
```

としなければならないし, 出力が

```{style=f90}
  write(10) x, y
```

であれば入力は

```{style=f90}
  read(10) x, y
```

とする必要がある. すなわち`write`で指定した変数並びと全く同じ変数並びで`read`しなければ正しく読み込みが出来ない. (大変困ったものであるが, [ストリーム入出力^†^]を用いれば少なくともこの問題は生じない .) なお当然であるが, `x`や`y`は[配列の入出力]の時と同様に配列でも良い.

また一般には異なる環境で作成したバイナリファイルには互換性が無い.ただし, この問題については多くの場合に対応が可能である(次節参照).

### バイトオーダー^†^
マルチバイトのデータを計算機のメモリ上に配置する方法のことをバイトオーダーとかエンディアンなどと呼ぶ. 分かりやすい(？)例としてIPアドレスを考えよう. IPアドレスは(IPv4では)4バイトで表され, 192.168.1.0のように1バイトごとに"."で区切って記述するのが一般的である. これをメモリに格納する際に192, 168, 1, 0の順に格納する方法をビッグエンディアン, 逆に0, 1, 168, 192の順に格納する方法をリトルエンディアンと呼んでいる. このバイトオーダーはCPU依存である. Intel系のCPUの場合はリトルエンディアンが採用されているので, 普通のPCを扱っている限りはバイトオーダーを気にする必要は無い. 一方でスーパーコンピューターなどではビッグエンディアンが採用されているCPUも比較的多く, そのような計算機で出力したデータを手元のPCで読み込む際にはバイトオーダーの変換が必要になってくる.

この変換は手動で行うことも出来るが, コンパイラのオプションで自動的に変換を行うように指定することも可能である. 例えばgfortranの場合はコンパイルオプションに`-fconvert=big-endian`を用いると, 入出力がビッグエンディアンのバイトオーダーで行われる. 他にも環境変数`F_UFMTENDIAN`を指定することでもバイトオーダーを指定することが出来るようである.

### ストリーム入出力^†^
Fortranの`unformatted`のバイナリデータは一般にはC言語の`fread`, `fwrite`による入出力と互換性が無い. これはFortranは各`write`文で出力されるデータの前後に余計なデータ(ヘッダーおよびフッター)を付加するためである^[ただしこれは慣習的にそうなっているだけで, 標準化されているわけではなく, 完全に処理系依存である. ヘッダーやフッターは4バイトのこともあるし8バイトのこともある. 同じコンパイラであってもオプションで変更することも出来る. ここで扱うストリーム入出力であればバイトオーダーさえ把握していればヘッダーやフッターのことを気にする必要が無い. ]. 新しいFortran 2003規格ではストリーム入出力というC言語の`fread`, `fwrite`と同じ(余計なデータを付加しない)読み書きが出来るようになっている. これには以下のように`access='stream'`を指定してファイルを開く.

```{style=f90}
  open(unit=10, file='binary.dat', access='stream', form='unformatted')
```

このように開かれたファイルに対しては

```{style=f90}
  write(10) x, y, z
```

と

```{style=f90}
  write(10) x
  write(10) y
  write(10) z
```

では全く同じデータが出力される. このように生成されたデータファイルはC言語の`fread`を用いて正常に読み込みが出来るし, また`fwrite`で出力したデータもFortranの`read`文で読み込むことが可能である.

## 文字列処理
### 文字型変数の宣言
文字型変数の宣言は

```{style=f90}
  character(len=長さ) :: 変数名 = 初期化文字列
```

のように行えば良いことは既に学んだ. ここで指定した文字数に足りない部分はスペースで埋められる. 従って, 例えば長さ10の文字型変数に`'ABCDE'`を代入すると, その後ろに空白文字が5文字代入される. 定数の場合は文字型の初期化時には長さを陽に指定しなくても

```{style=f90}
  character(len=*), parameter :: text = 'initialization by this string'
```

のように`len=*`を指定して初期化すると, 自動的に初期化文字列の長さを持った文字型変数となる^[[後述][関数とサブルーチン]の関数やサブルーチンの仮引数でもこの形式が使える.].

### 結合と代入
文字型変数は`//`演算子を用いて結合することや, 結合した文字列を他の文字型変数に代入することが出来る. ただしこの際には空白の存在に注意しなければならない. 例えば

```{style=f90}
  character(len=16) :: a, b, c, d

  a = 'This'
  b = 'is'
  c = 'a'
  d = 'pen'

  write(*,*) a // b // c // d
```

とした場合には, `a`, `b`, `c`, `d`のどれも16文字の文字列であるので, 16文字に満たない部分は全て空白で埋められている. 従って`//`で結合しても空白は取り除かれずに残ることになり, 実行結果の出力は以下のようになるだろう.

```{style=shell}
 This            is              a               pen
```

文字列の前後の空白文字を除去するには`trim`という組み込み関数を用いれば良い. 空白を除去して各文字列間に1文字分ずつ空白を入れて出力するには

```{style=f90}
  write(*, '(a,x,a,x,a,x,a)') trim(a), trim(b), trim(c), trim(d)
```

などとすれば良い. これによって以下の様な出力が得られる.

```{style=shell}
This is a pen
```

### 部分文字列
配列の場合には`a(1:10)`のように部分配列を用いることが出来た. これと同じことが文字型変数に対しても出来る. 例えば

```{style=f90}
  character(len=64) :: str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

  write(*,*) str(1:1)  ! 'A'
  write(*,*) str(6:10) ! 'FGHIJ'
```

などのような形である. 例えば, 以下のように特定の文字列の検索を行い, 該当部分だけを取り出すような処理に用いることが出来る.

```{style=f90}
  integer :: i1, i2
  character(len=64) :: str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

  ! XYZと一致する部分文字列を検索し, 開始位置のインデックスを返す
  i1 = index(str, 'XYZ')
  i2 = i1 + len('XYZ')
  write(*,*) str(i1:i2)  ! XYZを出力
```

ここで組込み関数`index(s1, s2)`は文字列`s1`の中から`s2`に一致する部分文字列を検索し, 開始位置のインデックスを返す関数である. 文字列操作に関するその他の組み込み関数については富田・齋藤(2011, 7章)などを参照のこと.

### 内部ファイル
プログラム中で必要な文字列のフォーマットを揃えるのには*内部ファイル*と呼ばれる機能を知っていると何かと便利である. これまでに`write`の一番目の引数には装置番号を指定することを学んだが, 以下の例では装置番号の代わりに文字型変数`str`が指定されている.

```{style=f90}
  character(len=64) :: str
  integer :: n

  do n = 1, 8
     write(str, '("data",i3.3,".dat")') n
     write(*, '(a)') str
  end do
```

これによりフォーマットされた文字列が`str`に代入される. この例では`data001.dat`, `data002.dat`, ... のように連番のファイル名を作成して出力する.

## ファイル終端までの逐次処理
文字列処理ではファイルの中身を一行ずつ読み込んで何らかの処理を行うことが多い. 以下のサンプルコードは標準入力から1行ずつ順に読み込み処理をする例である. (従ってリダイレクトによってファイルを与えれば良い). ファイルが終端に達したかどうかを調べるには`read`の終了ステータス`iostat`を取得すれば良い. 正常に読み込みが実行された時には`iostat`が0となり, これが負の場合にはファイルの終端, 正の場合には何らかのエラーが発生したことを意味する. なお, 実際にはこのような処理はシェルスクリプトやPerl, Python, Rubyなどを使って実装する方が圧倒的に簡単である. (何でもかんでもFortranでやろうとするのは無駄が多い.)

```{style=f90}
  integer :: ios
  character(len=128) :: line

  read(*, fmt='(a)', iostat=ios) line

  do while(ios == 0)

    lineに何らかの処理をする

    ! 次の行を読み込む
    read(*, fmt='(a)', iostat=ios) line
  end do
```

\clearpage

# 関数とサブルーチン

> サンプルプログラム
>
> - chap07/sample1.f90 : 関数
> - chap07/sample2.f90 : サブルーチン
> - chap07/sample3.f90 : 変数のスコープ
> - chap07/sample4.f90 : 詳細(実践編)

これまでのプログラムは全ての処理が`program`から`end program`で囲まれた部分に記述されていたことと思う. これをメインプログラムと呼ぶ. これに対して, メインプログラム以外にもまとまった処理を1つのプログラム単位として記述しておくことが出来る. これをサブプログラムと呼んでいる. サブプログラムを用いることで同じ処理を何度も書かずに済むようになるため, プログラムを簡潔に記述することが出来る(従って無用な間違いも減らすことが出来る).

なおFortranでのサブプログラムには関数(`function`)とサブルーチン(`subroutine`)の2種類が有る^[後で学ぶモジュールもサブプログラムになるのだが, ここではこの2つのみを考えれば良い.]. 関数は値を返すのに対してサブルーチンは値を返さないという違いが有るが, どちらも同じようなものである. (実際にほとんどの言語でサブルーチンと関数の区別は存在しない. Fortranで言うところサブルーチンはC/C++では単に返値が`void`型の関数でしかない.) 最初は少し取っ付きづらいかもしれないが, 関数やサブルーチンを使いこなせるようになると格段にプログラムの開発が楽になるので積極的に利用しよう.

## 概要
関数やサブルーチンなどのサブプログラムはひとまとまりの処理を実行する独立なプログラムと考えることが出来る. 例えば, 3次方程式$a x^3 + b x ^2 + c x + d = 0$の数値解を与えられた初期値からなんらかの反復法を用いて求める処理を考えよう^[3次方程式には解の公式が存在するが, 実用的には反復法の方が精度や速度の面で有利なことが多い.].

ここで係数$a, b, c, d$の値が何であっても行う処理は基本的に同じであろう. では2つの異なる係数の組に対して数値解を知りたい場合はどうすれば良いだろうか? 同じ処理なのだからコピー＆ペーストして係数の値だけ書き換えるというのも一つの案である. しかし, 100個の異なる係数の組に対する解を知りたい場合はどうすれば良いだろうか? 100回コピー＆ペーストするというのは得策とは言えない. このような場合には与えられた係数の組に対して処理を実行し, 結果を返す*関数*が定義されていれば, それを100回呼び出すだけである. ($\cos x$のような数学関数を思い浮かべてもらえば良い.)

このように, 何らかのまとまった処理を1つの独立したプログラム単位として定義することが出来れば圧倒的にプログラム作成が簡単になる. プログラム作成時に大事な事は人間は間違える動物であるという前提に立つことである. 間違いを少なくするには問題を簡単にするしか方法は無い. サブプログラムはそれ単体で独立したプログラムであるから, 仕様さえ確定してしまえばプログラマはそのサブプログラムの実装に集中すれば良く, それがどのように使われるかに気を使う必要は無いのである. また, サブプログラムが機能的に小さければ小さいほど(問題設定が単純になるので)実装が簡単で間違いが少ない^[全体像を完全に把握出来るプログラムの規模は常人にはせいぜい1000行程度が限界であろう. 実際には100行でも怪しいものである.]. 従って, 規模の大きなプログラムを開発する際には, 機能を出来る限り分割した小さな関数やサブルーチン群を実装し, それらを利用して最終的に所望の機能を実装する戦略の方が圧倒的にバグが入りにくいし, またあったとしても修正が容易になる. プログラムを作成する際には関数やサブルーチンにまとめられるような処理が無いか常に注意しておくべきである.

次図は関数とサブルーチンの概念図である. いずれもひとまとまりの処理を実行するものであり, 何らかの入力を受け取り, 出力を返すことが出来る. (もちろん入力や出力は無くても良い.) ひとたび正しく実装してしまえば, 利用者(呼び出し側)はサブプログラムの内部の実装を気にする必要は無く, ブラックボックスとして用いることが出来る. ($\cos x$の値を内部でどのように計算するのか意識しながら用いることは無いのと同じである.) このため, 利用者はその他の処理の実装に集中することが可能になるのである.

![関数とサブルーチンの概念図.](figure/blackbox.png)

サブプログラムはメインプログラムとは独立したプログラムなので, メインプログラムとは他の場所に定義して呼び出すことになる. 以下の図はメインプログラムで全ての処理を実行する場合と, サブプログラムを利用する場合の処理の流れを概念的に示している. サブプログラムを呼び出すと, その定義に記述されている処理を実行し, 終了すると呼び出し元に処理が返る仕組みになっている. もちろんサブプログラムが他のサブプログラムを呼び出すことも可能である.

![サブプログラムを利用したプログラムの概念図.](figure/subprogram.png)

## 定義と呼び出し
まずはサブプログラムの定義の仕方と, その呼び出し方を学ぼう.

### 関数
関数とは何らかの値を返すサブプログラムであり, 以下の様な形式で定義される.

```{style=f90}
型 function 関数名(引数リスト)

  変数や引数の型宣言

  処理

end function 関数名
```

例えば以下は倍精度実数の2乗を返す関数の定義である.

```{style=f90}
real(8) function square(x)
  implicit none  ! 暗黙の型宣言の禁止
  real(8) :: x   ! 引数の型宣言

  square = x**2  ! 関数名と同じ変数に値を代入することで, この値が返値となる

  return         ! 呼び出し元へ制御を戻す
end function square
```

メインプログラムが`program`で始まり`end program`で終わるのと同様に, 関数定義も`function`で始まり`end function`で終わる一つの独立したプログラム単位である. 従って`implicit none`によって暗黙の型宣言を禁止し, 使用する変数は明示的に宣言をする必要がある. メインプログラムとの大きな違いは, サブプログラムには引数(この場合は`x`)が入力として与えられることであり, 引数についてもデータ型を宣言しなければならない. 引数はカンマで区切って複数与えても良いし, それぞれが別のデータ型であっても構わない. なおサブプログラムの定義時の引数のことを仮引数と呼び, 呼び出すときに実際に与えられる引数のことを実引数と呼ぶ. 一方, 返値は*関数名と同じ名前の変数に値を代入する*ことでそれが返値となる. 返値のデータ型は1行目先頭の`real(8)`で指定される. `return`文はサブプログラムからその呼び出し元へ制御を戻すことを意味しており, 上のように他の処理が全て終わった後であれば省略しても構わない. 処理の途中で`return`することも可能で, その場合にはそれ以降の処理は行われずに呼び出し元へと制御が戻される. 例えば`if`文で何らかの条件判定を行い, それ以降の処理を行う必要がないと判断した場合にはその時点で`return`によって関数から抜けることが出来る.

なお関数宣言時に`function`の前に返値のデータ型を指定するのでは無く, 以下の様に`result(変数名)`のような形で指定することも出来る.

```{style=f90}
function 関数名(引数リスト) result(変数名)

  変数や引数の型宣言

  処理

end function 関数名
```

この場合は`result`で指定された変数に値を代入することで, それが関数の返値となる. 従って, 先ほどの`square`の定義は以下のように行うことも出来る.

```{style=f90}
function square(x) result(y)
  implicit none
  real(8) :: x
  real(8) :: y  ! yについても宣言

  y = x**2

  return
end function square
```

関数の呼出は組込み関数と全く同じで, 以下のように適宜引数を与えて呼び出せば良い.

```{style=f90}
  real(8) :: x

  ! 返値を代入
  x = square(3.0_8)

  ! 返値を標準出力に表示
  write(*,*) square(2.0_8)
```

### サブルーチン
サブルーチンは関数と良く似ているが, 値を返さないという違いがある. 定義は以下の様な形式となる.

```{style=f90}
subroutine サブルーチン名(引数リスト)
  変数や引数の型宣言

  処理

end subroutine サブルーチン名
```

例えば

```{style=f90}
subroutine hello(name)
  implicit none             ! 暗黙の型宣言の禁止
  character(len=*) :: name  ! 文字列を引数として受け取る

  write(*,*) 'Hello ', name ! 表示

  return
end subroutine hello
```

は引数で渡された文字列`name`を標準出力に表示するだけのサブルーチンである. 関数と非常によく似た構造になっていることが分かるだろう. 実際に, 関数で必要だった返値の型指定が無いことを除くとほとんど同じである.

上のように定義したサブルーチンを呼び出すには以下のように`call`を用いなければならない. (関数呼び出しに`call`を用いることはできない.)

```{style=f90}
  call hello('Michel')
```

## 変数のスコープ
注意しなければならないのは, サブプログラムは1つの独立したプログラム単位であるので, その中で宣言する*変数は外部の変数とは完全に独立*であるという点である. 例えばメインプログラムで宣言されている`x`という変数とサブプログラム中で宣言されている`x`という変数は完全に別のものとして扱われる. また当然サブプログラム中で使用している変数を外部から使用することは出来ない. いくつかの例外はあるものの, 基本的にはサブプログラムとメインプログラム及び他のサブプログラムは全く独立なものとして考えて良い^[例外としては[内部手続き]を用いる場合や, モジュールもしくはFortran 77の`common`を用いる場合が考えられるが, とりあえずはこのように理解して欲しい.]. サブプログラムと外部の情報のやり取りは基本的には引数と返値を通じて行うものと理解して欲しい.

## 内部手続きと外部手続き
サブプログラムは独立したプログラム単位なので, 定義はメインプログラムの外で行い, メインプログラムや他のサブプログラムから呼び出すことになる. 実際には以下で見るように内部手続きおよび外部手続きと呼ばれる2種類の方法があるが, この演習では内部手続きの利用を推奨することにする. それは, 内部手続きの方が間違いが少ないし, 外部手続きはモジュール中の内部手続きとして実装した方が一般的には行儀の良い(間違いの少ない)プログラムとなるためである.

### 内部手続き
メインプログラムの`stop`の後に`contains`を挿入し, そこから`end program`の間に定義されるサブプログラムを内部手続きと呼ぶ.

```{style=f90}
program sample
  implicit none

  メインプログラムの処理

  stop
contains

  内部手続の定義場所

end program sample
```

メインプログラムから呼び出すためには特に準備は必要無く, 以下のようにすれば良い.

```{style=f90}
program sample
  implicit none

  ! 関数の呼び出し
  write(*,*) square(2.0_8)

  ! サブルーチンの呼び出し
  call hello('Michel')

  stop
contains
  function square(x) result(y)
    定義
  end function square

  subroutine hello(name)
    定義
  end subroutine hello
end program sample
```

ただし内部手続きの変数のスコープには注意しなければならない. なぜなら*メインプログラム中で宣言した変数には内部手続きからアクセスすることが出来る*(逆は出来ない)ためである. 以下の例では, 内部手続き`sub`からメインプログラム中に定義された変数`n`にアクセスしている. しかし, もし内部手続き`sub`中で変数`n`が定義されている場合(13行目のコメントを外した場合)には, この変数は`sub`内部のみで有効な(メインプログラム中の`n`とは独立な)変数になる. 一般的には, サブプログラムからメインプログラム中の変数を不用意に直接参照するのは間違いの基になりやすい. それよりは, 引数や返値を通じて値のやり取りを明示的に行う方が分かりやすいプログラムとなることが多い.

```{style=f90}
program sample
  implicit none
  integer :: n = 10

  call sub()

  stop
contains
  ! 内部手続の定義
  subroutine sub()
    implicit none
    ! もし以下の行があればメインプログラムのnとサブプログラムのnは独立
    !integer :: n

    write(*,*) n        ! メインプログラム中の変数nにアクセス
  end subroutine sub
end program sample
```

### 外部手続き(非推奨)
外部手続きは`program`から`end program`で囲まれた範囲*以外*に定義される. メインプログラムの前でも後でもどちらでも良い. 適切にコンパイル・リンクすれば別ファイルで定義したサブプログラムを用いることも可能である.

内部手続きとは異なり, 外部手続は使うことを明示的に宣言する必要がある. これは例えば以下の様なものである.

```{style=f90}
program sample
  implicit none

  ! 外部関数を呼び出すために必要
  interface
    real(8) function square(x)
      real(8) :: x
    end function
  end interface

  ! 外部サブルーチンを呼び出すために必要
  interface
    subroutine hello(name)
      character(len=*) :: name
    end subroutine hello
  end interface

  他の変数宣言やメインプログラムの処理

  stop
end program sample

function square(x) result(y)
  定義
end function square

subroutine hello(name)
  定義
end subroutine hello

```

このように外部手続では`interface`によって関数やサブルーチンの呼び出し形式を予め宣言してから呼び出すことになる^[C言語で言うところのプロトタイプ宣言である.]. 実はもう少しサボった(`interface`を用いない)書き方も出来てしまうのだが, `interface`を使うこと強く推奨する. なぜなら, メインプログラムの外で定義された関数やサブルーチンについてはコンパイラが(引数の数や型などの)呼び出し形式を知る方法が無いため, 間違った呼び出し方をしていてもコンパイルが通ってしまう. しかし不正な呼び出しをしているため, 当然実行時にはエラーが発生してプログラムが異常終了することになる. 一般的に実行時のエラーの方がコンパイルエラーよりも厄介でデバッグにも時間がかかるため, コンパイル時にチェックが可能な`interface`による宣言の方が良いのである^[初心者の頃はコンパイルエラーに辟易とすることが常であるが, コンパイルエラーでは一応コンパイラが(大変分かりにくくはあるものの)エラーメッセージを出力してくれるのに対して, 実行時のエラーは通常何のヒントにもならない無情な`Segmentation fault`のみである.]. (内部手続では文字通りメインプログラムの内部に定義されているので, コンパイラがメインプログラムをコンパイルする際に呼び出し形式のチェックが可能である.)

とにかく外部手続は(行儀よく使おうと思うと)面倒なので, 特に理由が無い限りは内部手続を用いる方が良い. どうしてもメインプログラムの外で手続を定義する必要がある場合にはモジュールを用いる方が間違いが少ないのである.

## 引数の詳細
### intent属性
関数は返値として値を返すことが出来るが, 返値はあくまでも一つだけである. 実用的には複数の値を結果として返して欲しい場合も多いが, そのような場合には引数に結果の値を代入して返すことが出来る^[他にも[構造型]を用いるという方法も無いこともない.]. このことからすぐ分かるように関数とサブルーチンには本質的な違いは無い. サブルーチンを使っても返したい値を引数に代入して返せば良いからだ. どちらを使うかは好みの問題であろう. (Fortranしか使わない人はあまり関数を使いたがらない傾向があるように思える. 一方でC言語では関数の返値はエラーチェックに使うことが多いので, C言語から入った人は関数を好むかもしれない.)

さて, 実際には引数で与えた変数の値を勝手に変更して欲しく無い場合もあるだろう. そのため, 以下のようにサブプログラムの定義時に引数の入出力特性を指定することが出来る.

- `intent(in)`

    入力用の変数に指定する. 値は内部で参照されるのみで変更はされない.

- `intent(out)`

    出力用の変数に指定する. サブプログラム中で値が代入されることを意味する.

- `intent(inout)`

    入出力のどちらにも用いる変数に指定する. 何も指定しない場合のデフォルト.


例えば以下のように引数に属性を指定することによって意図せず第1引数`a`や第2引数`b`の値が変更されてしまうバグを防ぐことが出来る.

```{style=f90}
  ! c = a + b
  subroutine add(a, b, c)
    implicit none
    real(8), intent(in)  :: a, b
    real(8), intent(out) :: c

    ! 以下はコンパイルエラー
    !a = 1.0_8

    ! 出力用の変数に値を代入
    c = a + b

  end subroutine add
```

C言語の経験者はC言語の関数の引数が値渡しなのに対してFortranの関数やサブルーチンでは参照渡しであることに注意して欲しい. C言語では明示的にポインタを(またはC++での参照を)渡さない限り呼び出し元の値が変更されることは無いが, Fortranではサブプログラム中で引数の値を変更すると呼び出し元の値まで変更されてしまうのである.

### 配列渡し
配列も同様に関数やサブルーチンに引数として渡すことが可能である. 以下の例の`average1`では任意のサイズの配列を渡すことが出来る. (ただし次元は予め指定しておく必要がある.) 配列のサイズや形状が必要であれば`size`や`shape`などの組込み関数を使って求めることが出来る. 一方で`average2`では配列サイズを引数として明示的に渡している. 配列の添字範囲を指定するなどの特別な事情が無い限りは`average1`のような書き方の方がシンプルで良い.

```{style=f90}
  ! 形状引継ぎ配列
  function average1(x) result(ave)
    implicit none
    real(8), intent(in) :: x(:)
    real(8) :: ave

    ave = sum(x) / size(x)

  end function average1

  ! 配列サイズを引数で渡す
  function average2(n, x) result(ave)
    implicit none
    integer, intent(in) :: n
    real(8), intent(in) :: x(n)
    real(8) :: ave

    ave = sum(x) / size(x)

  end function average2
```

### save属性
関数やサブルーチン内で`save`属性付きで宣言された変数は前回の呼び出し時の値を記憶しておくことが出来る(C言語のstatic変数と同等である). 従って, 例えば自分が呼び出された回数を保持することなどもできる.

`save`属性付きの変数はプログラムの開始時に一度だけ宣言文で代入された値に初期化される. 例えば以下のサブルーチン`fibonacci`ではプログラムの開始時に`n = 1`, `f0 = 0`, `f1 = 0`と値が初期化されるが, 呼び出しごとに値が変更され, プログラムが終了するまでその値を内部に保持し続ける.

```{style=f90}
  subroutine fibonacci()
    implicit none
    ! 以下の3つがsave属性付き(初期値を指定)
    integer, save :: n  = 1
    integer, save :: f0 = 0
    integer, save :: f1 = 0

    integer :: f2

    if (n == 1) then
       write(*,*) 'Fibonacci number [', 0, '] = ', f0
       f2 = 1
    else
       f2 = f0 + f1
    end if

    write(*,*) 'Fibonacci number [', n, '] = ', f2

    ! 次回呼び出し用
    n  = n + 1
    f0 = f1
    f1 = f2

  end subroutine fibonacci
```

なおFortranでは変数宣言時に同時に初期化を行うと, それを自動的に`save`属性付きと扱うようである. すなわち

```{style=f90}
  integer :: n = 1
```

と宣言された変数には自動的に`save`属性が付加されるため`n = 1`に初期化されるのは一度だけである. 一方で,

```{style=f90}
  integer :: n
  n = 1
```

では毎回`n = 1`に初期化される. 混乱を防ぐために`save`属性付きとしたい変数は明示的に`save`を指定し, それ以外の変数は宣言時の初期化は避けたほうが無難である.

### optional属性とキーワード引数^†^
引数の型宣言において`optional`属性を指定した引数は省略することが出来, その引数が与えられたかどうかを検査する`present`という関数と共に用いる. すなわち`present(引数)`は引数が与えられていれば真, そうでない場合には偽を返すので, `if`による条件分岐と組み合わせて用いれば良い. 以下の例では引数`unit`が与えられた場合にはその装置番号へ, 与えられていない場合は標準出力へと出力を行う.

```{style=f90}
subroutine hello(name, unit)
  implicit none
  character(len=*), intent(in)  :: name
  integer, intent(in), optional :: unit

  integer :: u

  if( present(unit) ) then
    u = unit ! unitを指定
  else
    u = 6    ! デフォルトは標準出力
  end if

  write(u,*) 'Hello ', name ! 表示

  return
end subroutine hello
```

これまで関数やサブルーチンを呼び出す際には定義時の引数ならびの順番通りに与えなければならなかった. しかしキーワード引数という機能を用いて, 順番を気にせず引数を与えることも可能である. (`open`文の使い方を思い出そう.) すなわち, 上で定義された`hello`を呼び出す際に

```{style=f90}
  call hello(unit=6, name='Albert')
  call hello(name='Einstein')
```

のように引数を"仮引数名 = 値"という形式で渡すことで, 引数の順番を意識せずに呼び出しが出来る. (`unit`は`optional`属性付きで宣言されているので省略することも出来る.)

なお, このようにキーワード引数の機能を用いるには内部手続きとして宣言するか, 外部手続きの場合には`interface`宣言で明示的に仮引数名を呼び出し側に知らせてやらなければならない. (やはり外部手続きは面倒である.)

## 再帰呼び出し(recursive)^†^
再帰呼び出しとは, 関数やサブルーチンの中で自分自身を呼び出すことである. このような再帰手続は明示的に`recursive`を用いて関数やサブルーチンを定義しなければならない. なお, 何も考えずに自分自身を呼び出すと簡単に無限ループになってしまうので, そうならないように注意しよう. 例えば以下は階乗の計算をする例である.

```{style=f90}
  recursive function fact(n) result(m)
    implicit none
    integer, intent(in) :: n
    integer :: m

    if(n == 1) then
       m = 1
    else
       m = n*fact(n-1)
    end if

  end function fact
```

ここで$n ! = n \times (n-1) !$という漸化式を用いている. ある種のアルゴリズムは再帰を使うと非常にスッキリと書くことができるので重宝することも多いだろう. ただし関数やサブルーチンの呼び出しそのものにもコスト(時間)がかかるので, 不用意に用いるとパフォーマンスのボトルネックになることもあるため注意して欲しい.

\clearpage

# 数値解析の基礎
これまでは主にプログラミングの作法を学んできた. 基本的には現在までの知識を組み合わせれば原理的にはどんな問題にも対応できるようになっている^[もちろん数学や物理, 更には数値解析の知識は必要になってくるわけだが, それはこれから学んでいくことになる.]. そこで, これまでに学んだ知識を用いてもう少し実践的な内容に取り組もう. 具体的には非線形方程式の求根法や, 関数の数値積分, また乱数の使い方などを扱う.

> サンプルプログラム
>
> - chap08/sample1.f90 : 桁落ちと情報落ち
> - chap08/sample2.f90 : 二分法
> - chap08/sample3.f90 : Newton法
> - chap08/sample4.f90 : 数値積分
> - chap08/sample5.f90 : 乱数

## 実数の精度と誤差
これまで何気なく用いてきた実数型だが, 数値解析を始める前に計算機における実数の取り扱いやその誤差について理解しておこう.

### 浮動小数点数の表現
実数は計算機の内部では浮動小数点数と呼ばれる形式になっており,

$$
x = \underbrace{(-1)^{s}}_{符号} \times
    \underbrace{(1.f)}_{仮数部(2進表現)} \times
    \underbrace{(2^{e-127})}_{指数部}
$$

のような表現で表される. 仮数部は有効桁を決める部分であり, 指数部は絶対値を調整するためのものである. 仮数部が$1.f$となっているのは(最上位ビットは常に1なので)実質1ビット分だけ精度を稼ぐためである(これをケチ表現と呼ぶ). 例えば標準的な規格(IEEE754規格)では単精度の場合, 符号部に1ビット, 仮数部に23ビット, 指数部に8ビットが割り当てられている. 指数部が8ビットであることから, $e=0, 1, \ldots, 255$であり, 即ち絶対値の範囲としては$2^{-127} \sim 10^{-38} \lesssim x \lesssim 2^{127} \sim 10^{+38}$程度以内の数値しか表現できない. また$\log_{10} (2^{23 + 1}) \sim 7.2$なので10進での有効桁数は7桁程度である. 同様に倍精度では符号部に1ビット, 仮数部に52ビット, 指数部に11ビットが割り当てられていることから絶対値の範囲は$2^{-1024} \sim 10^{-308} \lesssim x \lesssim 2^{+1024} \sim 10^{+308}$, 有効桁数は$\log_{10} (2^{52+1}) \sim 15.9$となり10進での有効桁数は16桁程度である.

### 丸め誤差
実数を有効桁で「丸め」て表現することから生じる誤差を丸め誤差と呼ぶ. これは場合によっては求めたい計算結果の精度に悪影響を及ぼすこともあるため, 注意が必要である.

+ 桁落ち

    絶対値の非常に近い2つの数の差を計算すると絶対値が非常に小さくなり, その分だけ相対誤差が大きくなってしまう. これを桁落ちと呼ぶ.

    例えば $\sqrt{1 + x} - 1$のような演算は$x$が非常に小さい場合にはその誤差が無視できない. 簡単のため10進数で有効桁数が5桁の場合を考えよう. $x=0.001$とすると, この精度の範囲では$\sqrt{1 + x} \approx 1.0005$なので, $\sqrt{1 + x} - 1 \approx 0.0005$となり有効桁数が1桁に低下してしまう. これは例えば以下のような式変形によって減算を無くすことで回避が可能である.

    $$
        \sqrt{1 + x} - 1 = \frac{x}{\sqrt{1 + x} + 1}
    $$

+ 情報落ち

    絶対値の大きい数に小さい数を加えてもほとんど変化が無い. これを情報落ちと呼ぶ.

    同様に有効桁数が5桁の場合を考えよう. $a = 1.0000$, $b = 1.0000 \times 10^{-5}$ はどちらとも5桁の有効桁数を持つが, $a + b = 1.00001$ の小数点第5位は精度は有効桁数の範囲外となるため, 情報が失われてしまう. 例えば, 総和計算の際に非常に大きな数と小さな数を多数加える場合にはこれが問題となることがある. このときには小さい方から順に和を計算することで回避できる.

丸め誤差の影響を調べるのに一番安直だが確実な方法は単精度から倍精度, 倍精度から4倍精度に精度を上げてみて結果が変わらないことを確認することである.

## 求根法
解析的には解けない方程式(非線形方程式)の解を求める方法を考えよう. 通常は右辺と左辺の両方に式があるわけだが, 移行してしまって
$$
 f(x) = 0
$$
という一般的な形にして解くことにしよう. 実はこの問題は意外と難しい問題であり, どんな問題にも使うことのできる汎用的で, かつ高速に解を求められるような手法は存在しない. と言うのはどんな手法であっても基本的には初期値として近似解のあたりを付けて, 少しずつ真の解に近づけていく反復法だからである. 初期値の選び方によっては正しい解に収束しない場合や, 欲しい解(例えば物理的な解)に収束しないもあり得る^[1変数ならまだ良いのだが, 多変数関数に拡張するとほとんどお手上げである.]. 計算機は初期値までは面倒を見てくれないので, 人間が適切な初期値を与えてあげなければならない. とりあえず初期値は与えられたとして, そこから近似解を反復によって求めるアルゴリズムを見ていこう.

### 二分法
もしある区間に解が1つあると分かっているならば, 反復によって近似解が必ず真の解に収束する, 二分法(bisection method)と呼ばれるアルゴリズムが知られいる. まず$[x_1, x_2] \ (x_1 < x_2)$に対して$f(x_1) < 0, f(x_2) > 0$ならばこのの区間に解があることが分かる. このとき, 二分法によって近似解を求める手順は以下のようなものとなる.

>  #. $x = (x_1 + x_2)/2$を近似解とする.
>  #. $f(x) < 0$なら$x_1 = x$, $f(x) > 0$なら$x_2 = x$とし, (1)に戻る.

この手順を解が収束するまで繰り返せばよい. 収束判定は例えば許容誤差を$\epsilon$として$|x_2 - x_1| < \epsilon$(区間の幅が許容誤差よりも小さい)などとすればよい.

実際には$f(x_1) > 0, f(x_2) < 0$の場合も考慮しなければならないが, 組み込み関数``sign``を用いてこれは簡単に実現出来る. 以下のコードには二分法の実装例を示している. ただし`f`は関数として定義されているものとする.

```{style=f90}
  sig = sign(1.0_8, f(x2)-f(x1))
  do n = 1, nmax
     x = (x1 + x2) * 0.5_8
     y = f(x)

     ! 収束判定
     if (abs(x2-x1) < tolerance) then
        exit
     end if

     ! 次の値を推定
     if (y*sig < 0.0) then
        x1 = x
     else
        x2 = x
     end if
  end do
```


### Newton法
二分法は解の含まれる範囲を正しく指定すれば必ず収束するという利点はあるものの, あまり収束の速いアルゴリズムではなかった. 一方で, 初期値によっては収束しないかもしれないが, 収束するならばその収束自体は速いというアルゴリズムも考えられる. それがここで紹介するNewton法と呼ばれるものである. これは$f(x)$に加えてその微分$f'(x)$も用いるのが特徴である. すなわち, 近似解$x$が与えられたときに$x$の周りでのテイラー展開した

$$
 f(x + \delta) \simeq f(x) + \delta f'(x) + O(\delta^2)
$$

を用いて, $f(x + \delta) = 0$とすると

$$
 \delta = - \frac{f(x)}{f'(x)}
$$

を得る. 即ち $x - f(x)/f'(x)$ を新しい近似解として採用すればよい. 大きな特徴は関数の値だけではなく, その微分値(接線)も用いて収束を加速している点である. しかし, 当然ながら初期値によっては収束しないことも十分に考えられる(どういった場合であろうか？). 以下のコードはNewton法のアルゴリズムを実装したものである. プログラムの構造は二分法の場合とほぼ同様であるが, 微分値を返す関数`df`も用いている.

```{style=f90}
  do n = 1, nmax
     ! 次の値の推定
     y  = f(x)
     dy = df(x)
     dx =-y / dy
     x  = x + dx

     ! 収束判定
     if (abs(dx) < tolerance) then
        exit
     end if
  end do
```

## 数値積分
次に関数の積分

$$
 S = \int_{a}^{b} f(x) d x
$$

の数値的な評価を考えよう. 区分求積法の原理を思い出せば, 積分領域$[a, b]$を小さな領域$h = (b-a)/N$に分割し, 積分を微小区間の積分の総和で近似すればよいことが分かるだろう. ここで分割数$N$を十分大きくとることができれば, 近似式の誤差は十分小さく抑えることができる. $x_j = a + j h$とし, 微小区間の端点$[x_{i}, x_{i+1}]$で与えられた関数値$f_{i}, f_{i+1}$から, 関数系を
$$
 f(x) = \frac{f_{i+1} - f_{i}}{h} (x - x_{i}) + f_{i}
$$
のように線形近似することで, 以下の*台形公式*が得られる.
$$
 S = \frac{h}{2} \left[ f(x_0) +
                       2 \sum_{j=1}^{N-1} f (x_{j}) + f(x_N) \right]
 + O(h^2).
$$
ここで$O(h^2)$は誤差が刻み幅$h$の2乗で小さくなることを意味する. ただし例外として, 元の関数系が線形であれば, 当然この評価は厳密な積分値を与える.

この考え方をさらに発展させ, $x_{i-1}, x_{i}, x_{i+1}$の3点の関数値$f_{i-1}, f_{i}, f_{i+1}$から関数系を2次関数で近似すれば, 以下の*Simpsonの公式*が得られる.
$$
 S = \frac{h}{3}
  \left[ f(x_0) + 4 \sum_{j=1}^{N/2} f(x_{2j-1}) +
   2 \sum_{j=1}^{N/2-1} f(x_{2j}) + f(x_N)
  \right]
 + O(h^4).
$$
ここでSimpsonの公式の誤差は$h$の4乗に比例する. 当然ながら同じ精度を実現するために必要な計算量はSimpsonの公式の方が台形公式よりも小さくて済む.

Fortranプログラム中では$f(x)$を関数として定義し, 分割数$N$を適当に定めれば`do`ループによって総和計算をすることで積分値は簡単に求まる. 例えば台形公式は以下のように実装することが出来る.

```{style=f90}
  integral = 0.5_8 * (f(x1) + f(x2))
  do n = 1, nmax-1
     integral = integral + f(x1 + dx*real(n,8))
  end do
  integral = integral * dx
```

ただし, ここで`f(x)`は被積分関数である.

## 乱数
確率的な現象を計算機を用いて模擬する際には乱数を用いることになる. ただし計算機で用いることのできる乱数は擬似乱数と呼ばれ, 乱数のように見えるが実際には決定論的な手法に基づき生成される数列である. 従って質の良い(周期の長い)乱数を用いなければ, 用途によっては乱数とみなすことのできない場合もあるため注意が必要である.

Fortranには乱数を発生させる組込みのサブルーチン`random_number`が存在する.

```{style=f90}
  call random_number(x)
```

とすれば`x`に区間$[0,1)$の一様乱数が代入される. `x`は実数型(単精度もしくは倍精度)であれば配列でも良い. 配列の場合は全ての要素に一様乱数が代入される.

擬似乱数は決定論的な数列であることは既に述べた通りであるが, その初期値を指定することも出来る. これは乱数のシード(seed)と呼ばれ, 組込みのサブルーチン`random_seed`を用いて行うことが出来る. 使い方は

#. シードを格納領域のサイズを取得(サイズはコンパイラ依存)
#. 必要な領域を確保(`allocate`を用いる)
#. シードを指定

といった流れとなる. 以下のサブルーチン`random_seed_clock`は計算機の時刻^[Unix系OSの場合は1970年1月1日からの経過時間.]に応じてシードを指定するものであり, これを用いれば実行する度に(時刻が異なるので)得られる乱数値が異なることが保証される. 逆に固定のシードを用いるようにしておくと毎回同じ結果が得られるため, 乱数を用いるプログラムをデバッグする際には都合が良い.

```{style=f90}
  subroutine random_seed_clock()
    implicit none
    integer :: nseed, clock
    integer, allocatable :: seed(:)

    ! システムクロックを取得
    call system_clock(clock)

    call random_seed(size=nseed)
    allocate(seed(nseed))

    seed = clock
    call random_seed(put=seed)

    deallocate(seed)
  end subroutine random_seed_clock
```

\clearpage

# モジュールと構造型
これまでに既に[関数とサブルーチン]ではプログラムの開発を容易にするための手段として, 関数やサブルーチンといったサブプログラムを用いる方法を学んだ. これらサブプログラムは機能を分割し, 1つの独立したプログラム単位として扱われる. ところがプログラムの規模が大きくなってくると, 関数やサブルーチン群を用いるだけでは必ずしも十分とは言えなくなって来る. そのような場合に便利になってくる*モジュール*という機能について学ぼう.

モジュールも独立したサブプログラムであるが, 関数やサブルーチンなどよりも*1段階大きなプログラム単位*として考えることができる. すなわち, 複数の関連する機能を提供する関数やサブルーチン群を1つのモジュールにまとめて提供することが出来る. さらに関数やサブルーチンと大きく異なり, モジュール内部に宣言された変数に外部からアクセスすることも出来るため, 複数の変数群をまとめる役割も果たす. またモジュールと共に用いると便利な*構造型*の使い方も身につけよう. 構造型はいくつかのデータを1つにまとめて, 新しいユーザー定義型を提供する機能である.

> サンプルプログラム
>
> - chap09/sample1.f90 : 定数や変数の参照
> - chap09/sample2.f90 : 内部手続き
> - chap09/sample3.f90 : 総称名
> - chap09/sample4.f90 : アクセス制限
> - chap09/sample5.f90 : 構造型と演算子オーバーロード

## モジュールの基本
既に述べたようにモジュールは1つの独立したプログラム単位である. その特徴は以下の様な点である.

  - モジュール内で変数宣言が出来, それらの変数はモジュール内部からはもちろん他のモジュールやメインプログラムから使用することが出来る.
  - 複数の関数やサブルーチンをモジュール内で内部手続きとして定義することが出来る. 内部手続きはモジュール内部の他の内部手続きや, モジュール外部から呼び出すことも出来る.

モジュールの定義は以下のような形で行う.

```{style=f90}
module モジュール名
  implicit none

  変数宣言など

contains

  内部手続きの定義

end module モジュール名
```

モジュールの構造はメインプログラムと非常に似ており, `module`で始まり, `end module`で終わる. また内部手続きは`contains`から`end module`の間に定義する. ただしメインプログラムに記述されたコードは上から順に実行されていくのに対して, モジュール内(`implicit none`から`contains`までの間)には実行文は記述せず, 変数宣言などを行うだけである. 内部手続きについても明示的に呼び出されない限りは実行されることは無い.

定義したモジュールはメインプログラムや, サブルーチン, 関数などから参照して用いることが出来る. 使い方は`implicit none`を記述する前に`use`によって使いたいモジュールを記述するだけである.

例えばメインプログラムからモジュールを使用するには

```{style=f90}
program プログラム名
  use モジュール名
  implicit none

  メインプログラムの処理

end program プログラム名
```

というような形となる.

## 変数や定数の参照
モジュールを用いると変数や定数の宣言を共通化し, 異なるモジュールやメインプログラムから利用することが出来る. 大規模プログラムで共通の変数が複数のモジュールなどから参照される場合には変数宣言を共通化しておくと良い. 具体的には以下の例の様になる.

```{style=f90}
! モジュールの定義
module mod_variable
  implicit none

  ! 定数の定義
  real(8), parameter :: light_speed = 2.998e+08 ! 光速 [m/s]
  real(8), parameter :: kboltzmann  = 1.381e-23 ! Boltzmann定数 [J/K]
  real(8), parameter :: hplanck     = 6.626e-34 ! Planck定数 [J s]

  ! 変数
  real(8), save :: x, y, z

end module mod_variable

! メインプログラム
program sample
  use mod_variable
  implicit none

  ! 定数の値は参照のみ可能
  write(*, '(a20, ":", e12.4)') 'speed of light', light_speed
  write(*, '(a20, ":", e12.4)') 'Boltzmann constant', kboltzmann
  write(*, '(a20, ":", e12.4)') 'Planck constant', hplanck

  ! これはできない(コンパイルエラー)
  !light_speed = 1.0_8

  ! 変数の値は変更可能
  x = 1.0
  y = 0.0
  z = 0.0

  stop
end program sample
```

プログラム実行中に常にどこからでもアクセスできる変数を*グローバル変数*, サブルーチンや関数の内部でしか用いない変数を*ローカル変数*などと呼ぶことがある. 上の例ではモジュールの内部変数がグローバル変数として用いられている. この例のように, 一般にはモジュール変数をグローバル変数として用いるには`save`属性を付けておく方が良い. 例えば上の例で変数`x`, `y`, `z`の宣言を

```{style=f90}
  real(8) :: x, y, z
```

としてしまうと, 複数のサブルーチンや関数などから`use`で参照される場合に, その都度これらの値が書き換えられてしまう(初期化される)可能性がある. (例えばメインプログラムから1度だけ`use`で参照される場合にはこのような問題は生じない.) 最近のコンパイラは自動でモジュール内変数に`save`属性が指定されたものと扱う場合が多いようなので, これは必ずしも必須ではないかもしれない. ただしコンパイラ依存性を無くし, 移植性の高いプログラムとするためには指定しておいた方が無難であろう. なお, いずれにせよ定数変数については参照されるだけなので`save`属性は必要ない.

一般に, プログラムが複雑化して来ると*グローバル変数がバグの原因*になりやすくなるため, 使わない方が良いとされている. グローバル変数を一切使わない場合にはメインプログラムで全ての変数を宣言し, 必要な変数を各サブルーチンや関数へ全て引数として渡せば良い. この場合にはデータの受け渡しが明示的に行われるので, 意図せずデータが変更されるのを防ぐことが出来る. ただしこれはあくまで一般論であり, いつでもグローバル変数の使用を避けるべきというわけではない. 比較的単純で, データの受け渡しを間違いそうに無いようなプログラム(比較的小規模の数値シミュレーションコードはこれに当てはまる場合が多い)であればグローバル変数を用いた方がスッキリ書けるような場合も多い. ただし, この場合でもグローバル変数にしても問題無い変数と, ローカル変数にすべき変数はよく考えて区別しておいた方が良い. 何でもかんでもグローバル変数にしてしまうと汎用性の無いプログラムになってしまい, 仕様変更に伴うプログラムの修正が非常に困難になる.

例えば以下の例を考えよう. ここでは変数`i`をモジュール`mod_global`内で定義されたグローバル変数として用いている. メインプログラムの内部手続きとして定義されたサブルーチン`sub`内の`do`ループでも, メインプログラムでも変数`i`をループ変数として用いている. `gfortran`でこのプログラムをコンパイルして実行すると, 無限ループになってしまうようである(この動作はコンパイラに依存するかもしれないが, いずれにせよ「意図した通り」には動かない). これはメインプログラムから`sub`を3回呼び出すつもりでも, `sub`内部で変数`i`の値が更新され, メインプログラムの`do`ループの反復が正しく終了しないためであろう. これは極端な例ではあるが, 特にループ変数のように不用意に使ってしまいそうな名前の変数はローカル変数にして, 必要な場合にその都度宣言して用いる方が安全である.

```{style=f90}
module mod_global
  implicit none

  ! グローバル変数
  integer, save :: i

end module mod_global

program main
  use mod_global
  implicit none

  ! グローバル変数iでループを回す
  do i = 1, 2
     call sub() ! この中でiが更新されてしまう!!
  end do

  stop
contains
  subroutine sub()
    implicit none

    ! ここでもグローバル変数iでループを回す
    do i = 1, 3
       write(*,*) i
    end do

  end subroutine sub
end program main
```

## 内部手続き
メインプログラムと同様に, モジュールにも内部手続きを定義することが可能であり, またモジュールの内部手続きからモジュール内で定義された変数には自由にアクセスすることが出来る(これもメインプログラムの内部手続きと同様である). `use`でモジュールの使用を宣言すると, モジュールの変数だけでなく内部手続きも同様に用いることが出来る. このようにモジュールは関連する変数と手続きをまとめることが出来るため, サブルーチンや関数よりも大きなプログラム単位を提供することになる.

例えば以下のモジュール`mod_integrator`は予めサンプリングされた関数値の配列と刻み幅を受け取り, [数値積分]で扱った台形公式およびSimpsonの公式を用いて数値積分する関数を内部手続きとして実装したモジュールである. このように関連するサブプログラムをまとめてモジュールの内部手続きとして実装しておけば, `use mod_integrator`するだけで(外部手続きの時のように`interface`による準備をしなくても)安全に利用することが出来る. これから分かるように, [内部手続きと外部手続き]で外部手続きを非推奨としたのは, 単純に外部手続きを何らかのモジュールの中に入れて(内部手続きとして定義して)しまえば良いからである. これによって外部手続きの抱える問題は全て解決する.

```{style=f90}
module mod_integrator
  implicit none

contains
  !
  ! 台形公式による数値積分
  !
  function trapezoid(f, dx) result(ret)
    implicit none
    real(8), intent(in) :: f(:)
    real(8), intent(in) :: dx
    real(8) :: ret

    integer :: i, n

    n = size(f)

    ret = 0.5_8 * (f(1) + f(n))
    do i = 2, n-1
       ret = ret + f(i)
    end do
    ret = ret * dx

  end function trapezoid

  !
  ! Simpson公式による数値積分
  !
  function simpson(f, dx) result(ret)
    implicit none
    real(8), intent(in) :: f(:)
    real(8), intent(in) :: dx
    real(8) :: ret

    integer :: i, n

    n = size(f)

    ! 端点を含めた配列サイズが奇数でなければエラー
    if( mod(n, 2) == 0 ) then
       write(*,*) 'array size must be odd'
       stop
    end if

    ret = f(1) + f(n)
    ! even
    do i = 2, n-1, 2
       ret = ret + 4.0_8 * f(i)
    end do
    ! odd
    do i = 3, n-2, 2
       ret = ret + 2.0_8 * f(i)
    end do
    ret = ret * dx / 3.0_8

  end function simpson
end module mod_integrator
```

## 総称名
これまでは何も意識せずに単精度で宣言された`x`に対しても, 倍精度で宣言された`x`に対しても`sin(x)`のように型の精度を気にせず組み込み関数を呼び出しをしてきたことと思う. しかし自分で定義した関数やサブルーチンについては, 正確に宣言した型を引数として呼び出す必要があった. 実はその昔のFortran 77の時代には単精度に対して`sin(x)`, 倍精度に対しては`dsin(x)`というように, 組み込み関数にも精度ごとに異なる関数が用意されていて, 手動で使い分ける必要があった(ここで`d`は倍精度を表すdoubleの意味である). これでは明らかに不便である.

Fortran 90以降では, この問題を解決するために, 内部手続きに対して総称名(オーバーロード)という便利な機能を用いることが出来るようになった^[実は総称名はモジュールに限らず, メインプログラムの内部手続きでも用いることが出来る. その場合あまりありがたみは感じないかもしれないが.]. これを用いると, 呼び出し形式(引数の数や型)が異なる複数の関数やサブルーチンを同じ名前で呼び出すことが出来る. 先ほどの`sin(x)`の例で言えば, 引数`x`が単精度実数であれば単精度版を, 倍精度であれば倍精度版の関数を自動的に選択して呼び出すことになる. 自分で定義した関数やサブルーチンについても, この総称名の機能を用いることが出来る.

これにはモジュールの変数宣言部分で

```{style=f90}
  interface 総称名
    module procedure 個別名1, 個別名2
  end interface 総称名
```

のように`interface`を用いて総称名を宣言すれば良い. 個別名としては呼び出し形式の異なる(形式が同じだとコンパイラが判別出来ない!)複数の関数やサブルーチンをカンマで区切って記述する. これによって複数のルーチンを単一の名前で呼び出すことが出来る. コンパイラは総称名で呼び出されたルーチンについて, その呼び出し形式に応じて自動的に適切なものを選択する. 具体的な使い方は以下の例を見て欲しい.

```{style=f90}
! 面積を計算するモジュール
module mod_area
  implicit none

  real(8), parameter :: pi = 4*atan(1.0_8)

  ! 総称名を定義
  interface triangle
     module procedure triangle1, triangle2
  end interface triangle

contains

  ! 底辺と高さが与えられた時の面積の計算
  function triangle1(a, b) result(area)
    real(8), intent(in) :: a, b
    real(8) :: area

    area = a * b / 2

  end function triangle1

  ! 3つの頂点の座標が与えられた時の面積の計算
  function triangle2(x1, y1, x2, y2, x3, y3) result(area)
    real(8), intent(in) :: x1, y1, x2, y2, x3, y3
    real(8) :: area

    area = abs((x2-x1)*(y3-y1) - (x3-x1)*(y2-y1))/2

  end function triangle2

end module mod_area
```

この例では三角形の面積を底辺と高さが与えられた時と3つの頂点の座標が与えられた時のいずれも同じ関数名で呼び出すことが出来るように総称名`triangle`を宣言している. 2つの違いは呼び出し時の引数だけなので, 呼び出される時の引数の個数や型によってコンパイラが自動的に適切な方を呼び出すことが出来る. なお, 総称名を用いると全く別の機能を実装したものであってもまとめることが出来てしまうのだが, このような使い方は混乱の元になるだけであろう. 総称名を使うのは意味的に同じ機能を持った関数やサブルーチンをまとめる時にのみにしておいた方が良い.

## アクセス制限
モジュールを用いるために`use`すると, モジュール内で定義された変数, 関数, サブルーチンに自由にアクセスできるが, これは一般的にはあまり好ましいことでは無い. 例えば, [変数や定数の参照]では不用意にグローバル変数を作るとバグの元になることを示した. これはモジュールの利用者がモジュール内部の詳細を知らないために起こる問題である.

しかし, そもそもモジュールを利用する側はモジュール内部の詳細について知らないことが一般的であるし, そうあってしかるべきである. すなわち, モジュールを提供する側はそのモジュールと外部のインターフェースのみを提供し, 内部の実装の詳細については公開しないという立場を取る方が懸命である. これには主に以下の2つの理由が挙げられる.

+ モジュールを利用する立場からは, モジュール内で定義された変数名などで名前空間が汚染されてしまい, 同じ名前の変数やルーチンを宣言出来なくなる.
+ モジュールを提供する立場からは, モジュール内部で用いている変数などが不用意に変更されてしまう可能性がある. 例えば何らかの状態を保持する変数が利用者から意図せず変更されてしまうと動作がおかしくなるかもしれない.

[関数とサブルーチン]で学んだことは, それらをブラックボックスとして用いることで間違いを減らすことが出来るということであった. モジュールについても基本的に考え方は同じであって, せっかく機能を分割してモジュールを実装したのならば利用する時にはその中身のことは忘れたい. 特に規模が大きなプログラムを複数人体制で開発する際には他人が実装したモジュールの中身など知る由も無いし, 知りたくも無いであろう. いたずらに守備範囲を広げてエラーするくらいなら, 狭くても良いから自分の守備範囲だけは死守する方が守りは固くなるのである.


### 参照先からのアクセス制限
まずは参照先(モジュールの利用者の側)からのアクセス制限について学ぼう. 一部の変数やルーチンへのアクセスしか必要無い場合には, `use`宣言の際に`only`を用いてそれ以外の名前を参照先からは無効にする(見えないようにする)ことが出来る. 例えば[変数や定数の参照]の`mod_variable`から`light_speed`だけを用いたい場合には

```{style=f90}
  use mod_variable, only : light_speed
```

のように`only : `に続けて必要な変数名やルーチン名をカンマで区切ってリストすれば良い. また`light_speed`を別名で使いたい場合には

```{style=f90}
  use mod_variable, only : c => light_speed
```

のようにすることで, `light_speed`の代わりに`c`という名前でアクセスすることが出来る. (ただしあくまで別名なので実態は`light_speed`のままである.) これによって, 例えばモジュール内部の変数と同じ名前の変数を参照先で使いたい場合に, 名前の競合を避けることが出来る.

### 参照元からのアクセス制限
参照先からのアクセス制限は言わば性善説の立場に立ったアクセス制限である^[モジュール利用者がモジュール内部の処理に悪影響を与えないように振る舞ってくれればこれでも良いのだが, 過度の期待は禁物である.]. それに対して, 性悪説の立場に立った, モジュールを提供する側からのアクセス制限も可能である.

モジュール内部で宣言された変数やルーチンには`public`や`private`などの属性を与えることが出来, この属性によってアクセス制限をすることが出来る. すなわち, `private`属性が指定された変数やルーチンはモジュール外からは直接見えず, 内部からのみアクセスが可能になる. 一方で, `public`属性が指定されたものは公開され, 外部から自由にアクセスすることが出来る. Fortranのモジュールでは`public`がデフォルトである.

原則としてモジュールの内部でしか用いられないものは外部には公開しない方が良い. 例えば以下のモジュールを考えよう.

```{style=f90}
module mod_sample
  implicit none

  integer :: l, m, n

end module mod_sample
```

いかにも他で使いそうな`l`, `m`, `n`という変数をモジュール内で宣言している. 例えばメインプログラムからこのモジュールを利用する際に, 他の用途に使おうと思ってこれらと同じ名前の変数を宣言するとコンパイルエラーとなってしまう. 実はコンパイルエラーを出してくれればまだ良い方なのであって, メインプログラムで変数宣言を忘れた場合にはこれらの変数が普通に使えてしまう. モジュールの変数だと意識して使っていれば問題は無いのだが, そんなことはお構いなしに全く違う用途に使って値を書き換えてしまうと, モジュール内部でこれらの変数に依存しているようなコードは動作がおかしくなってしまうかもしれない. 公開する必要が無いものは予め非公開にしておけば, このような不用意なバグの混入を未然に防ぐことが出来るのである. `public`と`private`の指定方法はいくつかあって, 個別に指定する場合は

```{style=f90}
  integer, private :: l, m, n
```

のように変数宣言時に属性を指定することが出来る. または

```{style=f90}
  integer :: l, m, n

  private :: l, m, n
```

のように別に指定することも可能である. なお, 内部手続きの公開設定についても上の3行目のような形で手続名を並べれば良い. デフォルトで非公開としたい場合にはモジュール宣言の最初(`implicit none`の後)に`private`を指定しておけば, 明示的に`public`属性を付けない限りは非公開となる. 実用的なプログラムではデフォルトを非公開の設定にし, 必要な物だけに`public`属性を指定することを強く推奨する.

以下は単位変換付きの物理定数モジュールの例である. デフォルトで`private`にすることでモジュール内部の変数には直接アクセス出来ないようし, その代わり必要な定数の値を返す関数を`public`にしてある. アクセスする手段(インターフェース)を敢えて限定することで, 単位系のモード(`unit`)に応じて物理定数の値が自動的に切り替わるようになっている^[このように内部データを敢えて隠ぺいする(外から見えないようにする)ことをカプセル化(encapsulation)と呼ぶ. これは現代的なオブジェクト指向プログラミングの基本的な概念である.].

```{style=f90}
! 物理定数モジュール
module mod_const
  implicit none
  private ! デフォルトで非公開

  ! 単位選択フラグ: 1 => MKS, 2 => CGS
  integer, save :: unit = 1

  real(8), parameter :: pi  = 4*atan(1.0_8)
  real(8), parameter :: mu0 = 4*pi * 1.0e-7_8

  ! MKS => CGS への変換ファクター
  real(8), parameter :: T = 1.0e+0_8
  real(8), parameter :: L = 1.0e+2_8
  real(8), parameter :: M = 1.0e+3_8

  ! MKSで定義
  real(8), parameter :: mks_light_speed       = 2.997924e+8_8
  real(8), parameter :: mks_electron_mass     = 9.109382e-31_8
  real(8), parameter :: mks_elementary_charge = 1.602176e-19_8

  ! これらのみ公開
  public :: set_mks, set_cgs
  public :: light_speed, electron_mass, elementary_charge

contains

  ! MKSモード
  subroutine set_mks()
    implicit none

    unit = 1
  end subroutine set_mks

  ! CGSモード
  subroutine set_cgs()
    implicit none

    unit = 2
  end subroutine set_cgs

  ! 光速
  function light_speed() result(x)
    implicit none
    real(8) :: x

    if( unit == 1 ) then
       x = mks_light_speed
    else if ( unit == 2 ) then
       x = mks_light_speed * L/T
    else
       call unit_error(unit)
    end if

  end function light_speed

  ! 電子質量
  function electron_mass() result(x)
    implicit none
    real(8) :: x

    if( unit == 1 ) then
       x = mks_electron_mass
    else if ( unit == 2 ) then
       x = mks_electron_mass * M
    else
       call unit_error(unit)
    end if

  end function electron_mass

  ! 素電荷
  function elementary_charge() result(x)
    implicit none
    real(8) :: x

    if( unit == 1 ) then
       x = mks_elementary_charge
    else if ( unit == 2 ) then
       x = mks_elementary_charge * light_speed() * sqrt(mu0/(4*pi) * M * L * T**2)
    else
       call unit_error(unit)
    end if

  end function elementary_charge

  ! エラー
  subroutine unit_error(u)
    implicit none
    integer, intent(in) :: u

    ! 標準エラー出力へ
    write(0,'(a, i3)') 'Error: invalid unit ', u

  end subroutine unit_error

end module mod_const
```

## 構造型
これまで扱ってきた`integer`や`real`のような組込み型だけで無く, 新しいデータ型を自分で定義して用いることもできる. これを*構造型*と呼ぶ^[Fortran 2003以降では派生型と呼ばれるらしい. (オブジェクト指向プログラミングをサポートしたからであろう.)]. 構造型は組込み型やその配列はもちろん他の構造型を要素に持つことも出来る.

### 定義と使い方
構造型は以下の様な形式で定義される.

```{style=f90}
  type :: 構造型の名前
    型名 :: 要素名
    ...
  end type 構造型の名前
```

組み込み型と同様に, 定義した構造型の変数を以下のように宣言することによって使うことが出来る.

```{style=f90}
  type(構造型の名前) :: 変数名
```

例えば以下の例では, 倍精度実数型の`x`, `y`を要素に持つ新しい構造型`vector2`を定義して用いている.

```{style=f90}
  ! 2次元のベクトル
  type :: vector2
    real(8) :: x, y
  end type vector2

  ! 構造型の変数を宣言
  type(vector2) :: a

  ! '%'を用いて各要素にアクセスが出来る
  a%x = 1.0_8
  a%y = 0.0_8
```

構造型の各要素にアクセスするには上の例のように"`%`"を用いれば良い. 構造型を用いると, 常にセットで必要になるような複数のデータをまとめて保持することが出来るので, 上手く利用すればプログラムが非常に見やすくなる. 例えば非常に多くの引数を必要とするサブルーチンでも, 構造型を利用してデータをまとめることで引数の数を減らして, スッキリとした形に書き換えることが出来るだろう^[もっともこれは好みの問題であって, 引数が山ほどあるサブルーチンの方が分かりやすいという人もいるかもしれない.].

### ユーザー定義演算子
構造型の機能として特筆すべきは, 構造型に対する演算子を自分で定義することが出来るという点である. これをユーザー定義演算子と呼ぶ. 演算子の定義は以下のように総称名の場合とほぼ同様である.

```{style=f90}
  interface operator (演算子記号)
     module procedure 演算子の実態の関数名
  end interface operator (演算子記号)
```

演算子記号は`+`, `-`, `*`, `/`という組込み型に対して定義されている演算子か, または`.operator.`のように両側をピリオドで挟んだ名前のいずれかである. 例として, ベクトル同士の和を各要素同士の和として`+`演算子を定義しよう. 以下の関数は2つのベクトルを引数に受け取り, 要素同士の和を計算したものを結果として返す.

```{style=f90}
  ! + 演算子の中身
  function add2(a, b) result(ret)
    implicit none
    type(vector2), intent(in) :: a, b
    type(vector2) :: ret

    ret%x = a%x + b%x
    ret%y = a%y + b%y
  end function add2
```

これを`interface`を用いて

```{style=f90}
  interface operator (+)
     module procedure add2
  end interface operator (+)
```

のように宣言しておくことで`type(vector2)`の変数`a`, `b`の和を`a + b`のように記述することが出来る. この`+`演算子の計算の実態は上の`add2`という関数である.

また演算子についても総称名を用いることが出来る. すなわち`add2`は引数が2つとも`type(vector2)`であったが, 例えばどちらか片方が実数型の場合の処理も定義して`interface`宣言に加えておくことで, `+`演算子を総称名として用いることが出来る. これを演算子のオーバーロードと呼ぶ.

例えば, 先ほどの`add2`に加えて`add2_scalar1`, `add2_scalar2`の2つの関数を`interface`に加えておく.

```{style=f90}
  interface operator (+)
     module procedure add2, add2_scalar1, add2_scalar2
  end interface operator (+)
```

ここで`add2_scalar1`, `add2_scalar2`はそれぞれ以下のように定義されたものとする.

```{style=f90}
  ! + 演算子の中身: vector2 + scalar
  function add2_scalar1(a, b) result(ret)
    implicit none
    type(vector2), intent(in) :: a
    real(8), intent(in) :: b
    type(vector2) :: ret

    ret%x = a%x + b
    ret%y = a%y + b
  end function add2_scalar1

  ! + 演算子の中身: scalar + vector2
  function add2_scalar2(a, b) result(ret)
    implicit none
    real(8), intent(in) :: a
    type(vector2), intent(in) :: b
    type(vector2) :: ret

    ret%x = a + b%x
    ret%y = a + b%y
  end function add2_scalar2
```

このようにしておけば, `vector2`型と倍精度実数型の`+`演算が可能になる. この時, `a + 1.0_8`のような演算では`add2_scalar1`が, `0.5_8 + a`のような演算では`add2_scalar2`が自動的に呼び出されることになる.

### ユーザー定義代入文
代入文(`=`)に関しては, ユーザー定義演算子とは少し事情が異なるのでここで触れておく. まず代入文は, 同じ構造型同士であればデフォルトで使用可能である(例えば`type(vector2)`型の変数同士で`a = b`としても良い). この場合は, 構造型の各要素で単純に代入文が実行される. 異なる型同士での代入には, ユーザー定義代入文の定義が必要である. (明示的に指定しない限り, コンパイラには何が正しい代入動作か判断出来ないため.)

ユーザー定義演算子と異なり, 代入文の実態はサブルーチンを用いて定義する.

```{style=f90}
  ! = 中身
  subroutine assign2(a, b)
    implicit none
    type(vector2), intent(out) :: a ! intent(out) に注意
    real(8), intent(in)        :: b ! intent(in)  に注意

    ! どちらも同じ値
    a%x = b
    a%y = b
  end subroutine assign2
```

このサブルーチンを代入文として用いるには以下の様な`interface`宣言を行う.

```{style=f90}
  interface assignment (=)
     module procedure assign2
  end interface assignment (=)
```

これによって`a = 0.0_8`のように, `=` の右辺と左辺が異なる型の変数の場合であっても代入を行うことが出来るようになる. これにも総称名を用いてオーバーロードすることが可能である.

\clearpage

# 付録

> サンプルプログラム
>
> - cahp10/sample1.f90   : 分割コンパイル用サンプル
> - chap10/sample1a.f90  : 分割コンパイル用サンプル(モジュールA)
> - chap10/sample1b.f90  : 分割コンパイル用サンプル(モジュールB)
> - chap10/sample2.f90   : GUIライブラリの使い方
> - chap10/sample3.f90   : 二分法モジュール(mod_bisection)の使い方
> - chap10/bisection.f90 : 二分法モジュール(mod_bisection)の実装
> - chap10/sample4.f90   : 計算時間の測定
> - chap10/sample5.f90   : ポインタの使い方
> - chap10/sample6.f90   : リストモジュール(mod_list)の使い方
> - chap10/list.f90      : リストモジュール(mod_list)の実装
> - chap10/sample7.f90   : プリプロセッサの使い方

## 大規模なプログラム開発
### 分割コンパイル
これまでは基本的に単一のソースファイルからなるプログラムを扱ってきたが, 大規模なプログラムを扱う際にはソースファイルをいくつかに分割して扱うと開発の見通しが良くなる. 複数のソースファイルからなるプログラムを開発するにあたって, まずは単一のソースファイルから実行形式のファイルを作る手順を復習しよう. これまでは例えば

```{style=shell}
 $ gfortran sample.f90
```

によってソースファイルから実行ファイル`a.out`を作成してきた. これは実際には*コンパイル*と*リンク*という2つのステップを同時に行うものである.

コンパイルとはソースファイルを解釈し, 機械語に変換する作業である. 機械語に変換されたファイルを*オブジェクトファイル*と呼び, 通常は拡張子 `.o` が用いられる. オブジェクトファイルを生成するには

```{style=shell}
 $ gfortran -c sample.f90
```

のように`-c`オプションを付けてコンパイルする. この結果, この例では`sample.o`が生成される. 生成されたオブジェクトファイルは機械語になってはいても, 実際にプログラムを実行可能な形式にはなっておらず, 関数やサブルーチンなどの単位で個別に機械語になっているだけである. 実行形式に変換するには, それらの自分で実装したものに加え, 組み込み関数(`read`, `write`なども実際には組み込み関数の1種である)などを連結する作業が必要である. 組み込み関数などのまとまりを標準ライブラリと呼び, この連結作業をリンクと呼ぶ.

オブジェクトファイルをリンクするには

```{style=shell}
 $ gfortran sample.o
```

とすればよい. この例では`sample.o`と標準ライブラリがリンクされ, 実行可能なファイル(この例では`a.out`)が生成される.

次に複数のファイルからなるプログラムの場合を考えよう. 例えばメインプログラムが定義されている`sample1.f90`が`sample1a.f90`に, また`sample1a.f90`が`sample1b.f90`に依存している場合には

```{style=shell}
 $ gfortran sample1b.f90 sample1a.f90 sample1.f90
```

のようにすれば, コンパイルとリンクを1つのコマンドで同時に実行することができる(順番に注意). これは実際には以下のように各ファイルを個別にコンパイルし, 最後に全体をリンクする作業に相当する.

```{style=shell}
 $ gfortran -c sample1b.f90
 $ gfortran -c sample1a.f90
 $ gfortran -c sample1.f90
 $ gfortran sample1b.o sample1a.o sample1.o
```

リンク時には与えられた全てのオブジェクトファイルに加えて, 常に標準ライブラリがリンクされる.

このように分割コンパイルを用いる利点は, コンパイル時間の短縮にある. 個別にコンパイルが出来るので, ソースファイルを更新した場合には, その必要なファイルだけを再コンパイルすれば良い. なお, リンクにかかる時間は通常短く, コンパイル時間に対しては無視できる. 従って, 頻繁に修正をしながらテストする場合などでは, 実行ファイルの作成にかかる時間を短縮できることになる.

なお, Fortranでモジュールを用いる場合は`gfortran -c`によるコンパイルで`.mod`という拡張子のファイル(例えばモジュール名が`test`なら`test.mod`)が生成される. 別ファイルのモジュールを利用する際には, この`.mod`ファイルが無いとコンパイル出来ないので注意しよう^[これはFortranの規格というわけではないようだが, 多くのコンパイラがこのような仕様になっている.]. また他のディレクトリに`.mod`ファイルがある場合には, `-I`オプションを用いてコンパイラが`.mod`ファイルを探す場所を指定することが出来る^[C言語のインクルードパスの指定と同じである.].

```{style=shell}
 $ gfortran -c -I../module sample.f90
```

のように実行すれば, カレントディレクトリに加えて`../module`にある`.mod`ファイルも参照することになる. 規模が大きなプログラムではいくつかのディレクトリにファイルを分散して配置するようになるため, `-I`オプションを頻繁に用いることになるだろう.

### ライブラリの利用方法
一般に, 関数やサブルーチン群をひとまとまりにしたものをライブラリと呼ぶ. これまでにも組み込み関数などの標準で用意されている便利な機能を利用してきたが, これは標準ライブラリが提供するものである. これと同じように, 他の誰かが開発した便利な関数やサブルーチンを自分のプログラムから呼び出して利用することも出来る.

ライブラリは通常(Unix系のOSでは)`libABC.a`や`libXYZ.so`といったファイル名になっている(これらをアーカイブとも呼ぶ). 基本的には実行形式のファイルを作成するリンク時にこれらのライブラリともリンクするように指定してやれば良い. 例えば

```{style=shell}
 $ gfortran main.o -lABC -lXYZ
```

とすれば`libABC.a`, `libXYZ.so`の両方とリンクすることが出来る. このようにライブラリとリンクするには, 拡張子とファイル先頭の`lib`を除いたライブラリ名を`-l`オプションに渡せば良い. ただし, ライブラリファイルがあるディレクトリがカレントディレクトリや標準の場所(通常`/usr/lib`や`/usr/local/lib`など)以外の場合にはその場所を`-L`オプションで明示的に指定してやらなければならない. 以下の例では`libABC.a`が`../lib`にあるの場合に, それを明示的に指定してリンクを実行する.

```{style=shell}
 $ gfortran main.o -L../lib -lABC
```

### GUIプログラムの作成^†^
<!--
数値計算関係のライブラリはこれからも多々使う機会があると思うので, ここではちょっと違った例としてGUI(Graphical User Interface)のライブラリを使ってみよう. GUIのライブラリは様々なものが存在するが, ここではFortranから使えるGTK+を用いる. サンプルプログラム`samle2.f90`をコンパイルするには

```{style=shell}
 $ gfortran sample2.f90 `pkg-config --cflags --libs gtk-2-fortran`
```

のようにすれば良い.
-->

### Makeの使い方
To be written.

## 関数やサブルーチンの引数渡し
関数やサブルーチンの引数として, 関数やサブルーチンを渡すことが出来る. これには以下のように引数として渡す関数やサブルーチンの形式を`interface`を用いて指定する.

```{style=f90}
  subroutine writefunc(f, x)
    implicit none
    real(8), intent(in) :: x

    ! 引数として受け取る関数の形式
    interface
       function f(x) result(y)
         real(8), intent(in) :: x
         real(8) :: y
       end function f
    end interface

    write(*,'("f(", e12.5, ") = ",  e12.5)') x, f(x)

  end subroutine writefunc
```

より実用的な例として二分法のアルゴリズムを実装した以下の様なモジュール(抜粋)を考えよう. `bisection`というサブルーチンは関数$f(x)$を引数として受け取り, $f(x) = 0$の解を求める. このようなモジュールを定義しておけば, $f(x)$の具体的な形が変わってもメインプログラムで`bisection`の引数として渡す関数を変更するだけで良い. このように, 汎用性の高いモジュールを作成しておくことで再利用が非常に簡単になる.

なお, このサブルーチンでは最大の反復回数や許容誤差は`optional`属性の引数となっていることにも着目して欲しい. これらが与えられない場合にはモジュール内で定義されたデフォルトの値を用いるようになっている.

```{style=f90}
module mod_bisection
  implicit none
  private

  integer, parameter :: default_maxit = 50
  real(8), parameter :: default_tol   = 1.0e-8_8

  public :: bisection

contains
  ! 二分法により与えられた方程式の解を求める
  subroutine bisection(f, x1, x2, error, status, maxit, tol)
    implicit none
    real(8), intent(inout) :: x1, x2
    real(8), intent(out) :: error
    integer, intent(out) :: status
    integer, intent(in), optional :: maxit
    real(8), intent(in), optional :: tol
    ! 引数として関数を受け取る
    interface
       function f(x) result(y)
         real(8), intent(in) :: x
         real(8) :: y
       end function f
    end interface

    integer :: i, n
    real(8) :: x, y, sig, tolerance

    ! 最大の反復回数
    if (.not. present(maxit)) then
       n = default_maxit
    else
       n = maxit
    end if

    ! 許容誤差
    if (.not. present(tol)) then
       tolerance = default_tol
    else
       tolerance = tol
    end if

    !
    ! 以下略
    !

  end subroutine bisection

end module mod_bisection
```

なお`bisection.f90`で上記モジュールが定義されており, `sample3.f90`がこれを用いるメインプログラムである. これをコンパイルするには

```{style=shell}
 $ gfortran -c bisection.f90
 $ gfortran -c sample3.f90
 $ gfortran sample3.o bisection.o
```

もしくは

```{style=shell}
 $ gfortran bisection.f90 sample3.f90
```

とすれば良い.

## 計算時間の測定
プログラム全体の実行時間はシェルコマンドで計測できる. 例えば`time`コマンドを用いて以下のように実行すれば良い^[単に`time`とするとシェルの組込みコマンドになってしまうので, `/usr/bin/time`と絶対パスを指定している. シェル組込みの`time`でも問題は無いが, 出力が多少異なるであろう.]. realの行が実際の実行時間を示している. 大雑把には全実行時間のうち, userが自分のプログラムの処理が動いていた時間, sysはOSの処理が動いていた時間を表す.

```{style=shell}
 $ /usr/bin/time ./a.out
        0.98 real         0.97 user         0.00 sys
```

アルゴリズムによる実効速度の違いを検証したり, プログラムのチューニングをするようになってくると, プログラムのある特定の部分の実行時間を測定する必要が出てくる. ここでは`cpu_time`という組込みサブルーチンを使った時間計測のサンプルプログラムを以下に示す.

```{style=f90}
program sample
  implicit none

  integer :: i
  real(8) :: x, y, pi, t1, t2

  call cpu_time(t1)

  do i = 1, 20000000
     pi = 4.0_8 * atan(1.0_8)
     y  = cos(2*pi*x)
     x  = y
  end do

  call cpu_time(t2)

  write(*,'("CPU Time [sec] : ", e12.4)') t2 - t1

  stop
end program sample
```

実行結果は以下のようになる.

```{style=shell}
 $ ./a.out
 CPU Time [sec] :   0.8601E+00
```

サンプルプログラムでは9-12行目の処理にかかる時間を計測している. `cpu_time`の呼び出しによって引数に現在の時刻が秒単位で代入されるので, 計測したい部分の前後でこの値の差をとればよい. ただし正確に計算時間を計測する際には以下のようにいくつか注意が必要である.

- `write`や`read`のようなI/O(入出力)は避ける.これらは非常に時間のかかる処理であるので, 入出力があると純粋な計算時間を正確に測ることが出来ない.
- 計測対象がある程度時間のかかる処理(例えば$\gtrsim 1$秒)であること. `cpu_time`の返す時刻の精度は$1 \mu s$程度である.
- 何度か同じ計測をしてばらつきを見ること. 現在のほぼ全ての計算機はマルチタスクOSであり, 多くの処理を同時に行なっているため, ユーザーが実行しているプログラムの処理に全てのリソースが使われるわけではない. たまたま他のプログラムが走っているタイミングで実行された場合にはパフォーマンスがでない可能性がある.

なお, 細かいことを言うと経過時間(elapsed time), CPU時間(cpu time), システムCPU時間(system cpu time), ユーザーCPU時間(user cpu time)で意味が少しずつ異なることに注意しよう. `cpu_time`で計測されるのはCPU時間である.

## ポインタとデータ構造^†^
ポインタとは簡単に言えば別名である. 即ち, ポインタ変数は他の変数や配列によって保持されているデータ領域のメモリ上のアドレス(番地)を指し示す変数になっている. 例えば, ポインタ変数に対する処理として記述しておけば, ポインタ変数の指し示すアドレスを変更するだけで異なるデータに対する処理を行っていることになる.

しかし, ポインタはこれまで出てきたような処理には敢えて用いる必要が無いので, あまりありがたみを感じられないかもしれない. 実際にはポインタはリストやスタック, キューなどのより複雑な[データ構造]を記述するには必須であるが, そうでなければ必ずしも必要にはならない. ポインタは初心者には少し難しいかもしれないので, 分からなければとりあえずは無視しても良い.

### ポインタ変数
ポインタを用いるには変数宣言に`pointer`属性を指定すれば良い. またポインタが指し指すことの出来る変数(ターゲット変数)には`target`属性を指定する必要がある. 以下の例を考えよう.

```{style=f90}
  integer, pointer :: iptr
  integer, target  :: i, j

  i = 5
  j = 9

  ! 出力は iptr = 5, i = 5, j = 9
  iptr => i
  write(*,'(" iptr = ", i3, ", i = ", i3, ", j = ", i3)') iptr, i, j

  ! 出力は iptr = 9, i = 5, j = 9
  iptr => j
  write(*,'(" iptr = ", i3, ", i = ", i3, ", j = ", i3)') iptr, i, j

  ! 出力は iptr = 0, i = 5, j = 0
  iptr = 0
  write(*,'(" iptr = ", i3, ", i = ", i3, " j, = ", i3)') iptr, i, j
```

8行目の`iptr => i`によって`iptr`は`i`のアドレスを指すことになる(`iptr`が`i`の別名となる)ので, 9行目の出力では"iptr = 5, i = 5, j = 9"となる. 同様に12行目の`iptr => j`によって`iptr`は`j`のアドレスを指すことになる. また, 16行目の`iptr = 0`は`iptr`の指すアドレスへの代入なので, この結果`iptr`だけでなく`j`の値も変更されることになる. この代入文のように, ポインタ変数に対しても通常の変数のように任意の演算が可能である^[C言語のポインタと異なり, `=>`でポインタのアドレスを指定する以外は普通の変数のように使える. これによってポインタであることを意識せずに用いることが出来る. 個人的には逆に分かりにくいように思うのだが.].

なお`nullify`によってポインタ変数とターゲット変数との結合を解除することが出来る. またポインタは*無名領域*(他の変数によって指し示されていない領域)との結合も可能である. これは動的配列の場合と同様に`allocate`によって行い, この場合の結合の解除は(`nullify`では無く)`deallocate`によって行う. また, 結合状態を検査するための組込み関数`associated`も用意されている. この関数はポインタが結合状態であれば真, そうでなければ偽を返す. 従って例えば以下のように使うことが出来る.

```{style=f90}
  if( associated(iptr) ) then
    nullify(iptr)
  end if

  allocate(iptr)
  iptr = 1

  deallocate(iptr)
```

### ポインタ配列
ポインタ配列はターゲット配列と結合させることが出来る. ただし両者の次元は同じでなければならない. ポインタ配列は配列全体を指したり, 部分配列を指したりすることが出来る.

```{style=f90}
  integer :: i, j
  integer :: lb(2), ub(2)
  integer, pointer :: rptr(:,:)
  integer, target :: x(9,9)

  do j = 1, 9
     do i = 1, 9
        x(i,j) = i + (j-1)*9
     end do
  end do

  ! 部分配列へ結合
  rptr => x(2:4,2:6)

  lb = lbound(rptr) ! (/1, 1/)
  ub = ubound(rptr) ! (/3, 5/)

  do j = lb(2), ub(2)
     do i = lb(1), ub(1)
        write(*, fmt='(i7)', advance='no') rptr(i,j)
     end do
     write(*,*)
  end do
```

上の例では13行目において`rptr`を`x`の部分配列と結合させている. ポインタ変数の場合と同様に, `rptr`は`x`への別名となり, このポインタ配列に対するアクセスは`x`の対応する要素へのアクセスと等しくなる.

またポインタ配列に対しても`allocate`による無名領域への結合が出来るので, 動的配列と同様に用いることも可能である^[ただしポインタ配列の場合は`allocatable`とは異なり, スコープから外れた場合に自動で`deallocate`されないようである.].

### データ構造
これまでの例では, ポインタは複雑な割にはありがたみが少ない. 実際にポインタを使う必要性は特に感じられないだろう. ポインタが特に重要となってくるのは柔軟なデータ構造を扱う場合である. 実は配列もデータ構造の一つである. 配列はサイズが固定で, 全ての要素が同じ型のデータの集まりなので比較的簡単に扱うことが出来る. すなわち, 配列の各要素はメモリ上に連続的に配置されているので, 任意の要素への直接アクセス(ランダムアクセス)が可能という長所を持つ(任意の要素のアドレスが簡単に計算出来る). その一方で, 要素をある特定の位置に挿入したい場合にはそれ以降の要素を全てずらさなければならないし, サイズの変更が簡単には出来ないという短所がある.

![List構造.](figure/list.png)

配列とよく対比されるデータ構造として, リスト(list)が知られている. 図に示すようにリスト構造は各要素が他の要素へのポインタ(アドレス)を保持する. 従って, リスト構造では任意の要素(例えば先頭から$N$番目の要素)へのアクセスをしようと思ってもそのアドレスが分からない. すなわち, 常に各要素に対して順番にアクセス(シーケンシャルアクセス)をしなければならない. これは配列に対するリスト構造の短所である. その一方で, 任意の場所への要素の挿入や削除をするにはポインタアドレスの付け替えをするだけで実現出来る. また, リストの末尾に要素を追加するには新しい要素を生成(`allocate`)して, その要素に対するポインタを指定してやれば良い. このような特徴があるため, シーケンシャルアクセスしか必要とされない代わりに, 頻繁にサイズ変更, 要素の挿入・削除があるような用途にはリストが有用となる.

例として, 各要素の値が整数であるリストは以下のように構造型を用いて定義することになる.

```{style=f90}
  type :: list_type
     type(list_type), pointer :: next
     integer :: value
  end type list_type
```

リストの実装(`list.f90`)は少し長くなるのでここには掲載しないが, 地道にポインタを使ってアドレスを付け替えたりするだけである. 以下の例は`list.f90`で実装したモジュール`mod_list`の使い方を示している. リストの伸長は`append`, 要素の挿入は`insert`, 削除は`remove`を用いてなどのモジュール内部手続きによって行うことが出来る. なお10行目ではモジュール内で定義した代入演算子を用いてリストを配列によって初期化している.

```{style=f90}
program sample
  use mod_list
  implicit none

  type(list_type), pointer :: a

  nullify(a)

  write(*, fmt='(a20)', advance='no') 'initialize : '
  a = 1
  call show(a)

  write(*, fmt='(a20)', advance='no') 'append 2 : '
  call append(a, 2)
  call show(a)

  write(*, fmt='(a20)', advance='no') 'append 3 : '
  call append(a, 3)
  call show(a)

  write(*, fmt='(a20)', advance='no') 'insert -1 at 1 : '
  call insert(a, 1, -1)
  call show(a)

  write(*, fmt='(a20)', advance='no') 'insert -2 at 3 : '
  call insert(a, 3, -2)
  call show(a)

  write(*, fmt='(a20)', advance='no') 'remove at 1 : '
  call remove(a, 1)
  call show(a)

  write(*, fmt='(a20)', advance='no') 'remove at 3 : '
  call remove(a, 3)
  call show(a)

  write(*, fmt='(a20)', advance='no') 'delete : '
  call delete(a)
  call show(a)

end program sample
```

このプログラムの実行結果は以下のようになる. 正しくリストの操作が出来ていることが分かるかと思う.

```{style=shell}
  $ ./a.out
       initialize : List = [    1 ]
         append 4 : List = [    1     2 ]
         append 5 : List = [    1     2     3 ]
   insert -1 at 1 : List = [   -1     1     2     3 ]
   insert -2 at 3 : List = [   -1     1    -2     2     3 ]
      remove at 1 : List = [    1    -2     2     3 ]
      remove at 3 : List = [    1    -2     3 ]
           delete : List = []
```

ここではリストの実装例を見たが, 他にもキュー(queue)やスタック(stack), ツリー(tree), ハッシュ(hash)などがよく用いられるデータ構造の例として挙げられる. (これらはあくまでも大まかな分類であり, それぞれに対して更に細かい種類がある. 例えば単にリストと言っても, 片方向リストや双方向リスト, 線形リストや循環リストなどの種類が存在する.)

ただし, 大規模な数値計算においてこのようなデータ構造が用いられることはあまり多くない. なぜなら一般に柔軟なデータ構造を用いる処理は単純な配列に比べて効率が悪いためである. 大規模数値シミュレーションではパフォーマンスが非常に重要となってくるため, 複雑なデータ構造は極力使わずに実装される. しかし, 配列では実装しづらい複雑なアルゴリズムを用いる必要がある場合にはデータ構造の知識も重要になってくるかもしれないので, 興味のある人は勉強してみて欲しい. なおC++を始めとする多くの言語において, *データ構造を扱う標準ライブラリ*(組込み関数のようなもの)が存在している. 従って, 複雑なデータ構造の扱いが必要な場合には大人しくFortranを使うのは諦めて, 他の言語を用いることを推奨する. パフォーマンスが必要な場合にはC++など, そうでないならPythonなどを使うことで開発効率が格段に向上するであろう.

## デバッグのテクニック^†^
### プリプロセッサ
プログラムの開発中(デバッグ中)には一時的にソースコードの一部分をコメントアウトしてその影響を調べたいことが多々あるかと思う. このような時にプリプロセッサと呼ばれる機能を用いると便利である. プリプロセッサとはC/C++のコンパイラが自動的に行う前処理のことであるが, Fortranコンパイラでも多くの場合オプションによってプリプロセッサを有効にすることが出来る. なお, プリプロセッサを使うにはgfortranであれば`-cpp`オプション^[ifortでは`-fpp`.]を付けてコンパイルすれば良い. または拡張子を`.f90`では無く`.F90`とすればオプションを指定しなくても自動的にプリプロセッサが有効になる.

プリプロセッサの機能は様々であるが, 特に簡単で便利なのは以下の様な使い方である.

```{style=f90}
#if 0
  ここはコンパイラに無視されるので何が書いてあっても良い
#endif
```

一時的に実行させたく無い処理については, 上の例のように`#if 0`から`#endif`によって囲むことでコンパイラにその部分を無視させることが出来る. コンパイラに認識させたい時には`0`を`1`に変更するだけで良いので, 特定の処理が結果に与える影響を簡単に調べることが出来る. さらに

```{style=f90}
#if 1
  処理A
#else
  処理B
#endif
```

としておけば, `1`の時には処理A, `0`の時には処理Bをそれぞれコンパイルさせる事が出来る.

プリプロセッサは基本的にC言語で用いられるものと同じなので, *マクロ*という機能も用いることが出来る. 例えば

```{style=f90}
#ifdef _DEBUG
  デバッグ処理
#endif
```

となっている場合に

```{style=shell}
 $ gfortran -cpp -D_DEBUG sample.f90
```

とすれば"デバッグ処理"がコンパイルされる. ここで`-D_DEBUG`は`_DEBUG`というマクロを定義するという意味である. マクロを用いたプリプロセッサには様々な機能があり, より複雑な指定も可能である.

```{style=f90}
#if   _DEBUG_MODE == 0
  デバッグモード0
#elif _DEBUG_MODE == 1
  デバッグモード1
#elif _DEBUG_MODE == 2
  デバッグモード2
#endif
```

のような場合には, `_DEBUG_MODE`という名前のマクロの値^[変数のように見えるが, プリプロセッサで(コンパイルされる前に)処理されるのでプログラム中の変数にはなっていない.]によってコンパイルする処理を切り替えることが出来る. マクロの値もコマンドラインから明示的に与えることが出来る. 例えば

```{style=shell}
 $ gfortran -cpp -D_DEBUG_MODE=1 sample.f90
```

のように実行すれば, マクロ`_DEBUG_MODE`の値が1に定義され, "デバッグモード1"の処理がコンパイルされる.

### printfデバッグ
デバッグの基本中の基本テクニックは`printf`デバッグと呼ばれる. `printf`とはC言語で標準出力に表示するための関数名で, 要するに間違っていそうな箇所に当たりをつけて, 途中結果を出力して確認するという古典的な手法である. Fortranの場合にはひたすら`write(*,*)`で怪しい変数を出力してみれば大抵の場合(すくなくとも演習の課題レベルの場合)には自ずとバグの原因が見えてくる^[演習中にディスプレイの前でフリーズしている人を良く見かけるが, 考えているだけでは何も進まない. とりあえずヒントを探すという意味で値を出力するのは非常に重要である.].

このデバッグ手法はプリプロセッサと組み合わせると便利である. 例えば

```{style=f90}
#ifdef _DEBUG
#define DEBUG_PRINT(a) write(*,*) (a)
#else
#define DEBUG_PRINT(a)
#endif
```

としておくと, 任意の場所で

```{style=f90}
  DEBUG_PRINT(出力したい変数)
```

のように`DEBUG_PRINT`というマクロを関数(サブルーチン)のように用いることが出来る. この時, コンパイル時にオプション`-D_DEBUG`を付けると`DEBUG_PRINT`の引数に与えた変数の値が出力されるが, `-D_DEBUG`を付けなければ何も出力されない. つまり, この形式でデバッグメッセージを埋め込んでおけば, ソースコードを一切修正することなく, コマンドラインのみでデバッグモードに切り替えることが出来る. (これは`_DEBUG`というマクロが定義されている場合には, `DEBUG_PRINT(x)`が`write(*,*) (x)`に変換され, それ以外の場合は単なるホワイトスペース(空白)に変換されるためである.)

このようなテクニックは非常に有用で, 開発効率を大幅に高めてくれるハズなので, 少しずつ身につけていくと良い.

### gdb
To be written.

## C言語とのリンク^†^
To be written.

## Fortran 77について^†^
To be written.

<!--
## バージョン管理
-->

<!--
Local Variables:
fill-column: nil
End:
-->
