.. -*- coding: utf-8 -*-

.. highlight:: fortran
  :linenothreshold: 1

========
制御構造
========

ここではプログラムの動作を制御するための文法について学ぼう. と言っても覚えなければいけないことは ``if`` による条件分岐, ``do`` による繰り返し, ``select`` による条件分岐のみである. ``goto`` という構文も存在するのだが, これはバグのもとになることから一般的には使わないほうが良いとされており, 従ってここでも敢えて扱わない.

    サンプルプログラム

    - `sample1.f90 <sample/chap04/sample1.f90>`_ : 条件分岐(if)
    - `sample2.f90 <sample/chap04/sample2.f90>`_ : 反復処理(doループ1)
    - `sample3.f90 <sample/chap04/sample3.f90>`_ : 反復処理(doループ2)
    - `sample4.f90 <sample/chap04/sample4.f90>`_ : 反復処理(doループ3)
    - `sample5.f90 <sample/chap04/sample5.f90>`_ : 条件分岐(select)

.. contents:: この章の内容
    :depth: 2

条件分岐(if)
------------

``if`` による条件分岐は例えばユーザーの入力によって動作を変更する場合などに用いる. 典型的な使い方は以下のようなものである.

::

      integer :: n

      read(*,*) n  ! 整数値を標準入力から読み込む

      if ( n == 0 ) then
        write(*,*) n, 'is zero'
      else if ( n > 0 ) then
        write(*,*) n, 'is positive'
      else if ( n < 0 ) then
        write(*,*) n, 'is negative'
      end if

このように ``if`` に続く ``()`` の中に条件式(conditional)を記述し, その条件が真( ``.true.``)の時には ``then`` に続く処理が実行され, 偽( ``.false.``)の時には ``else if`` 以下で更に条件判定をすることになる. また

::

      if( conditional ) then
        ! 処理
      end if

や

::

      if( conditional ) then
        ! 処理1
      else
        ! 処理2
      end if

の用に書くことも出来る. 構文自体はそれほど難しくないので, ここで注意すべきは条件判定の部分だけであろう. 以下の表に条件式に用いられることの多い演算子をまとめてある. なおFortran 77では ``>`` のような演算子(関係演算子と呼ばれる)は正式にはサポートされていなかった. このため古いコードには ``.gt.`` のような演算子を見かけることもあるかも知れないが, 自分で新しくプログラムを作成する際にはこのような古い形式は使うべきではない. 新しい形式は ``/=`` 以外のものについてはC言語を始めとする他の多くの言語と同じなのでこちらを用いることを強く推奨する. ちなみにC言語などでは ``/=`` ではなく ``!=`` が用いられる.

特に実数の値が等しいかどうかを判定する際には注意が必要である. すなわち, 実数に対しては ``==`` を使うことは出来ない. なぜなら2つの実数がほぼ等しいように見えても ``==`` による判定では全てのビットが厳密に等しくなければ真とは判定されないからである. 従って, 代わりに例えば差の絶対値 ``abs(A-B)`` が十分小さいかどうかで判定しなくてはならない [#]_.

.. tabularcolumns:: |p{0.3 \textwidth}|p{0.3 \textwidth}|p{0.3 \textwidth}|
.. list-table:: 条件演算子
    :widths: 30, 30, 30
    :header-rows: 1

    * - 演算子
      - Fortran 77形式
      - 意味

    * - ``A >  B``
      - ``A .gt. B``
      - ``A`` の方が ``B`` よりも大きければ真

    * - ``A >= B``
      - ``A .ge. B``
      - ``A`` が ``B`` 以上であれば真

    * - ``A <  B``
      - ``A .lt. B``
      - ``A`` の方が ``B`` よりも小さければ真

    * - ``A <= B``
      - ``A .le. B``
      - ``A`` が ``B`` 以下であれば真

    * - ``A == B``
      - ``A .eq. B``
      - ``A`` と ``B`` が厳密に等しければ真

    * - ``A /= B``
      - ``A .ne. B``
      - ``A`` と ``B`` が等しくなければ真


また条件判定が複雑な時には以下の論理演算子を用いることになるだろう.

.. tabularcolumns:: |p{0.3 \textwidth}|p{0.3 \textwidth}|p{0.3 \textwidth}|
.. list-table:: 論理演算子
    :widths: 30, 30, 30
    :header-rows: 1

    * - 演算子
      - 意味
      - 使い方

    * - ``.and.``
      - 論理積
      - ``(条件式1) .and. (条件式2)``

    * - ``.or.``
      - 論理和
      - ``(条件式1) .or.  (条件式2)``

    * - ``.not.``
      - 否定
      - ``.not. (条件式)``

    * - ``.eqv.``
      - 論理等価
      - ``(条件式1) .eqv. (条件式2)``

    * - ``.neqv.``
      - 論理非等価
      - ``(条件式1) .neqv. (条件式2)``

使い方は例えば

::

      integer :: n

      if ( 2 < n .and. n < 5 ) then
        write(*,*) 'n is larger than 2 and smaller than 5'
      end if

と言った具合である. ``2 < n < 5`` のような数学的な書き方はできないので注意が必要である.

さらに複雑な条件分岐の場合には以下のように ``if`` 文を入れ子で使うことも出来る.

::

      if ( conditional 1 ) then
        if ( conditional 2 ) then
          ! 処理1
        else
          ! 処理2
        end if
      end if

ただし何重にも深く入れ子になった ``if`` 文の実行効率はあまり良くないので出来るかぎり浅い条件分岐に留めておいた方が良い.

反復処理
--------

.. _c4_do:

決まった回数の繰り返し(do)
~~~~~~~~~~~~~~~~~~~~~~~~~~

決まった繰り返しの処理をするために用いるのが ``do`` (従ってこの反復処理は``do`` ループと呼ばれる)である. これも使い方は至ってシンプルである.

::

      integer :: i

      do i = 1, 10, 2
        write(*,*) i
      end do

とすれば ``1, 3, 5, 7, 9`` が出力される. より一般には

::

      do i = lower, upper, stride
        ! 繰り返し処理
      end do

のような形で書くことになる. 上の例では整数型変数 ``i`` は ``do`` 変数と呼ばれ, ``do`` ループの中で ``i`` の値が ``lower`` から ``upper`` まで ``stride`` ずつ変化する. ``stride`` は省略することも可能であり, その場合は ``1`` と解釈される. また ``stride`` は負の値であっても良い(当然この時は ``lower > upper`` でなければループ内の処理は実行されない). 通常 ``do`` 変数は整数型でなければならないが, 実数型などでもコンパイル出来てしまう環境もあり, そのような場合は思わぬバグの原因となってしまう. 間違いを未然に防ぐためにも ``do`` 変数には整数型を用いること.

また ``if`` 文の場合と同様に ``do`` ループに関しても以下のように入れ子(多重ループ)にすることが出来る.

::

      integer :: i, j

      do i = 1, 9
        do j = 1, 9
          write(*,*) i, j, i*j
        end do
      end do

条件を指定した繰り返し(do while)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

繰り返しの処理には基本的に先ほどの ``do`` ループを用いれば良いのだが, これを少し違った形式で行う ``do while`` なる構文も用意されている. これは

::

      do while( conditional )
        ! 繰り返し処理
      end do

のような形で用い, ``()`` 内の条件式が真( ``.true.``)の間は繰り返し処理が行われる. 例えば

::

      integer :: i

      i = 1
      do while(i < 10)
        write(*,*) i
        i = i + 2
      end do

の例では ``1, 3, 5, 7, 9`` が出力されることになる. 繰り返し回数が予め分からない処理ではこのような形式を用いるとスマートに書ける場面にもしばしば遭遇する. 例えば反復計算によって実数型の値の収束判定をする場合などは

::

      real(8) :: x

      do while(abs(x) > 1.0e-8_8)
        ! 繰り返し処理
      end do

などのように非常にスッキリと記述できる. この例では ``abs(x)`` の値が :math:`10^{-8}` 以下になるまで反復を続ける.

複雑な処理(exitとcycle)
~~~~~~~~~~~~~~~~~~~~~~~

単純な繰り返しだけでなく, より柔軟な制御を行うには ``exit`` や ``cycle`` を用いる. ``exit`` では ``do`` ループの中から途中で抜けることが出来, ``cycle`` ではループ内のそれ以降の処理を行わずにループ先頭に戻ることがで出来る. これらを用いると意図的に作った無限ループから条件を満たした時だけ抜け出すようなプログラムも簡単に作ることができる. 例えば以下の例を見てみよう.

::

      integer :: i

      do while( .true. )        ! 無限ループ
        read(*,*) i             ! 標準入力から整数値を読み込む

        if ( i == 0 ) then
          exit                  ! 0ならループを抜ける
        else if ( i < 0 ) then
          cycle                 ! 負ならループ先頭(4行目)に戻る
        end if

        write(*,*) i            ! 値を標準出力に表示
      end do

この例では標準入力からの整数の入力値が正の時だけその値を表示し, 負の時は表示しない. また0を入力値として受け取るとループを抜けるようになっている. なお, 同じ処理を実現する方法は1つとは限らない. 例えば, 以下のループも全く同じ処理を行っていることが分かるかと思う.

::

      integer :: i

      read(*,*) i

      do while( i /= 0 )
        if ( i > 0 ) then
          write(*,*) i
        end if

        read(*,*) i
      end do

このように複数の方法がある場合にはより分かりやすい方(すなわち間違いが発生しにくい方)を採用すれば良い.

条件分岐(select)
----------------

``select`` 構文を用いても条件分岐を行うことも出来る. 基本的には ``if`` を用いれば同じことは実現出来るのだが, 場合によっては ``select`` を用いた方がよりスッキリとした形で書ける事があるので知っておいて損はない. 典型的には整数や文字列の値で場合分けを制御する際に用いる(実数型には用いることは出来ない). 以下は入力された整数 ``score`` (テストの点だと思おう)の値によって場合分けをする例である.

::

      integer :: score

      read(*,*) score

      select case(score)
      case(0)              ! 0点
         write(*,*) 'zero'
      case(1:29)           ! 1-29点
         write(*,*) 'poor'
      case(30:59)          ! 30-59点
         write(*,*) 'fair'
      case(60:89)          ! 60-89点
         write(*,*) 'good'
      case(90:100)         ! 90-100点
         write(*,*) 'excellent'
      case default         ! それ以外
         write(*,*) 'invalid input'
      end select

``case`` では単一の値もしくは値の範囲を指定する. 範囲の指定は ``case(下限:上限)`` のような形ですれば良い. また指定した範囲外の値に対する処理は ``case deafault`` によって行えば良い.

::

      character(len=128) :: input

      read(*,*) input

      select case(input)
      case('apple', 'orange', 'banana')
         write(*,*) 'food'
      case('earth', 'mars', 'venus')
         write(*,*) 'planet'
      case default
         write(*,*) 'others'
      end select

上の例は文字列の値によって分岐する例である. このように1つの ``case`` で複数の値をカンマで区切って指定することも出来る.

----

.. [#]

   ``abs(x)`` は ``x`` の絶対値を返す組込み関数である.
